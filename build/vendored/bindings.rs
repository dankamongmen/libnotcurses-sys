/* automatically generated by rust-bindgen 0.60.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _TIME_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _STDC_PREDEF_H: u32 = 1;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _CTYPE_H: u32 = 1;
pub const _WCHAR_H: u32 = 1;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const FILENAME_MAX: u32 = 4096;
pub const FOPEN_MAX: u32 = 16;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const _STDLIB_H: u32 = 1;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _STRING_H: u32 = 1;
pub const _NSIG: u32 = 65;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const _XOPEN_LIM_H: u32 = 1;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _NETINET_IN_H: u32 = 1;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const _ENDIAN_H: u32 = 1;
pub const _BYTESWAP_H: u32 = 1;
pub const PRETERUNICODEBASE: u32 = 1115000;
pub const NCKEY_TAB: u32 = 9;
pub const NCKEY_ESC: u32 = 27;
pub const NCKEY_SPACE: u32 = 32;
pub const NCKEY_MOD_SHIFT: u32 = 1;
pub const NCKEY_MOD_ALT: u32 = 2;
pub const NCKEY_MOD_CTRL: u32 = 4;
pub const NCKEY_MOD_SUPER: u32 = 8;
pub const NCKEY_MOD_HYPER: u32 = 16;
pub const NCKEY_MOD_META: u32 = 32;
pub const NCKEY_MOD_CAPSLOCK: u32 = 64;
pub const NCKEY_MOD_NUMLOCK: u32 = 128;
pub const NCBOXLIGHTW: &[u8; 19usize] =
    b"\xE2\x94\x8C\xE2\x94\x90\xE2\x94\x94\xE2\x94\x98\xE2\x94\x80\xE2\x94\x82\0";
pub const NCBOXHEAVYW: &[u8; 19usize] =
    b"\xE2\x94\x8F\xE2\x94\x93\xE2\x94\x97\xE2\x94\x9B\xE2\x94\x81\xE2\x94\x83\0";
pub const NCBOXROUNDW: &[u8; 19usize] =
    b"\xE2\x95\xAD\xE2\x95\xAE\xE2\x95\xB0\xE2\x95\xAF\xE2\x94\x80\xE2\x94\x82\0";
pub const NCBOXDOUBLEW: &[u8; 19usize] =
    b"\xE2\x95\x94\xE2\x95\x97\xE2\x95\x9A\xE2\x95\x9D\xE2\x95\x90\xE2\x95\x91\0";
pub const NCBOXASCIIW: &[u8; 7usize] = b"/\\\\/-|\0";
pub const NCBOXOUTERW : & [u8 ; 32usize] = b"\xF0\x9F\xAD\xBD\xF0\x9F\xAD\xBE\xF0\x9F\xAD\xBC\xF0\x9F\xAD\xBF\xE2\x96\x81\xF0\x9F\xAD\xB5\xF0\x9F\xAD\xB6\xF0\x9F\xAD\xB0\0" ;
pub const NCWHITESQUARESW: &[u8; 13usize] = b"\xE2\x97\xB2\xE2\x97\xB1\xE2\x97\xB3\xE2\x97\xB0\0";
pub const NCWHITECIRCLESW: &[u8; 13usize] = b"\xE2\x97\xB6\xE2\x97\xB5\xE2\x97\xB7\xE2\x97\xB4\0";
pub const NCCIRCULARARCSW: &[u8; 13usize] = b"\xE2\x97\x9C\xE2\x97\x9D\xE2\x97\x9F\xE2\x97\x9E\0";
pub const NCWHITETRIANGLESW: &[u8; 13usize] = b"\xE2\x97\xBF\xE2\x97\xBA\xE2\x97\xB9\xE2\x97\xB8\0";
pub const NCBLACKTRIANGLESW: &[u8; 13usize] = b"\xE2\x97\xA2\xE2\x97\xA3\xE2\x97\xA5\xE2\x97\xA4\0";
pub const NCSHADETRIANGLESW: &[u8; 17usize] =
    b"\xF0\x9F\xAE\x9E\xF0\x9F\xAE\x9F\xF0\x9F\xAE\x9D\xF0\x9F\xAE\x9C\0";
pub const NCBLACKARROWHEADSW: &[u8; 13usize] =
    b"\xE2\xAE\x9D\xE2\xAE\x9F\xE2\xAE\x9C\xE2\xAE\x9E\0";
pub const NCLIGHTARROWHEADSW: &[u8; 13usize] =
    b"\xE2\xAE\x99\xE2\xAE\x9B\xE2\xAE\x98\xE2\xAE\x9A\0";
pub const NCARROWDOUBLEW: &[u8; 13usize] = b"\xE2\xAE\x85\xE2\xAE\x87\xE2\xAE\x84\xE2\xAE\x86\0";
pub const NCARROWDASHEDW: &[u8; 13usize] = b"\xE2\xAD\xAB\xE2\xAD\xAD\xE2\xAD\xAA\xE2\xAD\xAC\0";
pub const NCARROWCIRCLEDW: &[u8; 13usize] = b"\xE2\xAE\x89\xE2\xAE\x8B\xE2\xAE\x88\xE2\xAE\x8A\0";
pub const NCARROWANTICLOCKW: &[u8; 13usize] = b"\xE2\xAE\x8F\xE2\xAE\x8D\xE2\xAE\x8E\xE2\xAE\x8C\0";
pub const NCBOXDRAWW: &[u8; 13usize] = b"\xE2\x95\xB5\xE2\x95\xB7\xE2\x95\xB4\xE2\x95\xB6\0";
pub const NCBOXDRAWHEAVYW: &[u8; 13usize] = b"\xE2\x95\xB9\xE2\x95\xBB\xE2\x95\xB8\xE2\x95\xBA\0";
pub const NCARROWW : & [u8 ; 25usize] = b"\xE2\xAD\xA1\xE2\xAD\xA3\xE2\xAD\xA0\xE2\xAD\xA2\xE2\xAD\xA7\xE2\xAD\xA9\xE2\xAD\xA6\xE2\xAD\xA8\0" ;
pub const NCDIAGONALSW : & [u8 ; 33usize] = b"\xF0\x9F\xAE\xA3\xF0\x9F\xAE\xA0\xF0\x9F\xAE\xA1\xF0\x9F\xAE\xA2\xF0\x9F\xAE\xA4\xF0\x9F\xAE\xA5\xF0\x9F\xAE\xA6\xF0\x9F\xAE\xA7\0" ;
pub const NCDIGITSSUPERW : & [u8 ; 28usize] = b"\xE2\x81\xB0\xC2\xB9\xC2\xB2\xC2\xB3\xE2\x81\xB4\xE2\x81\xB5\xE2\x81\xB6\xE2\x81\xB7\xE2\x81\xB8\xE2\x81\xB9\0" ;
pub const NCDIGITSSUBW : & [u8 ; 31usize] = b"\xE2\x82\x80\xE2\x82\x81\xE2\x82\x82\xE2\x82\x83\xE2\x82\x84\xE2\x82\x85\xE2\x82\x86\xE2\x82\x87\xE2\x82\x88\xE2\x82\x89\0" ;
pub const NCASTERISKS5 : & [u8 ; 25usize] = b"\xF0\x9F\x9E\xAF\xF0\x9F\x9E\xB0\xF0\x9F\x9E\xB1\xF0\x9F\x9E\xB2\xF0\x9F\x9E\xB3\xF0\x9F\x9E\xB4\0" ;
pub const NCASTERISKS6 : & [u8 ; 25usize] = b"\xF0\x9F\x9E\xB5\xF0\x9F\x9E\xB6\xF0\x9F\x9E\xB7\xF0\x9F\x9E\xB8\xF0\x9F\x9E\xB9\xF0\x9F\x9E\xBA\0" ;
pub const NCASTERISKS8 : & [u8 ; 24usize] = b"\xF0\x9F\x9E\xBB\xF0\x9F\x9E\xBC\xE2\x9C\xB3\xF0\x9F\x9E\xBD\xF0\x9F\x9E\xBE\xF0\x9F\x9E\xBF\0" ;
pub const NCANGLESBR : & [u8 ; 45usize] = b"\xF0\x9F\xAD\x81\xF0\x9F\xAD\x82\xF0\x9F\xAD\x83\xF0\x9F\xAD\x84\xF0\x9F\xAD\x85\xF0\x9F\xAD\x86\xF0\x9F\xAD\x87\xF0\x9F\xAD\x88\xF0\x9F\xAD\x89\xF0\x9F\xAD\x8A\xF0\x9F\xAD\x8B\0" ;
pub const NCANGLESTR : & [u8 ; 45usize] = b"\xF0\x9F\xAD\x92\xF0\x9F\xAD\x93\xF0\x9F\xAD\x94\xF0\x9F\xAD\x95\xF0\x9F\xAD\x96\xF0\x9F\xAD\xA7\xF0\x9F\xAD\xA2\xF0\x9F\xAD\xA3\xF0\x9F\xAD\xA4\xF0\x9F\xAD\xA5\xF0\x9F\xAD\xA6\0" ;
pub const NCANGLESBL : & [u8 ; 45usize] = b"\xF0\x9F\xAD\x8C\xF0\x9F\xAD\x8D\xF0\x9F\xAD\x8E\xF0\x9F\xAD\x8F\xF0\x9F\xAD\x90\xF0\x9F\xAD\x91\xF0\x9F\xAC\xBC\xF0\x9F\xAC\xBD\xF0\x9F\xAC\xBE\xF0\x9F\xAC\xBF\xF0\x9F\xAD\x80\0" ;
pub const NCANGLESTL : & [u8 ; 45usize] = b"\xF0\x9F\xAD\x9D\xF0\x9F\xAD\x9E\xF0\x9F\xAD\x9F\xF0\x9F\xAD\xA0\xF0\x9F\xAD\xA1\xF0\x9F\xAD\x9C\xF0\x9F\xAD\x97\xF0\x9F\xAD\x98\xF0\x9F\xAD\x99\xF0\x9F\xAD\x9A\xF0\x9F\xAD\x9B\0" ;
pub const NCEIGHTHSB : & [u8 ; 26usize] = b" \xE2\x96\x81\xE2\x96\x82\xE2\x96\x83\xE2\x96\x84\xE2\x96\x85\xE2\x96\x86\xE2\x96\x87\xE2\x96\x88\0" ;
pub const NCEIGHTHST : & [u8 ; 31usize] = b" \xE2\x96\x94\xF0\x9F\xAE\x82\xF0\x9F\xAE\x83\xE2\x96\x80\xF0\x9F\xAE\x84\xF0\x9F\xAE\x85\xF0\x9F\xAE\x86\xE2\x96\x88\0" ;
pub const NCEIGHTHSL : & [u8 ; 25usize] = b"\xE2\x96\x8F\xE2\x96\x8E\xE2\x96\x8D\xE2\x96\x8C\xE2\x96\x8B\xE2\x96\x8A\xE2\x96\x89\xE2\x96\x88\0" ;
pub const NCEIGHTHSR : & [u8 ; 30usize] = b"\xE2\x96\x95\xF0\x9F\xAE\x87\xF0\x9F\xAE\x88\xE2\x96\x90\xF0\x9F\xAE\x89\xF0\x9F\xAE\x8A\xF0\x9F\xAE\x8B\xE2\x96\x88\0" ;
pub const NCHALFBLOCKS: &[u8; 11usize] = b" \xE2\x96\x80\xE2\x96\x84\xE2\x96\x88\0";
pub const NCQUADBLOCKS : & [u8 ; 47usize] = b" \xE2\x96\x98\xE2\x96\x9D\xE2\x96\x80\xE2\x96\x96\xE2\x96\x8C\xE2\x96\x9E\xE2\x96\x9B\xE2\x96\x97\xE2\x96\x9A\xE2\x96\x90\xE2\x96\x9C\xE2\x96\x84\xE2\x96\x99\xE2\x96\x9F\xE2\x96\x88\0" ;
pub const NCSEXBLOCKS : & [u8 ; 247usize] = b" \xF0\x9F\xAC\x80\xF0\x9F\xAC\x81\xF0\x9F\xAC\x82\xF0\x9F\xAC\x83\xF0\x9F\xAC\x84\xF0\x9F\xAC\x85\xF0\x9F\xAC\x86\xF0\x9F\xAC\x87\xF0\x9F\xAC\x88\xF0\x9F\xAC\x8A\xF0\x9F\xAC\x8B\xF0\x9F\xAC\x8C\xF0\x9F\xAC\x8D\xF0\x9F\xAC\x8E\xF0\x9F\xAC\x8F\xF0\x9F\xAC\x90\xF0\x9F\xAC\x91\xF0\x9F\xAC\x92\xF0\x9F\xAC\x93\xE2\x96\x8C\xF0\x9F\xAC\x94\xF0\x9F\xAC\x95\xF0\x9F\xAC\x96\xF0\x9F\xAC\x97\xF0\x9F\xAC\x98\xF0\x9F\xAC\x99\xF0\x9F\xAC\x9A\xF0\x9F\xAC\x9B\xF0\x9F\xAC\x9C\xF0\x9F\xAC\x9D\xF0\x9F\xAC\x9E\xF0\x9F\xAC\x9F\xF0\x9F\xAC\xA0\xF0\x9F\xAC\xA1\xF0\x9F\xAC\xA2\xF0\x9F\xAC\xA3\xF0\x9F\xAC\xA4\xF0\x9F\xAC\xA5\xF0\x9F\xAC\xA6\xF0\x9F\xAC\xA7\xE2\x96\x90\xF0\x9F\xAC\xA8\xF0\x9F\xAC\xA9\xF0\x9F\xAC\xAA\xF0\x9F\xAC\xAB\xF0\x9F\xAC\xAC\xF0\x9F\xAC\xAD\xF0\x9F\xAC\xAE\xF0\x9F\xAC\xAF\xF0\x9F\xAC\xB0\xF0\x9F\xAC\xB1\xF0\x9F\xAC\xB2\xF0\x9F\xAC\xB3\xF0\x9F\xAC\xB4\xF0\x9F\xAC\xB5\xF0\x9F\xAC\xB6\xF0\x9F\xAC\xB7\xF0\x9F\xAC\xB8\xF0\x9F\xAC\xB9\xF0\x9F\xAC\xBA\xF0\x9F\xAC\xBB\xE2\x96\x88\0" ;
pub const NCBRAILLEEGCS : & [u8 ; 769usize] = b"\xE2\xA0\x80\xE2\xA0\x81\xE2\xA0\x88\xE2\xA0\x89\xE2\xA0\x82\xE2\xA0\x83\xE2\xA0\x8A\xE2\xA0\x8B\xE2\xA0\x90\xE2\xA0\x91\xE2\xA0\x98\xE2\xA0\x99\xE2\xA0\x92\xE2\xA0\x93\xE2\xA0\x9A\xE2\xA0\x9B\xE2\xA0\x84\xE2\xA0\x85\xE2\xA0\x8C\xE2\xA0\x8D\xE2\xA0\x86\xE2\xA0\x87\xE2\xA0\x8E\xE2\xA0\x8F\xE2\xA0\x94\xE2\xA0\x95\xE2\xA0\x9C\xE2\xA0\x9D\xE2\xA0\x96\xE2\xA0\x97\xE2\xA0\x9E\xE2\xA0\x9F\xE2\xA0\xA0\xE2\xA0\xA1\xE2\xA0\xA8\xE2\xA0\xA9\xE2\xA0\xA2\xE2\xA0\xA3\xE2\xA0\xAA\xE2\xA0\xAB\xE2\xA0\xB0\xE2\xA0\xB1\xE2\xA0\xB8\xE2\xA0\xB9\xE2\xA0\xB2\xE2\xA0\xB3\xE2\xA0\xBA\xE2\xA0\xBB\xE2\xA0\xA4\xE2\xA0\xA5\xE2\xA0\xAC\xE2\xA0\xAD\xE2\xA0\xA6\xE2\xA0\xA7\xE2\xA0\xAE\xE2\xA0\xAF\xE2\xA0\xB4\xE2\xA0\xB5\xE2\xA0\xBC\xE2\xA0\xBD\xE2\xA0\xB6\xE2\xA0\xB7\xE2\xA0\xBE\xE2\xA0\xBF\xE2\xA1\x80\xE2\xA1\x81\xE2\xA1\x88\xE2\xA1\x89\xE2\xA1\x82\xE2\xA1\x83\xE2\xA1\x8A\xE2\xA1\x8B\xE2\xA1\x90\xE2\xA1\x91\xE2\xA1\x98\xE2\xA1\x99\xE2\xA1\x92\xE2\xA1\x93\xE2\xA1\x9A\xE2\xA1\x9B\xE2\xA1\x84\xE2\xA1\x85\xE2\xA1\x8C\xE2\xA1\x8D\xE2\xA1\x86\xE2\xA1\x87\xE2\xA1\x8E\xE2\xA1\x8F\xE2\xA1\x94\xE2\xA1\x95\xE2\xA1\x9C\xE2\xA1\x9D\xE2\xA1\x96\xE2\xA1\x97\xE2\xA1\x9E\xE2\xA1\x9F\xE2\xA1\xA0\xE2\xA1\xA1\xE2\xA1\xA8\xE2\xA1\xA9\xE2\xA1\xA2\xE2\xA1\xA3\xE2\xA1\xAA\xE2\xA1\xAB\xE2\xA1\xB0\xE2\xA1\xB1\xE2\xA1\xB8\xE2\xA1\xB9\xE2\xA1\xB2\xE2\xA1\xB3\xE2\xA1\xBA\xE2\xA1\xBB\xE2\xA1\xA4\xE2\xA1\xA5\xE2\xA1\xAC\xE2\xA1\xAD\xE2\xA1\xA6\xE2\xA1\xA7\xE2\xA1\xAE\xE2\xA1\xAF\xE2\xA1\xB4\xE2\xA1\xB5\xE2\xA1\xBC\xE2\xA1\xBD\xE2\xA1\xB6\xE2\xA1\xB7\xE2\xA1\xBE\xE2\xA1\xBF\xE2\xA2\x80\xE2\xA2\x81\xE2\xA2\x88\xE2\xA2\x89\xE2\xA2\x82\xE2\xA2\x83\xE2\xA2\x8A\xE2\xA2\x8B\xE2\xA2\x90\xE2\xA2\x91\xE2\xA2\x98\xE2\xA2\x99\xE2\xA2\x92\xE2\xA2\x93\xE2\xA2\x9A\xE2\xA2\x9B\xE2\xA2\x84\xE2\xA2\x85\xE2\xA2\x8C\xE2\xA2\x8D\xE2\xA2\x86\xE2\xA2\x87\xE2\xA2\x8E\xE2\xA2\x8F\xE2\xA2\x94\xE2\xA2\x95\xE2\xA2\x9C\xE2\xA2\x9D\xE2\xA2\x96\xE2\xA2\x97\xE2\xA2\x9E\xE2\xA2\x9F\xE2\xA2\xA0\xE2\xA2\xA1\xE2\xA2\xA8\xE2\xA2\xA9\xE2\xA2\xA2\xE2\xA2\xA3\xE2\xA2\xAA\xE2\xA2\xAB\xE2\xA2\xB0\xE2\xA2\xB1\xE2\xA2\xB8\xE2\xA2\xB9\xE2\xA2\xB2\xE2\xA2\xB3\xE2\xA2\xBA\xE2\xA2\xBB\xE2\xA2\xA4\xE2\xA2\xA5\xE2\xA2\xAC\xE2\xA2\xAD\xE2\xA2\xA6\xE2\xA2\xA7\xE2\xA2\xAE\xE2\xA2\xAF\xE2\xA2\xB4\xE2\xA2\xB5\xE2\xA2\xBC\xE2\xA2\xBD\xE2\xA2\xB6\xE2\xA2\xB7\xE2\xA2\xBE\xE2\xA2\xBF\xE2\xA3\x80\xE2\xA3\x81\xE2\xA3\x88\xE2\xA3\x89\xE2\xA3\x82\xE2\xA3\x83\xE2\xA3\x8A\xE2\xA3\x8B\xE2\xA3\x90\xE2\xA3\x91\xE2\xA3\x98\xE2\xA3\x99\xE2\xA3\x92\xE2\xA3\x93\xE2\xA3\x9A\xE2\xA3\x9B\xE2\xA3\x84\xE2\xA3\x85\xE2\xA3\x8C\xE2\xA3\x8D\xE2\xA3\x86\xE2\xA3\x87\xE2\xA3\x8E\xE2\xA3\x8F\xE2\xA3\x94\xE2\xA3\x95\xE2\xA3\x9C\xE2\xA3\x9D\xE2\xA3\x96\xE2\xA3\x97\xE2\xA3\x9E\xE2\xA3\x9F\xE2\xA3\xA0\xE2\xA3\xA1\xE2\xA3\xA8\xE2\xA3\xA9\xE2\xA3\xA2\xE2\xA3\xA3\xE2\xA3\xAA\xE2\xA3\xAB\xE2\xA3\xB0\xE2\xA3\xB1\xE2\xA3\xB8\xE2\xA3\xB9\xE2\xA3\xB2\xE2\xA3\xB3\xE2\xA3\xBA\xE2\xA3\xBB\xE2\xA3\xA4\xE2\xA3\xA5\xE2\xA3\xAC\xE2\xA3\xAD\xE2\xA3\xA6\xE2\xA3\xA7\xE2\xA3\xAE\xE2\xA3\xAF\xE2\xA3\xB4\xE2\xA3\xB5\xE2\xA3\xBC\xE2\xA3\xBD\xE2\xA3\xB6\xE2\xA3\xB7\xE2\xA3\xBE\xE2\xA3\xBF\0" ;
pub const NCSEGDIGITS : & [u8 ; 41usize] = b"\xF0\x9F\xAF\xB0\xF0\x9F\xAF\xB1\xF0\x9F\xAF\xB2\xF0\x9F\xAF\xB3\xF0\x9F\xAF\xB4\xF0\x9F\xAF\xB5\xF0\x9F\xAF\xB6\xF0\x9F\xAF\xB7\xF0\x9F\xAF\xB8\xF0\x9F\xAF\xB9\0" ;
pub const NCSUITSBLACK: &[u8; 13usize] = b"\xE2\x99\xA0\xE2\x99\xA3\xE2\x99\xA5\xE2\x99\xA6\0";
pub const NCSUITSWHITE: &[u8; 13usize] = b"\xE2\x99\xA1\xE2\x99\xA2\xE2\x99\xA4\xE2\x99\xA7\0";
pub const NCCHESSBLACK: &[u8; 19usize] =
    b"\xE2\x99\x9F\xE2\x99\x9C\xE2\x99\x9E\xE2\x99\x9D\xE2\x99\x9B\xE2\x99\x9A\0";
pub const NCCHESSWHITE: &[u8; 19usize] =
    b"\xE2\x99\x9F\xE2\x99\x9C\xE2\x99\x9E\xE2\x99\x9D\xE2\x99\x9B\xE2\x99\x9A\0";
pub const NCDICE: &[u8; 19usize] =
    b"\xE2\x9A\x80\xE2\x9A\x81\xE2\x9A\x82\xE2\x9A\x83\xE2\x9A\x84\xE2\x9A\x85\0";
pub const NCMUSICSYM: &[u8; 22usize] =
    b"\xE2\x99\xA9\xE2\x99\xAA\xE2\x99\xAB\xE2\x99\xAC\xE2\x99\xAD\xE2\x99\xAE\xE2\x99\xAF\0";
pub const NCBOXLIGHT: &[u8; 19usize] =
    b"\xE2\x94\x8C\xE2\x94\x90\xE2\x94\x94\xE2\x94\x98\xE2\x94\x80\xE2\x94\x82\0";
pub const NCBOXHEAVY: &[u8; 19usize] =
    b"\xE2\x94\x8F\xE2\x94\x93\xE2\x94\x97\xE2\x94\x9B\xE2\x94\x81\xE2\x94\x83\0";
pub const NCBOXROUND: &[u8; 19usize] =
    b"\xE2\x95\xAD\xE2\x95\xAE\xE2\x95\xB0\xE2\x95\xAF\xE2\x94\x80\xE2\x94\x82\0";
pub const NCBOXDOUBLE: &[u8; 19usize] =
    b"\xE2\x95\x94\xE2\x95\x97\xE2\x95\x9A\xE2\x95\x9D\xE2\x95\x90\xE2\x95\x91\0";
pub const NCBOXASCII: &[u8; 7usize] = b"/\\\\/-|\0";
pub const NCBOXOUTER : & [u8 ; 32usize] = b"\xF0\x9F\xAD\xBD\xF0\x9F\xAD\xBE\xF0\x9F\xAD\xBC\xF0\x9F\xAD\xBF\xE2\x96\x81\xF0\x9F\xAD\xB5\xF0\x9F\xAD\xB6\xF0\x9F\xAD\xB0\0" ;
pub const NCALPHA_HIGHCONTRAST: u32 = 805306368;
pub const NCALPHA_TRANSPARENT: u32 = 536870912;
pub const NCALPHA_BLEND: u32 = 268435456;
pub const NCALPHA_OPAQUE: u32 = 0;
pub const NCPALETTESIZE: u32 = 256;
pub const NC_NOBACKGROUND_MASK: i64 = -8718968878589280256;
pub const NC_BGDEFAULT_MASK: u32 = 1073741824;
pub const NC_BG_RGB_MASK: u32 = 16777215;
pub const NC_BG_PALETTE: u32 = 134217728;
pub const NC_BG_ALPHA_MASK: u32 = 805306368;
pub const NCSTYLE_MASK: u32 = 65535;
pub const NCSTYLE_ITALIC: u32 = 16;
pub const NCSTYLE_UNDERLINE: u32 = 8;
pub const NCSTYLE_UNDERCURL: u32 = 4;
pub const NCSTYLE_BOLD: u32 = 2;
pub const NCSTYLE_STRUCK: u32 = 1;
pub const NCSTYLE_NONE: u32 = 0;
pub const NCOPTION_INHIBIT_SETLOCALE: u32 = 1;
pub const NCOPTION_NO_CLEAR_BITMAPS: u32 = 2;
pub const NCOPTION_NO_WINCH_SIGHANDLER: u32 = 4;
pub const NCOPTION_NO_QUIT_SIGHANDLERS: u32 = 8;
pub const NCOPTION_PRESERVE_CURSOR: u32 = 16;
pub const NCOPTION_SUPPRESS_BANNERS: u32 = 32;
pub const NCOPTION_NO_ALTERNATE_SCREEN: u32 = 64;
pub const NCOPTION_NO_FONT_CHANGES: u32 = 128;
pub const NCOPTION_DRAIN_INPUT: u32 = 256;
pub const NCOPTION_SCROLLING: u32 = 512;
pub const NCOPTION_CLI_MODE: u32 = 594;
pub const NCMICE_NO_EVENTS: u32 = 0;
pub const NCMICE_MOVE_EVENT: u32 = 1;
pub const NCMICE_BUTTON_EVENT: u32 = 2;
pub const NCMICE_DRAG_EVENT: u32 = 4;
pub const NCMICE_ALL_EVENTS: u32 = 7;
pub const NCPLANE_OPTION_HORALIGNED: u32 = 1;
pub const NCPLANE_OPTION_VERALIGNED: u32 = 2;
pub const NCPLANE_OPTION_MARGINALIZED: u32 = 4;
pub const NCPLANE_OPTION_FIXED: u32 = 8;
pub const NCPLANE_OPTION_AUTOGROW: u32 = 16;
pub const NCPLANE_OPTION_VSCROLL: u32 = 32;
pub const NCBOXMASK_TOP: u32 = 1;
pub const NCBOXMASK_RIGHT: u32 = 2;
pub const NCBOXMASK_BOTTOM: u32 = 4;
pub const NCBOXMASK_LEFT: u32 = 8;
pub const NCBOXGRAD_TOP: u32 = 16;
pub const NCBOXGRAD_RIGHT: u32 = 32;
pub const NCBOXGRAD_BOTTOM: u32 = 64;
pub const NCBOXGRAD_LEFT: u32 = 128;
pub const NCBOXCORNER_MASK: u32 = 768;
pub const NCBOXCORNER_SHIFT: u32 = 8;
pub const NCVISUAL_OPTION_NODEGRADE: u32 = 1;
pub const NCVISUAL_OPTION_BLEND: u32 = 2;
pub const NCVISUAL_OPTION_HORALIGNED: u32 = 4;
pub const NCVISUAL_OPTION_VERALIGNED: u32 = 8;
pub const NCVISUAL_OPTION_ADDALPHA: u32 = 16;
pub const NCVISUAL_OPTION_CHILDPLANE: u32 = 32;
pub const NCVISUAL_OPTION_NOINTERPOLATE: u32 = 64;
pub const NCREEL_OPTION_INFINITESCROLL: u32 = 1;
pub const NCREEL_OPTION_CIRCULAR: u32 = 2;
pub const NCPREFIXCOLUMNS: u32 = 7;
pub const NCIPREFIXCOLUMNS: u32 = 8;
pub const NCBPREFIXCOLUMNS: u32 = 9;
pub const NCPREFIXSTRLEN: u32 = 8;
pub const NCIPREFIXSTRLEN: u32 = 9;
pub const NCBPREFIXSTRLEN: u32 = 10;
pub const NCMENU_OPTION_BOTTOM: u32 = 1;
pub const NCMENU_OPTION_HIDING: u32 = 2;
pub const NCPROGBAR_OPTION_RETROGRADE: u32 = 1;
pub const NCTABBED_OPTION_BOTTOM: u32 = 1;
pub const NCPLOT_OPTION_LABELTICKSD: u32 = 1;
pub const NCPLOT_OPTION_EXPONENTIALD: u32 = 2;
pub const NCPLOT_OPTION_VERTICALI: u32 = 4;
pub const NCPLOT_OPTION_NODEGRADE: u32 = 8;
pub const NCPLOT_OPTION_DETECTMAXONLY: u32 = 16;
pub const NCPLOT_OPTION_PRINTSAMPLE: u32 = 32;
pub const NCREADER_OPTION_HORSCROLL: u32 = 1;
pub const NCREADER_OPTION_VERSCROLL: u32 = 2;
pub const NCREADER_OPTION_NOCMDKEYS: u32 = 4;
pub const NCREADER_OPTION_CURSOR: u32 = 8;
pub const NCDIRECT_OPTION_INHIBIT_SETLOCALE: u32 = 1;
pub const NCDIRECT_OPTION_INHIBIT_CBREAK: u32 = 2;
pub const NCDIRECT_OPTION_DRAIN_INPUT: u32 = 4;
pub const NCDIRECT_OPTION_NO_QUIT_SIGHANDLERS: u32 = 8;
pub const NCDIRECT_OPTION_VERBOSE: u32 = 16;
pub const NCDIRECT_OPTION_VERY_VERBOSE: u32 = 32;
#[doc = " Convenience types."]
pub type __u_char = core::ffi::c_uchar;
pub type __u_short = core::ffi::c_ushort;
pub type __u_int = core::ffi::c_uint;
pub type __u_long = core::ffi::c_ulong;
#[doc = " Fixed-size types, underlying types depend on word size and compiler."]
pub type __int8_t = core::ffi::c_schar;
pub type __uint8_t = core::ffi::c_uchar;
pub type __int16_t = core::ffi::c_short;
pub type __uint16_t = core::ffi::c_ushort;
pub type __int32_t = core::ffi::c_int;
pub type __uint32_t = core::ffi::c_uint;
pub type __int64_t = core::ffi::c_long;
pub type __uint64_t = core::ffi::c_ulong;
#[doc = " Smallest types with at least a given width."]
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = core::ffi::c_long;
pub type __u_quad_t = core::ffi::c_ulong;
pub type __intmax_t = core::ffi::c_long;
pub type __uintmax_t = core::ffi::c_ulong;
pub type __dev_t = core::ffi::c_ulong;
pub type __uid_t = core::ffi::c_uint;
pub type __gid_t = core::ffi::c_uint;
pub type __ino_t = core::ffi::c_ulong;
pub type __ino64_t = core::ffi::c_ulong;
pub type __mode_t = core::ffi::c_uint;
pub type __nlink_t = core::ffi::c_ulong;
pub type __off_t = core::ffi::c_long;
pub type __off64_t = core::ffi::c_long;
pub type __pid_t = core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [core::ffi::c_int; 2usize],
}
pub type __clock_t = core::ffi::c_long;
pub type __rlim_t = core::ffi::c_ulong;
pub type __rlim64_t = core::ffi::c_ulong;
pub type __id_t = core::ffi::c_uint;
pub type __time_t = core::ffi::c_long;
pub type __useconds_t = core::ffi::c_uint;
pub type __suseconds_t = core::ffi::c_long;
pub type __suseconds64_t = core::ffi::c_long;
pub type __daddr_t = core::ffi::c_int;
pub type __key_t = core::ffi::c_int;
pub type __clockid_t = core::ffi::c_int;
pub type __timer_t = *mut core::ffi::c_void;
pub type __blksize_t = core::ffi::c_long;
pub type __blkcnt_t = core::ffi::c_long;
pub type __blkcnt64_t = core::ffi::c_long;
pub type __fsblkcnt_t = core::ffi::c_ulong;
pub type __fsblkcnt64_t = core::ffi::c_ulong;
pub type __fsfilcnt_t = core::ffi::c_ulong;
pub type __fsfilcnt64_t = core::ffi::c_ulong;
pub type __fsword_t = core::ffi::c_long;
pub type __ssize_t = core::ffi::c_long;
pub type __syscall_slong_t = core::ffi::c_long;
pub type __syscall_ulong_t = core::ffi::c_ulong;
#[doc = " These few don't really vary by system, they always correspond"]
#[doc = "to one of the other defined types."]
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut core::ffi::c_char;
pub type __intptr_t = core::ffi::c_long;
pub type __socklen_t = core::ffi::c_uint;
#[doc = " C99: An integer type that can be accessed as an atomic entity,"]
#[doc = "even in the presence of asynchronous interrupts."]
#[doc = "It is not currently necessary for this to be machine-specific."]
pub type __sig_atomic_t = core::ffi::c_int;
#[doc = " Returned by `clock'."]
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[doc = " ISO C `broken-down time' structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tm {
    #[doc = " Seconds.\t[0-60] (1 leap second)"]
    pub tm_sec: core::ffi::c_int,
    #[doc = " Minutes.\t[0-59]"]
    pub tm_min: core::ffi::c_int,
    #[doc = " Hours.\t[0-23]"]
    pub tm_hour: core::ffi::c_int,
    #[doc = " Day.\t\t[1-31]"]
    pub tm_mday: core::ffi::c_int,
    #[doc = " Month.\t[0-11]"]
    pub tm_mon: core::ffi::c_int,
    #[doc = " Year\t- 1900."]
    pub tm_year: core::ffi::c_int,
    #[doc = " Day of week.\t[0-6]"]
    pub tm_wday: core::ffi::c_int,
    #[doc = " Days in year.[0-365]"]
    pub tm_yday: core::ffi::c_int,
    #[doc = " DST.\t\t[-1/0/1]"]
    pub tm_isdst: core::ffi::c_int,
    #[doc = " Seconds east of UTC."]
    pub __tm_gmtoff: core::ffi::c_long,
    #[doc = " Timezone abbreviation."]
    pub __tm_zone: *const core::ffi::c_char,
}
impl Default for tm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " POSIX.1b structure for a time value.  This is like a `struct timeval' but"]
#[doc = "has nanoseconds instead of microseconds."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timespec {
    #[doc = " Seconds."]
    pub tv_sec: __time_t,
    #[doc = " Nanoseconds."]
    pub tv_nsec: __syscall_slong_t,
}
extern "C" {
    #[doc = " Current timezone names."]
    pub static mut __tzname: [*mut core::ffi::c_char; 2usize];
}
extern "C" {
    #[doc = " If daylight-saving time is ever in use."]
    pub static mut __daylight: core::ffi::c_int;
}
extern "C" {
    #[doc = " Seconds west of UTC."]
    pub static mut __timezone: core::ffi::c_long;
}
extern "C" {
    #[doc = " Same as above."]
    pub static mut tzname: [*mut core::ffi::c_char; 2usize];
}
extern "C" {
    pub static mut daylight: core::ffi::c_int;
}
extern "C" {
    pub static mut timezone: core::ffi::c_long;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type wchar_t = core::ffi::c_int;
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
pub type wint_t = core::ffi::c_uint;
#[doc = " Conversion state information."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: core::ffi::c_int,
    #[doc = " Value so far."]
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: core::ffi::c_uint,
    pub __wchb: [core::ffi::c_char; 4usize],
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Scalar type that can hold values which represent locale-specific"]
#[doc = "character classifications."]
pub type wctype_t = core::ffi::c_ulong;
#[doc = " The tag name of this struct is _G_fpos_t to preserve historic"]
#[doc = "C++ mangled names for functions taking fpos_t arguments."]
#[doc = "That name should not be used in new code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
impl Default for _G_fpos_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The tag name of this struct is _G_fpos_t to preserve historic"]
#[doc = "C++ mangled names for functions taking fpos_t arguments."]
#[doc = "That name should not be used in new code."]
pub type __fpos_t = _G_fpos_t;
#[doc = " The tag name of this struct is _G_fpos64_t to preserve historic"]
#[doc = "C++ mangled names for functions taking fpos_t and/or fpos64_t"]
#[doc = "arguments.  That name should not be used in new code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The tag name of this struct is _G_fpos64_t to preserve historic"]
#[doc = "C++ mangled names for functions taking fpos_t and/or fpos64_t"]
#[doc = "arguments.  That name should not be used in new code."]
pub type __fpos64_t = _G_fpos64_t;
#[doc = " The tag name of this struct is _IO_FILE to preserve historic"]
#[doc = "C++ mangled names for functions taking FILE* arguments."]
#[doc = "That name should not be used in new code."]
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = core::ffi::c_void;
#[doc = " The tag name of this struct is _IO_FILE to preserve historic"]
#[doc = "C++ mangled names for functions taking FILE* arguments."]
#[doc = "That name should not be used in new code."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_FILE {
    #[doc = " High-order word is _IO_MAGIC; rest is flags."]
    pub _flags: core::ffi::c_int,
    #[doc = " Current read pointer"]
    pub _IO_read_ptr: *mut core::ffi::c_char,
    #[doc = " End of get area."]
    pub _IO_read_end: *mut core::ffi::c_char,
    #[doc = " Start of putback+get area."]
    pub _IO_read_base: *mut core::ffi::c_char,
    #[doc = " Start of put area."]
    pub _IO_write_base: *mut core::ffi::c_char,
    #[doc = " Current put pointer."]
    pub _IO_write_ptr: *mut core::ffi::c_char,
    #[doc = " End of put area."]
    pub _IO_write_end: *mut core::ffi::c_char,
    #[doc = " Start of reserve area."]
    pub _IO_buf_base: *mut core::ffi::c_char,
    #[doc = " End of reserve area."]
    pub _IO_buf_end: *mut core::ffi::c_char,
    #[doc = " Pointer to start of non-current get area."]
    pub _IO_save_base: *mut core::ffi::c_char,
    #[doc = " Pointer to first valid character of backup area"]
    pub _IO_backup_base: *mut core::ffi::c_char,
    #[doc = " Pointer to end of non-current get area."]
    pub _IO_save_end: *mut core::ffi::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: core::ffi::c_int,
    pub _flags2: core::ffi::c_int,
    #[doc = " This used to be _offset but it's too small."]
    pub _old_offset: __off_t,
    #[doc = " 1+column number of pbase(); 0 is unknown."]
    pub _cur_column: core::ffi::c_ushort,
    pub _vtable_offset: core::ffi::c_schar,
    pub _shortbuf: [core::ffi::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    #[doc = " Wide character stream stuff."]
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut core::ffi::c_void,
    pub __pad5: usize,
    pub _mode: core::ffi::c_int,
    #[doc = " Make sure we don't get into trouble again."]
    pub _unused2: [core::ffi::c_char; 20usize],
}
impl Default for _IO_FILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The tag name of this struct is _G_fpos_t to preserve historic"]
#[doc = "C++ mangled names for functions taking fpos_t arguments."]
#[doc = "That name should not be used in new code."]
pub type fpos_t = __fpos_t;
extern "C" {
    #[doc = " Standard input stream."]
    pub static mut stdin: *mut FILE;
}
extern "C" {
    #[doc = " Standard output stream."]
    pub static mut stdout: *mut FILE;
}
extern "C" {
    #[doc = " Standard error output stream."]
    pub static mut stderr: *mut FILE;
}
extern "C" {
    #[doc = " For communication from 'getopt' to the caller."]
    #[doc = "When 'getopt' finds an option that takes an argument,"]
    #[doc = "the argument value is returned here."]
    #[doc = "Also, when 'ordering' is RETURN_IN_ORDER,"]
    #[doc = "each non-option ARGV-element is returned here."]
    pub static mut optarg: *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Index in ARGV of the next element to be scanned."]
    #[doc = "This is used for communication to and from the caller"]
    #[doc = "and for communication between successive calls to 'getopt'."]
    #[doc = ""]
    #[doc = "On entry to 'getopt', zero means this is the first call; initialize."]
    #[doc = ""]
    #[doc = "When 'getopt' returns -1, this is the index of the first of the"]
    #[doc = "non-option elements that the caller should itself scan."]
    #[doc = ""]
    #[doc = "Otherwise, 'optind' communicates from one call to the next"]
    #[doc = "how much of ARGV has been scanned so far."]
    pub static mut optind: core::ffi::c_int;
}
extern "C" {
    #[doc = " Callers store zero here to inhibit the error message 'getopt' prints"]
    #[doc = "for unrecognized options."]
    pub static mut opterr: core::ffi::c_int;
}
extern "C" {
    #[doc = " Set to an option character which was unrecognized."]
    pub static mut optopt: core::ffi::c_int;
}
#[doc = " Signed."]
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
#[doc = " Unsigned."]
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
#[doc = " Signed."]
pub type int_fast8_t = core::ffi::c_schar;
pub type int_fast16_t = core::ffi::c_long;
pub type int_fast32_t = core::ffi::c_long;
pub type int_fast64_t = core::ffi::c_long;
#[doc = " Unsigned."]
pub type uint_fast8_t = core::ffi::c_uchar;
pub type uint_fast16_t = core::ffi::c_ulong;
pub type uint_fast32_t = core::ffi::c_ulong;
pub type uint_fast64_t = core::ffi::c_ulong;
#[doc = " Largest integral types."]
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " Returned by `div'."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct div_t {
    #[doc = " Quotient."]
    pub quot: core::ffi::c_int,
    #[doc = " Remainder."]
    pub rem: core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ldiv_t {
    #[doc = " Quotient."]
    pub quot: core::ffi::c_long,
    #[doc = " Remainder."]
    pub rem: core::ffi::c_long,
}
#[doc = " Returned by `lldiv'."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct lldiv_t {
    #[doc = " Quotient."]
    pub quot: core::ffi::c_longlong,
    #[doc = " Remainder."]
    pub rem: core::ffi::c_longlong,
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const core::ffi::c_void,
        arg2: *const core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[doc = " An integral type that can be modified atomically, without the"]
#[doc = "possibility of a signal arriving in the middle of the operation."]
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __sigset_t {
    pub __val: [core::ffi::c_ulong; 16usize],
}
#[doc = " A set of signals to be blocked, unblocked, or waited for."]
pub type sigset_t = __sigset_t;
pub type pid_t = __pid_t;
pub type uid_t = __uid_t;
#[doc = " Type of a signal handler."]
pub type __sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int)>;
extern "C" {
    #[link_name = "\u{1}__sysv_signal"]
    pub fn signal(__sig: core::ffi::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    #[doc = " Clear all signals from SET."]
    pub fn sigemptyset(__set: *mut sigset_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set all signals in SET."]
    pub fn sigfillset(__set: *mut sigset_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Add SIGNO to SET."]
    pub fn sigaddset(__set: *mut sigset_t, __signo: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Remove SIGNO from SET."]
    pub fn sigdelset(__set: *mut sigset_t, __signo: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return 1 if SIGNO is in SET, 0 if not."]
    pub fn sigismember(__set: *const sigset_t, __signo: core::ffi::c_int) -> core::ffi::c_int;
}
#[doc = " Structure describing the action to be taken when a signal arrives."]
#[repr(C)]
pub struct sigaction {
    pub sa_handler: __sighandler_t,
    #[doc = " Additional set of signals to be blocked."]
    pub sa_mask: __sigset_t,
    #[doc = " Special flags."]
    pub sa_flags: core::ffi::c_int,
    #[doc = " Restore handler."]
    pub sa_restorer: ::core::option::Option<unsafe extern "C" fn()>,
}
impl Default for sigaction {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Get and/or change the set of blocked signals."]
    pub fn sigprocmask(
        __how: core::ffi::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Change the set of blocked signals to SET,"]
    #[doc = "wait until a signal arrives, and restore the set of blocked signals."]
    #[doc = ""]
    #[doc = "This function is a cancellation point and therefore not marked with"]
    #[doc = "__THROW."]
    pub fn sigsuspend(__set: *const sigset_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get and/or set the action for signal SIG."]
    pub fn sigaction(
        __sig: core::ffi::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Put in SET all signals that are blocked and waiting to be delivered."]
    pub fn sigpending(__set: *mut sigset_t) -> core::ffi::c_int;
}
#[doc = " Structure for scatter/gather I/O."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct iovec {
    #[doc = " Pointer to data."]
    pub iov_base: *mut core::ffi::c_void,
    #[doc = " Length of data."]
    pub iov_len: usize,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type key_t = __key_t;
#[doc = " Clock ID used in clock and timer functions."]
pub type clockid_t = __clockid_t;
#[doc = " Timer ID returned by `timer_create'."]
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
#[doc = " These were defined by ISO C without the first `_'."]
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = core::ffi::c_long;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type socklen_t = __socklen_t;
#[doc = " Sequenced, reliable, connection-based"]
#[doc = "byte streams."]
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
#[doc = " Connectionless, unreliable datagrams"]
#[doc = "of fixed maximum length."]
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
#[doc = " Raw protocol interface."]
pub const __socket_type_SOCK_RAW: __socket_type = 3;
#[doc = " Reliably-delivered messages."]
pub const __socket_type_SOCK_RDM: __socket_type = 4;
#[doc = " Sequenced, reliable, connection-based,"]
#[doc = "datagrams of fixed maximum length."]
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
#[doc = " Datagram Congestion Control Protocol."]
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
#[doc = " Linux specific way of getting packets"]
#[doc = "at the dev level.  For writing rarp and"]
#[doc = "other similar things on the user level."]
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
#[doc = " Atomically set close-on-exec flag for the"]
#[doc = "new descriptor(s)."]
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
#[doc = " Atomically mark descriptor(s) as"]
#[doc = "non-blocking."]
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
#[doc = " Types of sockets."]
pub type __socket_type = core::ffi::c_uint;
#[doc = " POSIX.1g specifies this type name for the `sa_family' member."]
pub type sa_family_t = core::ffi::c_ushort;
#[doc = " Structure describing a generic socket address."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    #[doc = " Address data."]
    pub sa_data: [core::ffi::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [core::ffi::c_char; 118usize],
    #[doc = " Force desired alignment."]
    pub __ss_align: core::ffi::c_ulong,
}
impl Default for sockaddr_storage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure used for storage of ancillary data object information."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct cmsghdr {
    #[doc = " Length of data in cmsg_data plus length"]
    #[doc = "of cmsghdr structure."]
    #[doc = " The type should be socklen_t but the"]
    #[doc = "definition of the kernel is incompatible"]
    #[doc = "with this."]
    pub cmsg_len: usize,
    #[doc = " Originating protocol."]
    pub cmsg_level: core::ffi::c_int,
    #[doc = " Protocol specific type."]
    pub cmsg_type: core::ffi::c_int,
    #[doc = " Ancillary data."]
    pub __cmsg_data: __IncompleteArrayField<core::ffi::c_uchar>,
}
#[doc = " Structure used to manipulate the SO_LINGER option."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct linger {
    #[doc = " Nonzero to linger on close."]
    pub l_onoff: core::ffi::c_int,
    #[doc = " Time to linger."]
    pub l_linger: core::ffi::c_int,
}
#[doc = " Internet address."]
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[doc = " Type to represent a port."]
pub type in_port_t = u16;
#[doc = " IPv6 address"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for in6_addr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " ::"]
    pub static in6addr_any: in6_addr;
}
extern "C" {
    #[doc = " ::1"]
    pub static in6addr_loopback: in6_addr;
}
#[doc = " Structure describing an Internet socket address."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    #[doc = " Port number."]
    pub sin_port: in_port_t,
    #[doc = " Internet address."]
    pub sin_addr: in_addr,
    #[doc = " Pad to size of `struct sockaddr'."]
    pub sin_zero: [core::ffi::c_uchar; 8usize],
}
#[doc = " Ditto, for IPv6."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    #[doc = " Transport layer port #"]
    pub sin6_port: in_port_t,
    #[doc = " IPv6 flow information"]
    pub sin6_flowinfo: u32,
    #[doc = " IPv6 address"]
    pub sin6_addr: in6_addr,
    #[doc = " IPv6 scope-id"]
    pub sin6_scope_id: u32,
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Get a human-readable string describing the running Notcurses version."]
    pub fn notcurses_version() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Cannot be inline, as we want to get the versions of the actual Notcurses"]
    #[doc = " library we loaded, not what we compile against."]
    pub fn notcurses_version_components(
        major: *mut core::ffi::c_int,
        minor: *mut core::ffi::c_int,
        patch: *mut core::ffi::c_int,
        tweak: *mut core::ffi::c_int,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct notcurses {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncplane {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncvisual {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncuplot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncdplot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncprogbar {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncfdplane {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncsubproc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncselector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncmultiselector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncreader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ncfadectx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nctablet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncreel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct nctab {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct nctabbed {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncdirect {
    _unused: [u8; 0],
}
#[doc = " let the ncvisual pick"]
pub const ncblitter_e_NCBLIT_DEFAULT: ncblitter_e = 0;
#[doc = " space, compatible with ASCII"]
pub const ncblitter_e_NCBLIT_1x1: ncblitter_e = 1;
#[doc = " halves + 1x1 (space)     â–„â–€"]
pub const ncblitter_e_NCBLIT_2x1: ncblitter_e = 2;
#[doc = " quadrants + 2x1          â–—â– â––â–€â–Ÿâ–Œâ–™"]
pub const ncblitter_e_NCBLIT_2x2: ncblitter_e = 3;
#[doc = " sextants (*NOT* 2x2)     ðŸ¬€ðŸ¬ðŸ¬‚ðŸ¬ƒðŸ¬„ðŸ¬…ðŸ¬†ðŸ¬‡ðŸ¬ˆðŸ¬‰ðŸ¬ŠðŸ¬‹ðŸ¬ŒðŸ¬ðŸ¬ŽðŸ¬ðŸ¬ðŸ¬‘ðŸ¬’ðŸ¬“ðŸ¬”ðŸ¬•ðŸ¬–ðŸ¬—ðŸ¬˜ðŸ¬™ðŸ¬šðŸ¬›ðŸ¬œðŸ¬ðŸ¬ž"]
pub const ncblitter_e_NCBLIT_3x2: ncblitter_e = 4;
#[doc = " 4 rows, 2 cols (braille) â¡€â¡„â¡†â¡‡â¢€â£€â£„â£†â£‡â¢ â£ â£¤â£¦â£§â¢°â£°â£´â£¶â£·â¢¸â£¸â£¼â£¾â£¿"]
pub const ncblitter_e_NCBLIT_BRAILLE: ncblitter_e = 5;
#[doc = " pixel graphics"]
pub const ncblitter_e_NCBLIT_PIXEL: ncblitter_e = 6;
#[doc = " four vertical levels     â–ˆâ–†â–„â–‚"]
pub const ncblitter_e_NCBLIT_4x1: ncblitter_e = 7;
#[doc = " eight vertical levels    â–ˆâ–‡â–†â–…â–„â–ƒâ–‚â–"]
pub const ncblitter_e_NCBLIT_8x1: ncblitter_e = 8;
#[doc = " we never blit full blocks, but instead spaces (more efficient) with the"]
#[doc = " background set to the desired foreground. these need be kept in the same"]
#[doc = " order as the blitters[] definition in lib/blit.c."]
pub type ncblitter_e = core::ffi::c_uint;
pub const ncalign_e_NCALIGN_UNALIGNED: ncalign_e = 0;
pub const ncalign_e_NCALIGN_LEFT: ncalign_e = 1;
pub const ncalign_e_NCALIGN_CENTER: ncalign_e = 2;
pub const ncalign_e_NCALIGN_RIGHT: ncalign_e = 3;
#[doc = " Alignment within a plane or terminal. Left/right-justified, or centered."]
pub type ncalign_e = core::ffi::c_uint;
pub const ncscale_e_NCSCALE_NONE: ncscale_e = 0;
pub const ncscale_e_NCSCALE_SCALE: ncscale_e = 1;
pub const ncscale_e_NCSCALE_STRETCH: ncscale_e = 2;
pub const ncscale_e_NCSCALE_NONE_HIRES: ncscale_e = 3;
pub const ncscale_e_NCSCALE_SCALE_HIRES: ncscale_e = 4;
#[doc = " How to scale an ncvisual during rendering. NCSCALE_NONE will apply no"]
#[doc = " scaling. NCSCALE_SCALE scales a visual to the plane's size, maintaining"]
#[doc = " aspect ratio. NCSCALE_STRETCH stretches and scales the image in an attempt"]
#[doc = " to fill the entirety of the plane. NCSCALE_NONE_HIRES and"]
#[doc = " NCSCALE_SCALE_HIRES behave like their counterparts, but admit blitters"]
#[doc = " which don't preserve aspect ratio."]
pub type ncscale_e = core::ffi::c_uint;
extern "C" {
    #[doc = " Returns the number of columns occupied by the longest valid prefix of a"]
    #[doc = " multibyte (UTF-8) string. If an invalid character is encountered, -1 will be"]
    #[doc = " returned, and the number of valid bytes and columns will be written into"]
    #[doc = " *|validbytes| and *|validwidth| (assuming them non-NULL). If the entire"]
    #[doc = " string is valid, *|validbytes| and *|validwidth| reflect the entire string."]
    pub fn ncstrwidth(
        egcs: *const core::ffi::c_char,
        validbytes: *mut core::ffi::c_int,
        validwidth: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " input functions like notcurses_get() return ucs32-encoded uint32_t. convert"]
    #[doc = " a series of uint32_t to utf8. result must be at least 4 bytes per input"]
    #[doc = " uint32_t (6 bytes per uint32_t will future-proof against Unicode expansion)."]
    #[doc = " the number of bytes used is returned, or -1 if passed illegal ucs32, or too"]
    #[doc = " small of a buffer."]
    pub fn notcurses_ucs32_to_utf8(
        ucs32: *const u32,
        ucs32count: core::ffi::c_uint,
        resultbuf: *mut core::ffi::c_uchar,
        buflen: usize,
    ) -> core::ffi::c_int;
}
#[doc = " An nccell corresponds to a single character cell on some plane, which can be"]
#[doc = " occupied by a single grapheme cluster (some root spacing glyph, along with"]
#[doc = " possible combining characters, which might span multiple columns). At any"]
#[doc = " cell, we can have a theoretically arbitrarily long UTF-8 EGC, a foreground"]
#[doc = " color, a background color, and an attribute set. Valid grapheme cluster"]
#[doc = " contents include:"]
#[doc = ""]
#[doc = "  * A NUL terminator,"]
#[doc = "  * A single control character, followed by a NUL terminator,"]
#[doc = "  * At most one spacing character, followed by zero or more nonspacing"]
#[doc = "    characters, followed by a NUL terminator."]
#[doc = ""]
#[doc = " Multi-column characters can only have a single style/color throughout."]
#[doc = " Existence is suffering, and thus wcwidth() is not reliable. It's just"]
#[doc = " quoting whether or not the EGC contains a \"Wide Asian\" double-width"]
#[doc = " character. This is set for some things, like most emoji, and not set for"]
#[doc = " other things, like cuneiform. True display width is a *function of the"]
#[doc = " font and terminal*. Among the longest Unicode codepoints is"]
#[doc = ""]
#[doc = "    U+FDFD ARABIC LIGATURE BISMILLAH AR-RAHMAN AR-RAHEEM ï·½"]
#[doc = ""]
#[doc = " wcwidth() rather optimistically claims this most exalted glyph to occupy"]
#[doc = " a single column. BiDi text is too complicated for me to even get into here."]
#[doc = " Be assured there are no easy answers; ours is indeed a disturbing Universe."]
#[doc = ""]
#[doc = " Each nccell occupies 16 static bytes (128 bits). The surface is thus ~1.6MB"]
#[doc = " for a (pretty large) 500x200 terminal. At 80x43, it's less than 64KB."]
#[doc = " Dynamic requirements (the egcpool) can add up to 16MB to an ncplane, but"]
#[doc = " such large pools are unlikely in common use."]
#[doc = ""]
#[doc = " We implement some small alpha compositing. Foreground and background both"]
#[doc = " have two bits of inverted alpha. The actual grapheme written to a cell is"]
#[doc = " the topmost non-zero grapheme. If its alpha is 00, its foreground color is"]
#[doc = " used unchanged. If its alpha is 10, its foreground color is derived entirely"]
#[doc = " from cells underneath it. Otherwise, the result will be a composite."]
#[doc = " Likewise for the background. If the bottom of a coordinate's zbuffer is"]
#[doc = " reached with a cumulative alpha of zero, the default is used. In this way,"]
#[doc = " a terminal configured with transparent background can be supported through"]
#[doc = " multiple occluding ncplanes. A foreground alpha of 11 requests high-contrast"]
#[doc = " text (relative to the computed background). A background alpha of 11 is"]
#[doc = " currently forbidden."]
#[doc = ""]
#[doc = " Default color takes precedence over palette or RGB, and cannot be used with"]
#[doc = " transparency. Indexed palette takes precedence over RGB. It cannot"]
#[doc = " meaningfully set transparency, but it can be mixed into a cascading color."]
#[doc = " RGB is used if neither default terminal colors nor palette indexing are in"]
#[doc = " play, and fully supports all transparency options."]
#[doc = ""]
#[doc = " This structure is exposed only so that most functions can be inlined. Do not"]
#[doc = " directly modify or access the fields of this structure; use the API."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nccell {
    #[doc = " 4B â†’ 4B little endian EGC"]
    pub gcluster: u32,
    #[doc = " 1B â†’ 5B (8 bits of zero)"]
    pub gcluster_backstop: u8,
    #[doc = " 1B â†’ 6B (8 bits of EGC column width)"]
    pub width: u8,
    #[doc = " 2B â†’ 8B (16 bits of NCSTYLE_* attributes)"]
    pub stylemask: u16,
    #[doc = " + 8B == 16B"]
    pub channels: u64,
}
extern "C" {
    #[doc = " Breaks the UTF-8 string in 'gcluster' down, setting up the nccell 'c'."]
    #[doc = " Returns the number of bytes copied out of 'gcluster', or -1 on failure. The"]
    #[doc = " styling of the cell is left untouched, but any resources are released."]
    pub fn nccell_load(
        n: *mut ncplane,
        c: *mut nccell,
        gcluster: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Duplicate 'c' into 'targ'; both must be/will be bound to 'n'. Returns -1 on"]
    #[doc = " failure, and 0 on success."]
    pub fn nccell_duplicate(
        n: *mut ncplane,
        targ: *mut nccell,
        c: *const nccell,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Release resources held by the nccell 'c'."]
    pub fn nccell_release(n: *mut ncplane, c: *mut nccell);
}
extern "C" {
    #[doc = " return a pointer to the NUL-terminated EGC referenced by 'c'. this pointer"]
    #[doc = " can be invalidated by any further operation on the plane 'n', so...watch out!"]
    pub fn nccell_extended_gcluster(
        n: *const ncplane,
        c: *const nccell,
    ) -> *const core::ffi::c_char;
}
#[doc = " default. print nothing once fullscreen service begins"]
pub const ncloglevel_e_NCLOGLEVEL_SILENT: ncloglevel_e = -1;
#[doc = " print diagnostics related to catastrophic failure"]
pub const ncloglevel_e_NCLOGLEVEL_PANIC: ncloglevel_e = 0;
#[doc = " we're hanging around, but we've had a horrible fault"]
pub const ncloglevel_e_NCLOGLEVEL_FATAL: ncloglevel_e = 1;
#[doc = " we can't keep doing this, but we can do other things"]
pub const ncloglevel_e_NCLOGLEVEL_ERROR: ncloglevel_e = 2;
#[doc = " you probably don't want what's happening to happen"]
pub const ncloglevel_e_NCLOGLEVEL_WARNING: ncloglevel_e = 3;
#[doc = " \"standard information\""]
pub const ncloglevel_e_NCLOGLEVEL_INFO: ncloglevel_e = 4;
#[doc = " \"detailed information\""]
pub const ncloglevel_e_NCLOGLEVEL_VERBOSE: ncloglevel_e = 5;
#[doc = " this is honestly a bit much"]
pub const ncloglevel_e_NCLOGLEVEL_DEBUG: ncloglevel_e = 6;
#[doc = " there's probably a better way to do what you want"]
pub const ncloglevel_e_NCLOGLEVEL_TRACE: ncloglevel_e = 7;
#[doc = " These log levels consciously map cleanly to those of libav; Notcurses itself"]
#[doc = " does not use this full granularity. The log level does not affect the opening"]
#[doc = " and closing banners, which can be disabled via the notcurses_option struct's"]
#[doc = " 'suppress_banner'. Note that if stderr is connected to the same terminal on"]
#[doc = " which we're rendering, any kind of logging will disrupt the output (which is"]
#[doc = " undesirable). The \"default\" zero value is NCLOGLEVEL_PANIC."]
pub type ncloglevel_e = core::ffi::c_int;
#[doc = " Configuration for notcurses_init()."]
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct notcurses_options {
    #[doc = " The name of the terminfo database entry describing this terminal. If NULL,"]
    #[doc = " the environment variable TERM is used. Failure to open the terminal"]
    #[doc = " definition will result in failure to initialize notcurses."]
    pub termtype: *const core::ffi::c_char,
    #[doc = " Progressively higher log levels result in more logging to stderr. By"]
    #[doc = " default, nothing is printed to stderr once fullscreen service begins."]
    pub loglevel: ncloglevel_e,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety"]
    #[doc = " of the screen. If the screen is too small, we do what we can--this is"]
    #[doc = " strictly best-effort. Absolute coordinates are relative to the rendering"]
    #[doc = " area ((0, 0) is always the origin of the rendering area)."]
    pub margin_t: core::ffi::c_uint,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety"]
    #[doc = " of the screen. If the screen is too small, we do what we can--this is"]
    #[doc = " strictly best-effort. Absolute coordinates are relative to the rendering"]
    #[doc = " area ((0, 0) is always the origin of the rendering area)."]
    pub margin_r: core::ffi::c_uint,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety"]
    #[doc = " of the screen. If the screen is too small, we do what we can--this is"]
    #[doc = " strictly best-effort. Absolute coordinates are relative to the rendering"]
    #[doc = " area ((0, 0) is always the origin of the rendering area)."]
    pub margin_b: core::ffi::c_uint,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety"]
    #[doc = " of the screen. If the screen is too small, we do what we can--this is"]
    #[doc = " strictly best-effort. Absolute coordinates are relative to the rendering"]
    #[doc = " area ((0, 0) is always the origin of the rendering area)."]
    pub margin_l: core::ffi::c_uint,
    #[doc = " General flags; see NCOPTION_*. This is expressed as a bitfield so that"]
    #[doc = " future options can be added without reshaping the struct. Undefined bits"]
    #[doc = " must be set to 0."]
    pub flags: u64,
}
impl Default for notcurses_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Lex a margin argument according to the standard Notcurses definition. There"]
    #[doc = " can be either a single number, which will define all margins equally, or"]
    #[doc = " there can be four numbers separated by commas."]
    pub fn notcurses_lex_margins(
        op: *const core::ffi::c_char,
        opts: *mut notcurses_options,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Lex a blitter."]
    pub fn notcurses_lex_blitter(
        op: *const core::ffi::c_char,
        blitter: *mut ncblitter_e,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the name of a blitter."]
    pub fn notcurses_str_blitter(blitter: ncblitter_e) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Lex a scaling mode (one of \"none\", \"stretch\", \"scale\", \"hires\","]
    #[doc = " \"scalehi\", or \"inflate\")."]
    pub fn notcurses_lex_scalemode(
        op: *const core::ffi::c_char,
        scalemode: *mut ncscale_e,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the name of a scaling mode."]
    pub fn notcurses_str_scalemode(scalemode: ncscale_e) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Initialize a Notcurses context on the connected terminal at 'fp'. 'fp' must"]
    #[doc = " be a tty. You'll usually want stdout. NULL can be supplied for 'fp', in"]
    #[doc = " which case /dev/tty will be opened. Returns NULL on error, including any"]
    #[doc = " failure initializing terminfo."]
    pub fn notcurses_init(opts: *const notcurses_options, fp: *mut FILE) -> *mut notcurses;
}
extern "C" {
    #[doc = " The same as notcurses_init(), but without any multimedia functionality,"]
    #[doc = " allowing for a svelter binary. Link with notcurses-core if this is used."]
    pub fn notcurses_core_init(opts: *const notcurses_options, fp: *mut FILE) -> *mut notcurses;
}
extern "C" {
    #[doc = " Destroy a Notcurses context. A NULL 'nc' is a no-op."]
    pub fn notcurses_stop(nc: *mut notcurses) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Shift to the alternate screen, if available. If already using the alternate"]
    #[doc = " screen, this returns 0 immediately. If the alternate screen is not"]
    #[doc = " available, this returns -1 immediately. Entering the alternate screen turns"]
    #[doc = " off scrolling for the standard plane."]
    pub fn notcurses_enter_alternate_screen(nc: *mut notcurses) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Exit the alternate screen. Immediately returns 0 if not currently using the"]
    #[doc = " alternate screen."]
    pub fn notcurses_leave_alternate_screen(nc: *mut notcurses) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get a reference to the standard plane (one matching our current idea of the"]
    #[doc = " terminal size) for this terminal. The standard plane always exists, and its"]
    #[doc = " origin is always at the uppermost, leftmost cell of the terminal."]
    pub fn notcurses_stdplane(nc: *mut notcurses) -> *mut ncplane;
}
extern "C" {
    pub fn notcurses_stdplane_const(nc: *const notcurses) -> *const ncplane;
}
extern "C" {
    #[doc = " Return the topmost plane of the pile containing 'n'."]
    pub fn ncpile_top(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Return the bottommost plane of the pile containing 'n'."]
    pub fn ncpile_bottom(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Renders the pile of which 'n' is a part. Rendering this pile again will blow"]
    #[doc = " away the render. To actually write out the render, call ncpile_rasterize()."]
    pub fn ncpile_render(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Make the physical screen match the last rendered frame from the pile of"]
    #[doc = " which 'n' is a part. This is a blocking call. Don't call this before the"]
    #[doc = " pile has been rendered (doing so will likely result in a blank screen)."]
    pub fn ncpile_rasterize(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Perform the rendering and rasterization portion of ncpile_render() and"]
    #[doc = " ncpile_rasterize(), but do not write the resulting buffer out to the"]
    #[doc = " terminal. Using this function, the user can control the writeout process."]
    #[doc = " The returned buffer must be freed by the caller."]
    pub fn ncpile_render_to_buffer(
        p: *mut ncplane,
        buf: *mut *mut core::ffi::c_char,
        buflen: *mut usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Write the last rendered frame, in its entirety, to 'fp'. If a frame has"]
    #[doc = " not yet been rendered, nothing will be written."]
    pub fn ncpile_render_to_file(p: *mut ncplane, fp: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Destroy all ncplanes other than the stdplane."]
    pub fn notcurses_drop_planes(nc: *mut notcurses);
}
pub const ncintype_e_NCTYPE_UNKNOWN: ncintype_e = 0;
pub const ncintype_e_NCTYPE_PRESS: ncintype_e = 1;
pub const ncintype_e_NCTYPE_REPEAT: ncintype_e = 2;
pub const ncintype_e_NCTYPE_RELEASE: ncintype_e = 3;
pub type ncintype_e = core::ffi::c_uint;
#[doc = " An input event. Cell coordinates are currently defined only for mouse"]
#[doc = " events. It is not guaranteed that we can set the modifiers for a given"]
#[doc = " ncinput. We encompass single Unicode codepoints, not complete EGCs."]
#[doc = " FIXME for abi4, combine the bools into |modifiers|"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash)]
pub struct ncinput {
    #[doc = " Unicode codepoint or synthesized NCKEY event"]
    pub id: u32,
    #[doc = " y/x cell coordinate of event, -1 for undefined"]
    pub y: core::ffi::c_int,
    #[doc = " y/x cell coordinate of event, -1 for undefined"]
    pub x: core::ffi::c_int,
    #[doc = " utf8 representation, if one exists"]
    pub utf8: [core::ffi::c_char; 5usize],
    #[doc = " was alt held?"]
    pub alt: bool,
    #[doc = " was shift held?"]
    pub shift: bool,
    #[doc = " was ctrl held?"]
    pub ctrl: bool,
    #[doc = " END DEPRECATION"]
    pub evtype: ncintype_e,
    #[doc = " bitmask over NCKEY_MOD_*"]
    pub modifiers: core::ffi::c_uint,
    #[doc = " pixel offsets within cell, -1 for undefined"]
    pub ypx: core::ffi::c_int,
    #[doc = " pixel offsets within cell, -1 for undefined"]
    pub xpx: core::ffi::c_int,
}
impl Default for ncinput {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Read a UTF-32-encoded Unicode codepoint from input. This might only be part"]
    #[doc = " of a larger EGC. Provide a NULL 'ts' to block at length, and otherwise a"]
    #[doc = " timespec specifying an absolute deadline calculated using CLOCK_MONOTONIC."]
    #[doc = " Returns a single Unicode code point, or a synthesized special key constant,"]
    #[doc = " or (uint32_t)-1 on error. Returns 0 on a timeout. If an event is processed,"]
    #[doc = " the return value is the 'id' field from that event. 'ni' may be NULL."]
    pub fn notcurses_get(n: *mut notcurses, ts: *const timespec, ni: *mut ncinput) -> u32;
}
extern "C" {
    #[doc = " Acquire up to 'vcount' ncinputs at the vector 'ni'. The number read will be"]
    #[doc = " returned, or -1 on error without any reads, 0 on timeout."]
    pub fn notcurses_getvec(
        n: *mut notcurses,
        ts: *const timespec,
        ni: *mut ncinput,
        vcount: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get a file descriptor suitable for input event poll()ing. When this"]
    #[doc = " descriptor becomes available, you can call notcurses_get_nblock(),"]
    #[doc = " and input ought be ready. This file descriptor is *not* necessarily"]
    #[doc = " the file descriptor associated with stdin (but it might be!)."]
    pub fn notcurses_inputready_fd(n: *mut notcurses) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Enable mice events according to 'eventmask'; an eventmask of 0 will disable"]
    #[doc = " all mice tracking. On failure, -1 is returned. On success, 0 is returned, and"]
    #[doc = " mouse events will be published to notcurses_get()."]
    pub fn notcurses_mice_enable(
        n: *mut notcurses,
        eventmask: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Disable signals originating from the terminal's line discipline, i.e."]
    #[doc = " SIGINT (^C), SIGQUIT (^\\), and SIGTSTP (^Z). They are enabled by default."]
    pub fn notcurses_linesigs_disable(n: *mut notcurses) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Restore signals originating from the terminal's line discipline, i.e."]
    #[doc = " SIGINT (^C), SIGQUIT (^\\), and SIGTSTP (^Z), if disabled."]
    pub fn notcurses_linesigs_enable(n: *mut notcurses) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Refresh the physical screen to match what was last rendered (i.e., without"]
    #[doc = " reflecting any changes since the last call to notcurses_render()). This is"]
    #[doc = " primarily useful if the screen is externally corrupted, or if an"]
    #[doc = " NCKEY_RESIZE event has been read and you're not yet ready to render. The"]
    #[doc = " current screen geometry is returned in 'y' and 'x', if they are not NULL."]
    pub fn notcurses_refresh(
        n: *mut notcurses,
        y: *mut core::ffi::c_uint,
        x: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Extract the Notcurses context to which this plane is attached."]
    pub fn ncplane_notcurses(n: *const ncplane) -> *mut notcurses;
}
extern "C" {
    pub fn ncplane_notcurses_const(n: *const ncplane) -> *const notcurses;
}
extern "C" {
    #[doc = " Return the dimensions of this ncplane. y or x may be NULL."]
    pub fn ncplane_dim_yx(n: *const ncplane, y: *mut core::ffi::c_uint, x: *mut core::ffi::c_uint);
}
extern "C" {
    #[doc = " Retrieve pixel geometry for the display region ('pxy', 'pxx'), each cell"]
    #[doc = " ('celldimy', 'celldimx'), and the maximum displayable bitmap ('maxbmapy',"]
    #[doc = " 'maxbmapx'). If bitmaps are not supported, or if there is no artificial"]
    #[doc = " limit on bitmap size, 'maxbmapy' and 'maxbmapx' will be 0. Any of the"]
    #[doc = " geometry arguments may be NULL."]
    pub fn ncplane_pixel_geom(
        n: *const ncplane,
        pxy: *mut core::ffi::c_uint,
        pxx: *mut core::ffi::c_uint,
        celldimy: *mut core::ffi::c_uint,
        celldimx: *mut core::ffi::c_uint,
        maxbmapy: *mut core::ffi::c_uint,
        maxbmapx: *mut core::ffi::c_uint,
    );
}
extern "C" {
    #[doc = " Retrieve the contents of the specified cell as last rendered. Returns the EGC"]
    #[doc = " or NULL on error. This EGC must be free()d by the caller. The stylemask and"]
    #[doc = " channels are written to 'stylemask' and 'channels', respectively."]
    pub fn notcurses_at_yx(
        nc: *mut notcurses,
        yoff: core::ffi::c_uint,
        xoff: core::ffi::c_uint,
        stylemask: *mut u16,
        channels: *mut u64,
    ) -> *mut core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncplane_options {
    #[doc = " vertical placement relative to parent plane"]
    pub y: core::ffi::c_int,
    #[doc = " horizontal placement relative to parent plane"]
    pub x: core::ffi::c_int,
    #[doc = " rows, must be >0 unless NCPLANE_OPTION_MARGINALIZED"]
    pub rows: core::ffi::c_uint,
    #[doc = " columns, must be >0 unless NCPLANE_OPTION_MARGINALIZED"]
    pub cols: core::ffi::c_uint,
    #[doc = " user curry, may be NULL"]
    pub userptr: *mut core::ffi::c_void,
    #[doc = " name (used only for debugging), may be NULL"]
    pub name: *const core::ffi::c_char,
    #[doc = " callback when parent is resized"]
    pub resizecb:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ncplane) -> core::ffi::c_int>,
    #[doc = " closure over NCPLANE_OPTION_*"]
    pub flags: u64,
    #[doc = " margins (require NCPLANE_OPTION_MARGINALIZED)"]
    pub margin_b: core::ffi::c_uint,
    #[doc = " margins (require NCPLANE_OPTION_MARGINALIZED)"]
    pub margin_r: core::ffi::c_uint,
}
impl Default for ncplane_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Create a new ncplane bound to plane 'n', at the offset 'y'x'x' (relative to"]
    #[doc = " the origin of 'n') and the specified size. The number of 'rows' and 'cols'"]
    #[doc = " must both be positive. This plane is initially at the top of the z-buffer,"]
    #[doc = " as if ncplane_move_top() had been called on it. The void* 'userptr' can be"]
    #[doc = " retrieved (and reset) later. A 'name' can be set, used in debugging."]
    pub fn ncplane_create(n: *mut ncplane, nopts: *const ncplane_options) -> *mut ncplane;
}
extern "C" {
    #[doc = " Same as ncplane_create(), but creates a new pile. The returned plane will"]
    #[doc = " be the top, bottom, and root of this new pile."]
    pub fn ncpile_create(nc: *mut notcurses, nopts: *const ncplane_options) -> *mut ncplane;
}
extern "C" {
    #[doc = " resize the plane to the visual region's size (used for the standard plane)."]
    pub fn ncplane_resize_maximize(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " resize the plane to its parent's size, attempting to enforce the margins"]
    #[doc = " supplied along with NCPLANE_OPTION_MARGINALIZED."]
    pub fn ncplane_resize_marginalized(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " realign the plane 'n' against its parent, using the alignments specified"]
    #[doc = " with NCPLANE_OPTION_HORALIGNED and/or NCPLANE_OPTION_VERALIGNED."]
    pub fn ncplane_resize_realign(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " move the plane such that it is entirely within its parent, if possible."]
    #[doc = " no resizing is performed."]
    pub fn ncplane_resize_placewithin(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Replace the ncplane's existing resizecb with 'resizecb' (which may be NULL)."]
    #[doc = " The standard plane's resizecb may not be changed."]
    pub fn ncplane_set_resizecb(
        n: *mut ncplane,
        resizecb: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ncplane) -> core::ffi::c_int,
        >,
    );
}
extern "C" {
    #[doc = " Returns the ncplane's current resize callback."]
    pub fn ncplane_resizecb(
        n: *const ncplane,
    ) -> ::core::option::Option<unsafe extern "C" fn(n: *mut ncplane) -> core::ffi::c_int>;
}
extern "C" {
    #[doc = " Set the plane's name (may be NULL), replacing any current name."]
    pub fn ncplane_set_name(n: *mut ncplane, name: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return a heap-allocated copy of the plane's name, or NULL if it has none."]
    pub fn ncplane_name(n: *const ncplane) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Plane 'n' will be unbound from its parent plane, and will be made a bound"]
    #[doc = " child of 'newparent'. It is an error if 'n' or 'newparent' are NULL. If"]
    #[doc = " 'newparent' is equal to 'n', 'n' becomes the root of a new pile, unless 'n'"]
    #[doc = " is already the root of a pile, in which case this is a no-op. Returns 'n'."]
    #[doc = " The standard plane cannot be reparented. Any planes bound to 'n' are"]
    #[doc = " reparented to the previous parent of 'n'."]
    pub fn ncplane_reparent(n: *mut ncplane, newparent: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " The same as ncplane_reparent(), except any planes bound to 'n' come along"]
    #[doc = " with it to its new destination. Their z-order is maintained. If 'newparent'"]
    #[doc = " is an ancestor of 'n', NULL is returned, and no changes are made."]
    pub fn ncplane_reparent_family(n: *mut ncplane, newparent: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Duplicate an existing ncplane. The new plane will have the same geometry,"]
    #[doc = " will duplicate all content, and will start with the same rendering state."]
    #[doc = " The new plane will be immediately above the old one on the z axis, and will"]
    #[doc = " be bound to the same parent (unless 'n' is a root plane, in which case the"]
    #[doc = " new plane will be bound to it). Bound planes are *not* duplicated; the new"]
    #[doc = " plane is bound to the parent of 'n', but has no bound planes."]
    pub fn ncplane_dup(n: *const ncplane, opaque: *mut core::ffi::c_void) -> *mut ncplane;
}
extern "C" {
    #[doc = " provided a coordinate relative to the origin of 'src', map it to the same"]
    #[doc = " absolute coordinate relative to the origin of 'dst'. either or both of 'y'"]
    #[doc = " and 'x' may be NULL. if 'dst' is NULL, it is taken to be the standard plane."]
    pub fn ncplane_translate(
        src: *const ncplane,
        dst: *const ncplane,
        y: *mut core::ffi::c_int,
        x: *mut core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " Fed absolute 'y'/'x' coordinates, determine whether that coordinate is"]
    #[doc = " within the ncplane 'n'. If not, return false. If so, return true. Either"]
    #[doc = " way, translate the absolute coordinates relative to 'n'. If the point is not"]
    #[doc = " within 'n', these coordinates will not be within the dimensions of the plane."]
    pub fn ncplane_translate_abs(
        n: *const ncplane,
        y: *mut core::ffi::c_int,
        x: *mut core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " All planes are created with scrolling disabled. Scrolling can be dynamically"]
    #[doc = " controlled with ncplane_set_scrolling(). Returns true if scrolling was"]
    #[doc = " previously enabled, or false if it was disabled."]
    pub fn ncplane_set_scrolling(n: *mut ncplane, scrollp: core::ffi::c_uint) -> bool;
}
extern "C" {
    pub fn ncplane_scrolling_p(n: *const ncplane) -> bool;
}
extern "C" {
    #[doc = " By default, planes are created with autogrow disabled. Autogrow can be"]
    #[doc = " dynamically controlled with ncplane_set_autogrow(). Returns true if"]
    #[doc = " autogrow was previously enabled, or false if it was disabled."]
    pub fn ncplane_set_autogrow(n: *mut ncplane, growp: core::ffi::c_uint) -> bool;
}
extern "C" {
    pub fn ncplane_autogrow_p(n: *const ncplane) -> bool;
}
#[doc = " Palette API. Some terminals only support 256 colors, but allow the full"]
#[doc = " palette to be specified with arbitrary RGB colors. In all cases, it's more"]
#[doc = " performant to use indexed colors, since it's much less data to write to the"]
#[doc = " terminal. If you can limit yourself to 256 colors, that's probably best."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncpalette {
    #[doc = " RGB values as regular ol' channels"]
    pub chans: [u32; 256usize],
}
impl Default for ncpalette {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Create a new palette store. It will be initialized with notcurses' best"]
    #[doc = " knowledge of the currently configured palette."]
    pub fn ncpalette_new(nc: *mut notcurses) -> *mut ncpalette;
}
extern "C" {
    #[doc = " Attempt to configure the terminal with the provided palette 'p'. Does not"]
    #[doc = " transfer ownership of 'p'; ncpalette_free() can (ought) still be called."]
    pub fn ncpalette_use(nc: *mut notcurses, p: *const ncpalette) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Free the palette store 'p'."]
    pub fn ncpalette_free(p: *mut ncpalette);
}
#[doc = " Capabilities, derived from terminfo, environment variables, and queries"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nccapabilities {
    #[doc = " size of palette for indexed colors"]
    pub colors: core::ffi::c_uint,
    #[doc = " are we using utf-8 encoding? from nl_langinfo(3)"]
    pub utf8: bool,
    #[doc = " 24bit color? COLORTERM/heuristics/terminfo 'rgb'"]
    pub rgb: bool,
    #[doc = " can we change the palette? terminfo 'ccc'"]
    pub can_change_colors: bool,
    #[doc = " we assume halfblocks, but some are known to lack them"]
    pub halfblocks: bool,
    #[doc = " do we have (good, vetted) Unicode 1 quadrant support?"]
    pub quadrants: bool,
    #[doc = " do we have (good, vetted) Unicode 13 sextant support?"]
    pub sextants: bool,
    #[doc = " do we have Braille support? (linux console does not)"]
    pub braille: bool,
}
extern "C" {
    #[doc = " Returns a 16-bit bitmask of supported curses-style attributes"]
    #[doc = " (NCSTYLE_UNDERLINE, NCSTYLE_BOLD, etc.) The attribute is only"]
    #[doc = " indicated as supported if the terminal can support it together with color."]
    #[doc = " For more information, see the \"ncv\" capability in terminfo(5)."]
    pub fn notcurses_supported_styles(nc: *const notcurses) -> u16;
}
extern "C" {
    #[doc = " Returns the number of simultaneous colors claimed to be supported, or 1 if"]
    #[doc = " there is no color support. Note that several terminal emulators advertise"]
    #[doc = " more colors than they actually support, downsampling internally."]
    pub fn notcurses_palette_size(nc: *const notcurses) -> core::ffi::c_uint;
}
extern "C" {
    #[doc = " Returns the name (and sometimes version) of the terminal, as Notcurses"]
    #[doc = " has been best able to determine."]
    pub fn notcurses_detected_terminal(nc: *const notcurses) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn notcurses_capabilities(n: *const notcurses) -> *const nccapabilities;
}
pub const ncpixelimpl_e_NCPIXEL_NONE: ncpixelimpl_e = 0;
#[doc = " sixel"]
pub const ncpixelimpl_e_NCPIXEL_SIXEL: ncpixelimpl_e = 1;
#[doc = " linux framebuffer"]
pub const ncpixelimpl_e_NCPIXEL_LINUXFB: ncpixelimpl_e = 2;
#[doc = " iTerm2"]
pub const ncpixelimpl_e_NCPIXEL_ITERM2: ncpixelimpl_e = 3;
#[doc = " C=1 (disabling scrolling) was only introduced in 0.20.0, at the same"]
#[doc = " time as animation. prior to this, graphics had to be entirely redrawn"]
#[doc = " on any change, and it wasn't possible to use the bottom line."]
pub const ncpixelimpl_e_NCPIXEL_KITTY_STATIC: ncpixelimpl_e = 4;
#[doc = " until 0.22.0's introduction of 'a=c' for self-referential composition, we"]
#[doc = " had to keep a complete copy of the RGBA data, in case a wiped cell needed"]
#[doc = " to be rebuilt. we'd otherwise have to unpack the glyph and store it into"]
#[doc = " the auxvec on the fly."]
pub const ncpixelimpl_e_NCPIXEL_KITTY_ANIMATED: ncpixelimpl_e = 5;
#[doc = " with 0.22.0, we only ever write transparent cells after writing the"]
#[doc = " original image (which we now deflate, since we needn't unpack it later)."]
#[doc = " the only data we need keep is the auxvecs."]
pub const ncpixelimpl_e_NCPIXEL_KITTY_SELFREF: ncpixelimpl_e = 6;
#[doc = " pixel blitting implementations. informative only; don't special-case"]
#[doc = " based off any of this information!"]
pub type ncpixelimpl_e = core::ffi::c_uint;
extern "C" {
    #[doc = " Can we blit pixel-accurate bitmaps?"]
    pub fn notcurses_check_pixel_support(nc: *const notcurses) -> ncpixelimpl_e;
}
extern "C" {
    #[doc = " Can we load images? This requires being built against FFmpeg/OIIO."]
    pub fn notcurses_canopen_images(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we load videos? This requires being built against FFmpeg."]
    pub fn notcurses_canopen_videos(nc: *const notcurses) -> bool;
}
#[doc = " whenever a new field is added here, ensure we add the proper rule to"]
#[doc = " notcurses_stats_reset(), so that values are preserved in the stash stats."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncstats {
    #[doc = " successful ncpile_render() runs"]
    pub renders: u64,
    #[doc = " successful ncpile_rasterize() runs"]
    pub writeouts: u64,
    #[doc = " aborted renders, should be 0"]
    pub failed_renders: u64,
    #[doc = " aborted writes"]
    pub failed_writeouts: u64,
    #[doc = " bytes emitted to ttyfp"]
    pub raster_bytes: u64,
    #[doc = " max bytes emitted for a frame"]
    pub raster_max_bytes: i64,
    #[doc = " min bytes emitted for a frame"]
    pub raster_min_bytes: i64,
    #[doc = " nanoseconds spent rendering"]
    pub render_ns: u64,
    #[doc = " max ns spent in render for a frame"]
    pub render_max_ns: i64,
    #[doc = " min ns spent in render for a frame"]
    pub render_min_ns: i64,
    #[doc = " nanoseconds spent rasterizing"]
    pub raster_ns: u64,
    #[doc = " max ns spent in raster for a frame"]
    pub raster_max_ns: i64,
    #[doc = " min ns spent in raster for a frame"]
    pub raster_min_ns: i64,
    #[doc = " nanoseconds spent writing frames to terminal"]
    pub writeout_ns: u64,
    #[doc = " max ns spent writing out a frame"]
    pub writeout_max_ns: i64,
    #[doc = " min ns spent writing out a frame"]
    pub writeout_min_ns: i64,
    #[doc = " cells we elided entirely thanks to damage maps"]
    pub cellelisions: u64,
    #[doc = " total number of cells emitted to terminal"]
    pub cellemissions: u64,
    #[doc = " RGB fg elision count"]
    pub fgelisions: u64,
    #[doc = " RGB fg emissions"]
    pub fgemissions: u64,
    #[doc = " RGB bg elision count"]
    pub bgelisions: u64,
    #[doc = " RGB bg emissions"]
    pub bgemissions: u64,
    #[doc = " default color was emitted"]
    pub defaultelisions: u64,
    #[doc = " default color was elided"]
    pub defaultemissions: u64,
    #[doc = " refresh requests (non-optimized redraw)"]
    pub refreshes: u64,
    #[doc = " sprixel draw count"]
    pub sprixelemissions: u64,
    #[doc = " sprixel elision count"]
    pub sprixelelisions: u64,
    #[doc = " sprixel bytes emitted"]
    pub sprixelbytes: u64,
    #[doc = " how many application-synchronized updates?"]
    pub appsync_updates: u64,
    #[doc = " errors processing control sequences/utf8"]
    pub input_errors: u64,
    #[doc = " characters returned to userspace"]
    pub input_events: u64,
    #[doc = " unnecessary hpas issued"]
    pub hpa_gratuitous: u64,
    #[doc = " cell geometry changes (resizes)"]
    pub cell_geo_changes: u64,
    #[doc = " pixel geometry changes (font resize)"]
    pub pixel_geo_changes: u64,
    #[doc = " total bytes devoted to all active framebuffers"]
    pub fbbytes: u64,
    #[doc = " number of planes currently in existence"]
    pub planes: core::ffi::c_uint,
}
extern "C" {
    #[doc = " Allocate an ncstats object. Use this rather than allocating your own, since"]
    #[doc = " future versions of Notcurses might enlarge this structure."]
    pub fn notcurses_stats_alloc(nc: *const notcurses) -> *mut ncstats;
}
extern "C" {
    #[doc = " Acquire an atomic snapshot of the Notcurses object's stats."]
    pub fn notcurses_stats(nc: *mut notcurses, stats: *mut ncstats);
}
extern "C" {
    #[doc = " Reset all cumulative stats (immediate ones, such as fbbytes, are not reset),"]
    #[doc = " first copying them into |*stats| (if |stats| is not NULL)."]
    pub fn notcurses_stats_reset(nc: *mut notcurses, stats: *mut ncstats);
}
extern "C" {
    #[doc = " Resize the specified ncplane. The four parameters 'keepy', 'keepx',"]
    #[doc = " 'keepleny', and 'keeplenx' define a subset of the ncplane to keep,"]
    #[doc = " unchanged. This may be a region of size 0, though none of these four"]
    #[doc = " parameters may be negative. 'keepx' and 'keepy' are relative to the ncplane."]
    #[doc = " They must specify a coordinate within the ncplane's totality. 'yoff' and"]
    #[doc = " 'xoff' are relative to 'keepy' and 'keepx', and place the upper-left corner"]
    #[doc = " of the resized ncplane. Finally, 'ylen' and 'xlen' are the dimensions of the"]
    #[doc = " ncplane after resizing. 'ylen' must be greater than or equal to 'keepleny',"]
    #[doc = " and 'xlen' must be greater than or equal to 'keeplenx'. It is an error to"]
    #[doc = " attempt to resize the standard plane. If either of 'keepleny' or 'keeplenx'"]
    #[doc = " is non-zero, both must be non-zero."]
    #[doc = ""]
    #[doc = " Essentially, the kept material does not move. It serves to anchor the"]
    #[doc = " resized plane. If there is no kept material, the plane can move freely."]
    pub fn ncplane_resize(
        n: *mut ncplane,
        keepy: core::ffi::c_int,
        keepx: core::ffi::c_int,
        keepleny: core::ffi::c_uint,
        keeplenx: core::ffi::c_uint,
        yoff: core::ffi::c_int,
        xoff: core::ffi::c_int,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Destroy the specified ncplane. None of its contents will be visible after"]
    #[doc = " the next call to notcurses_render(). It is an error to attempt to destroy"]
    #[doc = " the standard plane."]
    pub fn ncplane_destroy(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the ncplane's base nccell to 'c'. The base cell is used for purposes of"]
    #[doc = " rendering anywhere that the ncplane's gcluster is 0. Note that the base cell"]
    #[doc = " is not affected by ncplane_erase(). 'c' must not be a secondary cell from a"]
    #[doc = " multicolumn EGC."]
    pub fn ncplane_set_base_cell(n: *mut ncplane, c: *const nccell) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the ncplane's base nccell. It will be used for purposes of rendering"]
    #[doc = " anywhere that the ncplane's gcluster is 0. Note that the base cell is not"]
    #[doc = " affected by ncplane_erase(). 'egc' must be an extended grapheme cluster."]
    #[doc = " Returns the number of bytes copied out of 'gcluster', or -1 on failure."]
    pub fn ncplane_set_base(
        n: *mut ncplane,
        egc: *const core::ffi::c_char,
        stylemask: u16,
        channels: u64,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Extract the ncplane's base nccell into 'c'. The reference is invalidated if"]
    #[doc = " 'ncp' is destroyed."]
    pub fn ncplane_base(n: *mut ncplane, c: *mut nccell) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the origin of plane 'n' relative to its bound plane, or pile (if 'n' is"]
    #[doc = " a root plane). To get absolute coordinates, use ncplane_abs_yx()."]
    pub fn ncplane_yx(n: *const ncplane, y: *mut core::ffi::c_int, x: *mut core::ffi::c_int);
}
extern "C" {
    pub fn ncplane_y(n: *const ncplane) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_x(n: *const ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Move this plane relative to the standard plane, or the plane to which it is"]
    #[doc = " bound (if it is bound to a plane). It is an error to attempt to move the"]
    #[doc = " standard plane."]
    pub fn ncplane_move_yx(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the origin of plane 'n' relative to its pile. Either or both of 'x' and"]
    #[doc = " 'y' may be NULL."]
    pub fn ncplane_abs_yx(n: *const ncplane, y: *mut core::ffi::c_int, x: *mut core::ffi::c_int);
}
extern "C" {
    pub fn ncplane_abs_y(n: *const ncplane) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_abs_x(n: *const ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the plane to which the plane 'n' is bound, if any."]
    pub fn ncplane_parent(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    pub fn ncplane_parent_const(n: *const ncplane) -> *const ncplane;
}
extern "C" {
    #[doc = " Splice ncplane 'n' out of the z-buffer, and reinsert it above 'above'."]
    #[doc = " Returns non-zero if 'n' is already in the desired location. 'n' and"]
    #[doc = " 'above' must not be the same plane. If 'above' is NULL, 'n' is moved"]
    #[doc = " to the bottom of its pile."]
    pub fn ncplane_move_above(n: *mut ncplane, above: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Splice ncplane 'n' out of the z-buffer, and reinsert it below 'below'."]
    #[doc = " Returns non-zero if 'n' is already in the desired location. 'n' and"]
    #[doc = " 'below' must not be the same plane. If 'below' is NULL, 'n' is moved to"]
    #[doc = " the top of its pile."]
    pub fn ncplane_move_below(n: *mut ncplane, below: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Splice ncplane 'n' and its bound planes out of the z-buffer, and reinsert"]
    #[doc = " them above or below 'targ'. Relative order will be maintained between the"]
    #[doc = " reinserted planes. For a plane E bound to C, with z-ordering A B C D E,"]
    #[doc = " moving the C family to the top results in C E A B D, while moving it to"]
    #[doc = " the bottom results in A B D C E."]
    pub fn ncplane_move_family_above(n: *mut ncplane, targ: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_move_family_below(n: *mut ncplane, targ: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return the plane below this one, or NULL if this is at the bottom."]
    pub fn ncplane_below(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Return the plane above this one, or NULL if this is at the top."]
    pub fn ncplane_above(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Effect |r| scroll events on the plane |n|. Returns an error if |n| is not"]
    #[doc = " a scrolling plane, and otherwise returns the number of lines scrolled."]
    pub fn ncplane_scrollup(n: *mut ncplane, r: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Scroll |n| up until |child| is no longer hidden beneath it. Returns an"]
    #[doc = " error if |child| is not a child of |n|, or |n| is not scrolling, or |child|"]
    #[doc = " is fixed. Returns the number of scrolling events otherwise (might be 0)."]
    #[doc = " If the child plane is not fixed, it will likely scroll as well."]
    pub fn ncplane_scrollup_child(n: *mut ncplane, child: *const ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Rotate the plane Ï€/2 radians clockwise or counterclockwise. This cannot"]
    #[doc = " be performed on arbitrary planes, because glyphs cannot be arbitrarily"]
    #[doc = " rotated. The glyphs which can be rotated are limited: line-drawing"]
    #[doc = " characters, spaces, half blocks, and full blocks. The plane must have"]
    #[doc = " an even number of columns. Use the ncvisual rotation for a more"]
    #[doc = " flexible approach."]
    pub fn ncplane_rotate_cw(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_rotate_ccw(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Retrieve the current contents of the cell under the cursor. The EGC is"]
    #[doc = " returned, or NULL on error. This EGC must be free()d by the caller. The"]
    #[doc = " stylemask and channels are written to 'stylemask' and 'channels', respectively."]
    pub fn ncplane_at_cursor(
        n: *const ncplane,
        stylemask: *mut u16,
        channels: *mut u64,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Retrieve the current contents of the cell under the cursor into 'c'. This"]
    #[doc = " cell is invalidated if the associated plane is destroyed. Returns the number"]
    #[doc = " of bytes in the EGC, or -1 on error."]
    pub fn ncplane_at_cursor_cell(n: *mut ncplane, c: *mut nccell) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Retrieve the current contents of the specified cell. The EGC is returned, or"]
    #[doc = " NULL on error. This EGC must be free()d by the caller. The stylemask and"]
    #[doc = " channels are written to 'stylemask' and 'channels', respectively. The return"]
    #[doc = " represents how the cell will be used during rendering, and thus integrates"]
    #[doc = " any base cell where appropriate. If called upon the secondary columns of a"]
    #[doc = " wide glyph, the EGC will be returned (i.e. this function does not distinguish"]
    #[doc = " between the primary and secondary columns of a wide glyph). If called on a"]
    #[doc = " sprixel plane, its control sequence is returned for all valid locations."]
    pub fn ncplane_at_yx(
        n: *const ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        stylemask: *mut u16,
        channels: *mut u64,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Retrieve the current contents of the specified cell into 'c'. This cell is"]
    #[doc = " invalidated if the associated plane is destroyed. Returns the number of"]
    #[doc = " bytes in the EGC, or -1 on error. Unlike ncplane_at_yx(), when called upon"]
    #[doc = " the secondary columns of a wide glyph, the return can be distinguished from"]
    #[doc = " the primary column (nccell_wide_right_p(c) will return true). It is an"]
    #[doc = " error to call this on a sprixel plane (unlike ncplane_at_yx())."]
    pub fn ncplane_at_yx_cell(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        c: *mut nccell,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Create a flat string from the EGCs of the selected region of the ncplane"]
    #[doc = " 'n'. Start at the plane's 'begy'x'begx' coordinate (which must lie on the"]
    #[doc = " plane), continuing for 'leny'x'lenx' cells. Either or both of 'leny' and"]
    #[doc = " 'lenx' can be specified as 0 to go through the boundary of the plane."]
    #[doc = " -1 can be specified for 'begx'/'begy' to use the current cursor location."]
    pub fn ncplane_contents(
        n: *mut ncplane,
        begy: core::ffi::c_int,
        begx: core::ffi::c_int,
        leny: core::ffi::c_uint,
        lenx: core::ffi::c_uint,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Manipulate the opaque user pointer associated with this plane."]
    #[doc = " ncplane_set_userptr() returns the previous userptr after replacing"]
    #[doc = " it with 'opaque'. the others simply return the userptr."]
    pub fn ncplane_set_userptr(
        n: *mut ncplane,
        opaque: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn ncplane_userptr(n: *mut ncplane) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Find the center coordinate of a plane, preferring the top/left in the"]
    #[doc = " case of an even number of rows/columns (in such a case, there will be one"]
    #[doc = " more cell to the bottom/right of the center than the top/left). The"]
    #[doc = " center is then modified relative to the plane's origin."]
    pub fn ncplane_center_abs(
        n: *const ncplane,
        y: *mut core::ffi::c_int,
        x: *mut core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " Create an RGBA flat array from the selected region of the ncplane 'nc'."]
    #[doc = " Start at the plane's 'begy'x'begx' coordinate (which must lie on the"]
    #[doc = " plane), continuing for 'leny'x'lenx' cells. Either or both of 'leny' and"]
    #[doc = " 'lenx' can be specified as 0 to go through the boundary of the plane."]
    #[doc = " Only glyphs from the specified ncblitset may be present. If 'pxdimy' and/or"]
    #[doc = " 'pxdimx' are non-NULL, they will be filled in with the total pixel geometry."]
    pub fn ncplane_as_rgba(
        n: *const ncplane,
        blit: ncblitter_e,
        begy: core::ffi::c_int,
        begx: core::ffi::c_int,
        leny: core::ffi::c_uint,
        lenx: core::ffi::c_uint,
        pxdimy: *mut core::ffi::c_uint,
        pxdimx: *mut core::ffi::c_uint,
    ) -> *mut u32;
}
extern "C" {
    #[doc = " Move the cursor to the specified position (the cursor needn't be visible)."]
    #[doc = " Pass -1 as either coordinate to hold that axis constant. Returns -1 if the"]
    #[doc = " move would place the cursor outside the plane."]
    pub fn ncplane_cursor_move_yx(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Move the cursor relative to the current cursor position (the cursor needn't"]
    #[doc = " be visible). Returns -1 on error, including target position exceeding the"]
    #[doc = " plane's dimensions."]
    pub fn ncplane_cursor_move_rel(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Move the cursor to 0, 0. Can't fail."]
    pub fn ncplane_home(n: *mut ncplane);
}
extern "C" {
    #[doc = " Get the current position of the cursor within n. y and/or x may be NULL."]
    pub fn ncplane_cursor_yx(
        n: *const ncplane,
        y: *mut core::ffi::c_uint,
        x: *mut core::ffi::c_uint,
    );
}
extern "C" {
    #[doc = " Get the current colors and alpha values for ncplane 'n'."]
    pub fn ncplane_channels(n: *const ncplane) -> u64;
}
extern "C" {
    #[doc = " Get the current styling for the ncplane 'n'."]
    pub fn ncplane_styles(n: *const ncplane) -> u16;
}
extern "C" {
    #[doc = " Replace the cell at the specified coordinates with the provided cell 'c',"]
    #[doc = " and advance the cursor by the width of the cell (but not past the end of the"]
    #[doc = " plane). On success, returns the number of columns the cursor was advanced."]
    #[doc = " 'c' must already be associated with 'n'. On failure, -1 is returned."]
    pub fn ncplane_putc_yx(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        c: *const nccell,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Replace the EGC underneath us, but retain the styling. The current styling"]
    #[doc = " of the plane will not be changed."]
    pub fn ncplane_putchar_stained(n: *mut ncplane, c: core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Replace the cell at the specified coordinates with the provided EGC, and"]
    #[doc = " advance the cursor by the width of the cluster (but not past the end of the"]
    #[doc = " plane). On success, returns the number of columns the cursor was advanced."]
    #[doc = " On failure, -1 is returned. The number of bytes converted from gclust is"]
    #[doc = " written to 'sbytes' if non-NULL."]
    pub fn ncplane_putegc_yx(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        gclust: *const core::ffi::c_char,
        sbytes: *mut usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Replace the EGC underneath us, but retain the styling. The current styling"]
    #[doc = " of the plane will not be changed."]
    pub fn ncplane_putegc_stained(
        n: *mut ncplane,
        gclust: *const core::ffi::c_char,
        sbytes: *mut usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Replace the EGC underneath us, but retain the styling. The current styling"]
    #[doc = " of the plane will not be changed."]
    pub fn ncplane_putwegc_stained(
        n: *mut ncplane,
        gclust: *const wchar_t,
        sbytes: *mut usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_putnstr_aligned(
        n: *mut ncplane,
        y: core::ffi::c_int,
        align: ncalign_e,
        s: usize,
        str_: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_putwstr_stained(n: *mut ncplane, gclustarr: *const wchar_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " The ncplane equivalents of printf(3) and vprintf(3)."]
    pub fn ncplane_vprintf_aligned(
        n: *mut ncplane,
        y: core::ffi::c_int,
        align: ncalign_e,
        format: *const core::ffi::c_char,
        ap: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_vprintf_yx(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        format: *const core::ffi::c_char,
        ap: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_vprintf_stained(
        n: *mut ncplane,
        format: *const core::ffi::c_char,
        ap: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Write the specified text to the plane, breaking lines sensibly, beginning at"]
    #[doc = " the specified line. Returns the number of columns written. When breaking a"]
    #[doc = " line, the line will be cleared to the end of the plane (the last line will"]
    #[doc = " *not* be so cleared). The number of bytes written from the input is written"]
    #[doc = " to '*bytes' if it is not NULL. Cleared columns are included in the return"]
    #[doc = " value, but *not* included in the number of bytes written. Leaves the cursor"]
    #[doc = " at the end of output. A partial write will be accomplished as far as it can;"]
    #[doc = " determine whether the write completed by inspecting '*bytes'. Can output to"]
    #[doc = " multiple rows even in the absence of scrolling, but not more rows than are"]
    #[doc = " available. With scrolling enabled, arbitrary amounts of data can be emitted."]
    #[doc = " All provided whitespace is preserved -- ncplane_puttext() followed by an"]
    #[doc = " appropriate ncplane_contents() will read back the original output."]
    #[doc = ""]
    #[doc = " If 'y' is -1, the first row of output is taken relative to the current"]
    #[doc = " cursor: it will be left-, right-, or center-aligned in whatever remains"]
    #[doc = " of the row. On subsequent rows -- or if 'y' is not -1 -- the entire row can"]
    #[doc = " be used, and alignment works normally."]
    #[doc = ""]
    #[doc = " A newline at any point will move the cursor to the next row."]
    pub fn ncplane_puttext(
        n: *mut ncplane,
        y: core::ffi::c_int,
        align: ncalign_e,
        text: *const core::ffi::c_char,
        bytes: *mut usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Draw horizontal or vertical lines using the specified cell, starting at the"]
    #[doc = " current cursor position. The cursor will end at the cell following the last"]
    #[doc = " cell output (even, perhaps counter-intuitively, when drawing vertical"]
    #[doc = " lines), just as if ncplane_putc() was called at that spot. Return the"]
    #[doc = " number of cells drawn on success. On error, return the negative number of"]
    #[doc = " cells drawn. A length of 0 is an error, resulting in a return of -1."]
    pub fn ncplane_hline_interp(
        n: *mut ncplane,
        c: *const nccell,
        len: core::ffi::c_uint,
        c1: u64,
        c2: u64,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_vline_interp(
        n: *mut ncplane,
        c: *const nccell,
        len: core::ffi::c_uint,
        c1: u64,
        c2: u64,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Draw a box with its upper-left corner at the current cursor position, and its"]
    #[doc = " lower-right corner at 'ystop'x'xstop'. The 6 cells provided are used to draw the"]
    #[doc = " upper-left, ur, ll, and lr corners, then the horizontal and vertical lines."]
    #[doc = " 'ctlword' is defined in the least significant byte, where bits [7, 4] are a"]
    #[doc = " gradient mask, and [3, 0] are a border mask:"]
    #[doc = "  * 7, 3: top"]
    #[doc = "  * 6, 2: right"]
    #[doc = "  * 5, 1: bottom"]
    #[doc = "  * 4, 0: left"]
    #[doc = " If the gradient bit is not set, the styling from the hl/vl cells is used for"]
    #[doc = " the horizontal and vertical lines, respectively. If the gradient bit is set,"]
    #[doc = " the color is linearly interpolated between the two relevant corner cells."]
    #[doc = ""]
    #[doc = " By default, vertexes are drawn whether their connecting edges are drawn or"]
    #[doc = " not. The value of the bits corresponding to NCBOXCORNER_MASK control this,"]
    #[doc = " and are interpreted as the number of connecting edges necessary to draw a"]
    #[doc = " given corner. At 0 (the default), corners are always drawn. At 3, corners"]
    #[doc = " are never drawn (since at most 2 edges can touch a box's corner)."]
    pub fn ncplane_box(
        n: *mut ncplane,
        ul: *const nccell,
        ur: *const nccell,
        ll: *const nccell,
        lr: *const nccell,
        hline: *const nccell,
        vline: *const nccell,
        ystop: core::ffi::c_uint,
        xstop: core::ffi::c_uint,
        ctlword: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Starting at the specified coordinate, if its glyph is different from that of"]
    #[doc = " 'c', 'c' is copied into it, and the original glyph is considered the fill"]
    #[doc = " target. We do the same to all cardinally-connected cells having this same"]
    #[doc = " fill target. Returns the number of cells polyfilled. An invalid initial y, x"]
    #[doc = " is an error. Returns the number of cells filled, or -1 on error."]
    pub fn ncplane_polyfill_yx(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        c: *const nccell,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Draw a gradient with its upper-left corner at the position specified by 'y'/'x',"]
    #[doc = " where -1 means the current cursor position in that dimension. The area is"]
    #[doc = " specified by 'ylen'/'xlen', where 0 means \"everything remaining below or"]
    #[doc = " to the right, respectively.\" The glyph composed of 'egc' and 'styles' is"]
    #[doc = " used for all cells. The channels specified by 'ul', 'ur', 'll', and 'lr'"]
    #[doc = " are composed into foreground and background gradients. To do a vertical"]
    #[doc = " gradient, 'ul' ought equal 'ur' and 'll' ought equal 'lr'. To do a"]
    #[doc = " horizontal gradient, 'ul' ought equal 'll' and 'ur' ought equal 'ul'. To"]
    #[doc = " color everything the same, all four channels should be equivalent. The"]
    #[doc = " resulting alpha values are equal to incoming alpha values. Returns the"]
    #[doc = " number of cells filled on success, or -1 on failure."]
    #[doc = " Palette-indexed color is not supported."]
    #[doc = ""]
    #[doc = " Preconditions for gradient operations (error otherwise):"]
    #[doc = ""]
    #[doc = "  all: only RGB colors, unless all four channels match as default"]
    #[doc = "  all: all alpha values must be the same"]
    #[doc = "  1x1: all four colors must be the same"]
    #[doc = "  1xN: both top and both bottom colors must be the same (vertical gradient)"]
    #[doc = "  Nx1: both left and both right colors must be the same (horizontal gradient)"]
    pub fn ncplane_gradient(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
        egc: *const core::ffi::c_char,
        styles: u16,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Do a high-resolution gradient using upper blocks and synced backgrounds."]
    #[doc = " This doubles the number of vertical gradations, but restricts you to"]
    #[doc = " half blocks (appearing to be full blocks). Returns the number of cells"]
    #[doc = " filled on success, or -1 on error."]
    pub fn ncplane_gradient2x1(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
        ul: u32,
        ur: u32,
        ll: u32,
        lr: u32,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the given style throughout the specified region, keeping content and"]
    #[doc = " channels unchanged. The upper left corner is at 'y', 'x', and -1 may be"]
    #[doc = " specified to indicate the cursor's position in that dimension. The area"]
    #[doc = " is specified by 'ylen', 'xlen', and 0 may be specified to indicate everything"]
    #[doc = " remaining to the right and below, respectively. It is an error for any"]
    #[doc = " coordinate to be outside the plane. Returns the number of cells set,"]
    #[doc = " or -1 on failure."]
    pub fn ncplane_format(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
        stylemask: u16,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the given channels throughout the specified region, keeping content and"]
    #[doc = " channels unchanged. The upper left corner is at 'y', 'x', and -1 may be"]
    #[doc = " specified to indicate the cursor's position in that dimension. The area"]
    #[doc = " is specified by 'ylen', 'xlen', and 0 may be specified to indicate everything"]
    #[doc = " remaining to the right and below, respectively. It is an error for any"]
    #[doc = " coordinate to be outside the plane. Returns the number of cells set,"]
    #[doc = " or -1 on failure."]
    pub fn ncplane_stain(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Merge the entirety of 'src' down onto the ncplane 'dst'. If 'src' does not"]
    #[doc = " intersect with 'dst', 'dst' will not be changed, but it is not an error."]
    pub fn ncplane_mergedown_simple(src: *mut ncplane, dst: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Merge the ncplane 'src' down onto the ncplane 'dst'. This is most rigorously"]
    #[doc = " defined as \"write to 'dst' the frame that would be rendered were the entire"]
    #[doc = " stack made up only of the specified subregion of 'src' and, below it, the"]
    #[doc = " subregion of 'dst' having the specified origin. Supply -1 to indicate the"]
    #[doc = " current cursor position in the relevant dimension. Merging is independent of"]
    #[doc = " the position of 'src' viz 'dst' on the z-axis. It is an error to define a"]
    #[doc = " subregion that is not entirely contained within 'src'. It is an error to"]
    #[doc = " define a target origin such that the projected subregion is not entirely"]
    #[doc = " contained within 'dst'.  Behavior is undefined if 'src' and 'dst' are"]
    #[doc = " equivalent. 'dst' is modified, but 'src' remains unchanged. Neither 'src'"]
    #[doc = " nor 'dst' may have sprixels. Lengths of 0 mean \"everything left\"."]
    pub fn ncplane_mergedown(
        src: *mut ncplane,
        dst: *mut ncplane,
        begsrcy: core::ffi::c_int,
        begsrcx: core::ffi::c_int,
        leny: core::ffi::c_uint,
        lenx: core::ffi::c_uint,
        dsty: core::ffi::c_int,
        dstx: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Erase every cell in the ncplane (each cell is initialized to the null glyph"]
    #[doc = " and the default channels/styles). All cells associated with this ncplane are"]
    #[doc = " invalidated, and must not be used after the call, *excluding* the base cell."]
    #[doc = " The cursor is homed. The plane's active attributes are unaffected."]
    pub fn ncplane_erase(n: *mut ncplane);
}
extern "C" {
    #[doc = " Erase every cell in the region starting at {ystart, xstart} and having size"]
    #[doc = " {|ylen|x|xlen|} for non-zero lengths. If ystart and/or xstart are -1, the current"]
    #[doc = " cursor position along that axis is used; other negative values are an error. A"]
    #[doc = " negative ylen means to move up from the origin, and a negative xlen means to move"]
    #[doc = " left from the origin. A positive ylen moves down, and a positive xlen moves right."]
    #[doc = " A value of 0 for the length erases everything along that dimension. It is an error"]
    #[doc = " if the starting coordinate is not in the plane, but the ending coordinate may be"]
    #[doc = " outside the plane."]
    #[doc = ""]
    #[doc = " For example, on a plane of 20 rows and 10 columns, with the cursor at row 10 and"]
    #[doc = " column 5, the following would hold:"]
    #[doc = ""]
    #[doc = "  (-1, -1, 0, 1): clears the column to the right of the cursor (column 6)"]
    #[doc = "  (-1, -1, 0, -1): clears the column to the left of the cursor (column 4)"]
    #[doc = "  (-1, -1, INT_MAX, 0): clears all rows with or below the cursor (rows 10--19)"]
    #[doc = "  (-1, -1, -INT_MAX, 0): clears all rows with or above the cursor (rows 0--10)"]
    #[doc = "  (-1, 4, 3, 3): clears from row 5, column 4 through row 7, column 6"]
    #[doc = "  (-1, 4, -3, -3): clears from row 5, column 4 through row 3, column 2"]
    #[doc = "  (4, -1, 0, 3): clears columns 5, 6, and 7"]
    #[doc = "  (-1, -1, 0, 0): clears the plane *if the cursor is in a legal position*"]
    #[doc = "  (0, 0, 0, 0): clears the plane in all cases"]
    pub fn ncplane_erase_region(
        n: *mut ncplane,
        ystart: core::ffi::c_int,
        xstart: core::ffi::c_int,
        ylen: core::ffi::c_int,
        xlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the alpha and coloring bits of the plane's current channels from a"]
    #[doc = " 64-bit pair of channels."]
    pub fn ncplane_set_channels(n: *mut ncplane, channels: u64);
}
extern "C" {
    #[doc = " Set the background alpha and coloring bits of the plane's current"]
    #[doc = " channels from a single 32-bit value."]
    pub fn ncplane_set_bchannel(n: *mut ncplane, channel: u32) -> u64;
}
extern "C" {
    #[doc = " Set the foreground alpha and coloring bits of the plane's current"]
    #[doc = " channels from a single 32-bit value."]
    pub fn ncplane_set_fchannel(n: *mut ncplane, channel: u32) -> u64;
}
extern "C" {
    #[doc = " Set the specified style bits for the ncplane 'n', whether they're actively"]
    #[doc = " supported or not."]
    pub fn ncplane_set_styles(n: *mut ncplane, stylebits: core::ffi::c_uint);
}
extern "C" {
    #[doc = " Add the specified styles to the ncplane's existing spec."]
    pub fn ncplane_on_styles(n: *mut ncplane, stylebits: core::ffi::c_uint);
}
extern "C" {
    #[doc = " Remove the specified styles from the ncplane's existing spec."]
    pub fn ncplane_off_styles(n: *mut ncplane, stylebits: core::ffi::c_uint);
}
extern "C" {
    #[doc = " Set the current fore/background color using RGB specifications. If the"]
    #[doc = " terminal does not support directly-specified 3x8b cells (24-bit \"TrueColor\","]
    #[doc = " indicated by the \"RGB\" terminfo capability), the provided values will be"]
    #[doc = " interpreted in some lossy fashion. None of r, g, or b may exceed 255."]
    #[doc = " \"HP-like\" terminals require setting foreground and background at the same"]
    #[doc = " time using \"color pairs\"; Notcurses will manage color pairs transparently."]
    pub fn ncplane_set_fg_rgb8(
        n: *mut ncplane,
        r: core::ffi::c_uint,
        g: core::ffi::c_uint,
        b: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_rgb8(
        n: *mut ncplane,
        r: core::ffi::c_uint,
        g: core::ffi::c_uint,
        b: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Same, but clipped to [0..255]."]
    pub fn ncplane_set_bg_rgb8_clipped(
        n: *mut ncplane,
        r: core::ffi::c_int,
        g: core::ffi::c_int,
        b: core::ffi::c_int,
    );
}
extern "C" {
    pub fn ncplane_set_fg_rgb8_clipped(
        n: *mut ncplane,
        r: core::ffi::c_int,
        g: core::ffi::c_int,
        b: core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " Same, but with rgb assembled into a channel (i.e. lower 24 bits)."]
    pub fn ncplane_set_fg_rgb(n: *mut ncplane, channel: u32) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_rgb(n: *mut ncplane, channel: u32) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Use the default color for the foreground/background."]
    pub fn ncplane_set_fg_default(n: *mut ncplane);
}
extern "C" {
    pub fn ncplane_set_bg_default(n: *mut ncplane);
}
extern "C" {
    #[doc = " Set the ncplane's foreground palette index, set the foreground palette index"]
    #[doc = " bit, set it foreground-opaque, and clear the foreground default color bit."]
    pub fn ncplane_set_fg_palindex(n: *mut ncplane, idx: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_palindex(n: *mut ncplane, idx: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the alpha parameters for ncplane 'n'."]
    pub fn ncplane_set_fg_alpha(n: *mut ncplane, alpha: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_alpha(n: *mut ncplane, alpha: core::ffi::c_int) -> core::ffi::c_int;
}
#[doc = " Called for each fade iteration on 'ncp'. If anything but 0 is returned,"]
#[doc = " the fading operation ceases immediately, and that value is propagated out."]
#[doc = " The recommended absolute display time target is passed in 'tspec'."]
pub type fadecb = ::core::option::Option<
    unsafe extern "C" fn(
        nc: *mut notcurses,
        n: *mut ncplane,
        arg1: *const timespec,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
extern "C" {
    #[doc = " Fade the ncplane out over the provided time, calling 'fader' at each"]
    #[doc = " iteration. Requires a terminal which supports truecolor, or at least palette"]
    #[doc = " modification (if the terminal uses a palette, our ability to fade planes is"]
    #[doc = " limited, and affected by the complexity of the rest of the screen)."]
    pub fn ncplane_fadeout(
        n: *mut ncplane,
        ts: *const timespec,
        fader: fadecb,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Fade the ncplane in over the specified time. Load the ncplane with the"]
    #[doc = " target cells without rendering, then call this function. When it's done, the"]
    #[doc = " ncplane will have reached the target levels, starting from zeroes."]
    pub fn ncplane_fadein(
        n: *mut ncplane,
        ts: *const timespec,
        fader: fadecb,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Rather than the simple ncplane_fade{in/out}(), ncfadectx_setup() can be"]
    #[doc = " paired with a loop over ncplane_fade{in/out}_iteration() + ncfadectx_free()."]
    pub fn ncfadectx_setup(n: *mut ncplane) -> *mut ncfadectx;
}
extern "C" {
    #[doc = " Return the number of iterations through which 'nctx' will fade."]
    pub fn ncfadectx_iterations(nctx: *const ncfadectx) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Fade out through 'iter' iterations, where"]
    #[doc = " 'iter' < 'ncfadectx_iterations(nctx)'."]
    pub fn ncplane_fadeout_iteration(
        n: *mut ncplane,
        nctx: *mut ncfadectx,
        iter: core::ffi::c_int,
        fader: fadecb,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Fade in through 'iter' iterations, where"]
    #[doc = " 'iter' < 'ncfadectx_iterations(nctx)'."]
    pub fn ncplane_fadein_iteration(
        n: *mut ncplane,
        nctx: *mut ncfadectx,
        iter: core::ffi::c_int,
        fader: fadecb,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Pulse the plane in and out until the callback returns non-zero, relying on"]
    #[doc = " the callback 'fader' to initiate rendering. 'ts' defines the half-period"]
    #[doc = " (i.e. the transition from black to full brightness, or back again). Proper"]
    #[doc = " use involves preparing (but not rendering) an ncplane, then calling"]
    #[doc = " ncplane_pulse(), which will fade in from black to the specified colors."]
    pub fn ncplane_pulse(
        n: *mut ncplane,
        ts: *const timespec,
        fader: fadecb,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Release the resources associated with 'nctx'."]
    pub fn ncfadectx_free(nctx: *mut ncfadectx);
}
extern "C" {
    #[doc = " Open a visual at 'file', extract a codec and parameters, decode the first"]
    #[doc = " image to memory."]
    pub fn ncvisual_from_file(file: *const core::ffi::c_char) -> *mut ncvisual;
}
extern "C" {
    #[doc = " Prepare an ncvisual, and its underlying plane, based off RGBA content in"]
    #[doc = " memory at 'rgba'. 'rgba' is laid out as 'rows' lines, each of which is"]
    #[doc = " 'rowstride' bytes in length. Each line has 'cols' 32-bit 8bpc RGBA pixels"]
    #[doc = " followed by possible padding (there will be 'rowstride' - 'cols' * 4 bytes"]
    #[doc = " of padding). The total size of 'rgba' is thus (rows * rowstride) bytes, of"]
    #[doc = " which (rows * cols * 4) bytes are actual non-padding data."]
    pub fn ncvisual_from_rgba(
        rgba: *const core::ffi::c_void,
        rows: core::ffi::c_int,
        rowstride: core::ffi::c_int,
        cols: core::ffi::c_int,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " ncvisual_from_rgba(), but the pixels are 3-byte RGB. A is filled in"]
    #[doc = " throughout using 'alpha'."]
    pub fn ncvisual_from_rgb_packed(
        rgba: *const core::ffi::c_void,
        rows: core::ffi::c_int,
        rowstride: core::ffi::c_int,
        cols: core::ffi::c_int,
        alpha: core::ffi::c_int,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " ncvisual_from_rgba(), but the pixels are 4-byte RGBx. A is filled in"]
    #[doc = " throughout using 'alpha'. rowstride must be a multiple of 4."]
    pub fn ncvisual_from_rgb_loose(
        rgba: *const core::ffi::c_void,
        rows: core::ffi::c_int,
        rowstride: core::ffi::c_int,
        cols: core::ffi::c_int,
        alpha: core::ffi::c_int,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " ncvisual_from_rgba(), but 'bgra' is arranged as BGRA. note that this is a"]
    #[doc = " byte-oriented layout, despite being bunched in 32-bit pixels; the lowest"]
    #[doc = " memory address ought be B, and A is reached by adding 3 to that address."]
    pub fn ncvisual_from_bgra(
        bgra: *const core::ffi::c_void,
        rows: core::ffi::c_int,
        rowstride: core::ffi::c_int,
        cols: core::ffi::c_int,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " ncvisual_from_rgba(), but 'data' is 'pstride'-byte palette-indexed pixels,"]
    #[doc = " arranged in 'rows' lines of 'rowstride' bytes each, composed of 'cols'"]
    #[doc = " pixels. 'palette' is an array of at least 'palsize' ncchannels."]
    pub fn ncvisual_from_palidx(
        data: *const core::ffi::c_void,
        rows: core::ffi::c_int,
        rowstride: core::ffi::c_int,
        cols: core::ffi::c_int,
        palsize: core::ffi::c_int,
        pstride: core::ffi::c_int,
        palette: *const u32,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " Promote an ncplane 'n' to an ncvisual. The plane may contain only spaces,"]
    #[doc = " half blocks, and full blocks. The latter will be checked, and any other"]
    #[doc = " glyph will result in a NULL being returned. This function exists so that"]
    #[doc = " planes can be subjected to ncvisual transformations. If possible, it's"]
    #[doc = " better to create the ncvisual from memory using ncvisual_from_rgba()."]
    #[doc = " Lengths of 0 are interpreted to mean \"all available remaining area\"."]
    pub fn ncvisual_from_plane(
        n: *const ncplane,
        blit: ncblitter_e,
        begy: core::ffi::c_int,
        begx: core::ffi::c_int,
        leny: core::ffi::c_uint,
        lenx: core::ffi::c_uint,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " Construct an ncvisual from a nul-terminated Sixel control sequence."]
    pub fn ncvisual_from_sixel(
        s: *const core::ffi::c_char,
        leny: core::ffi::c_uint,
        lenx: core::ffi::c_uint,
    ) -> *mut ncvisual;
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncvisual_options {
    #[doc = " if no ncplane is provided, one will be created using the exact size"]
    #[doc = " necessary to render the source with perfect fidelity (this might be"]
    #[doc = " smaller or larger than the rendering area). if NCVISUAL_OPTION_CHILDPLANE"]
    #[doc = " is provided, this must be non-NULL, and will be interpreted as the parent."]
    pub n: *mut ncplane,
    #[doc = " the scaling is ignored if no ncplane is provided (it ought be NCSCALE_NONE"]
    #[doc = " in this case). otherwise, the source is stretched/scaled relative to the"]
    #[doc = " provided ncplane."]
    pub scaling: ncscale_e,
    #[doc = " if an ncplane is provided, y and x specify where the visual will be"]
    #[doc = " rendered on that plane. otherwise, they specify where the created ncplane"]
    #[doc = " will be placed relative to the standard plane's origin. x is an ncalign_e"]
    #[doc = " value if NCVISUAL_OPTION_HORALIGNED is provided. y is an ncalign_e if"]
    #[doc = " NCVISUAL_OPTION_VERALIGNED is provided."]
    pub y: core::ffi::c_int,
    #[doc = " if an ncplane is provided, y and x specify where the visual will be"]
    #[doc = " rendered on that plane. otherwise, they specify where the created ncplane"]
    #[doc = " will be placed relative to the standard plane's origin. x is an ncalign_e"]
    #[doc = " value if NCVISUAL_OPTION_HORALIGNED is provided. y is an ncalign_e if"]
    #[doc = " NCVISUAL_OPTION_VERALIGNED is provided."]
    pub x: core::ffi::c_int,
    #[doc = " origin of rendered region in pixels"]
    pub begy: core::ffi::c_uint,
    #[doc = " origin of rendered region in pixels"]
    pub begx: core::ffi::c_uint,
    #[doc = " size of rendered region in pixels"]
    pub leny: core::ffi::c_uint,
    #[doc = " size of rendered region in pixels"]
    pub lenx: core::ffi::c_uint,
    #[doc = " glyph set to use (maps input to output cells)"]
    pub blitter: ncblitter_e,
    #[doc = " bitmask over NCVISUAL_OPTION_*"]
    pub flags: u64,
    #[doc = " treat this color as transparent under NCVISUAL_OPTION_ADDALPHA"]
    pub transcolor: u32,
    #[doc = " pixel offsets within the cell. if NCBLIT_PIXEL is used, the bitmap will"]
    #[doc = " be drawn offset from the upper-left cell's origin by these amounts. it is"]
    #[doc = " an error if either number exceeds the cell-pixel geometry in its"]
    #[doc = " dimension. if NCBLIT_PIXEL is not used, these fields are ignored."]
    #[doc = " this functionality can be used for smooth bitmap movement."]
    pub pxoffy: core::ffi::c_uint,
    #[doc = " pixel offsets within the cell. if NCBLIT_PIXEL is used, the bitmap will"]
    #[doc = " be drawn offset from the upper-left cell's origin by these amounts. it is"]
    #[doc = " an error if either number exceeds the cell-pixel geometry in its"]
    #[doc = " dimension. if NCBLIT_PIXEL is not used, these fields are ignored."]
    #[doc = " this functionality can be used for smooth bitmap movement."]
    pub pxoffx: core::ffi::c_uint,
}
impl Default for ncvisual_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " describes all geometries of an ncvisual: those which are inherent, and those"]
#[doc = " dependent upon a given rendering regime. pixy and pixx are the true internal"]
#[doc = " pixel geometry, taken directly from the load (and updated by"]
#[doc = " ncvisual_resize()). cdimy/cdimx are the cell-pixel geometry *at the time"]
#[doc = " of this call* (it can change with a font change, in which case all values"]
#[doc = " other than pixy/pixx are invalidated). rpixy/rpixx are the pixel geometry as"]
#[doc = " handed to the blitter, following any scaling. scaley/scalex are the number"]
#[doc = " of input pixels drawn to a single cell; when using NCBLIT_PIXEL, they are"]
#[doc = " equivalent to cdimy/cdimx. rcelly/rcellx are the cell geometry as written by"]
#[doc = " the blitter, following any padding (there is padding whenever rpix{y, x} is"]
#[doc = " not evenly divided by scale{y, x}, and also sometimes for Sixel)."]
#[doc = " maxpixely/maxpixelx are defined only when NCBLIT_PIXEL is used, and specify"]
#[doc = " the largest bitmap that the terminal is willing to accept. blitter is the"]
#[doc = " blitter which will be used, a function of the requested blitter and the"]
#[doc = " blitters actually supported by this environment. if no ncvisual was"]
#[doc = " supplied, only cdimy/cdimx are filled in."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncvgeom {
    #[doc = " true pixel geometry of ncvisual data"]
    pub pixy: core::ffi::c_uint,
    #[doc = " true pixel geometry of ncvisual data"]
    pub pixx: core::ffi::c_uint,
    #[doc = " terminal cell geometry when this was calculated"]
    pub cdimy: core::ffi::c_uint,
    #[doc = " terminal cell geometry when this was calculated"]
    pub cdimx: core::ffi::c_uint,
    #[doc = " rendered pixel geometry (per visual_options)"]
    pub rpixy: core::ffi::c_uint,
    #[doc = " rendered pixel geometry (per visual_options)"]
    pub rpixx: core::ffi::c_uint,
    #[doc = " rendered cell geometry (per visual_options)"]
    pub rcelly: core::ffi::c_uint,
    #[doc = " rendered cell geometry (per visual_options)"]
    pub rcellx: core::ffi::c_uint,
    #[doc = " source pixels per filled cell"]
    pub scaley: core::ffi::c_uint,
    #[doc = " source pixels per filled cell"]
    pub scalex: core::ffi::c_uint,
    #[doc = " upper-left corner of used region"]
    pub begy: core::ffi::c_uint,
    #[doc = " upper-left corner of used region"]
    pub begx: core::ffi::c_uint,
    #[doc = " geometry of used region"]
    pub leny: core::ffi::c_uint,
    #[doc = " geometry of used region"]
    pub lenx: core::ffi::c_uint,
    #[doc = " only defined for NCBLIT_PIXEL"]
    pub maxpixely: core::ffi::c_uint,
    #[doc = " only defined for NCBLIT_PIXEL"]
    pub maxpixelx: core::ffi::c_uint,
    #[doc = " blitter that will be used"]
    pub blitter: ncblitter_e,
}
impl Default for ncvgeom {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " all-purpose ncvisual geometry solver. one or both of 'nc' and 'n' must be"]
    #[doc = " non-NULL. if 'nc' is NULL, only pixy/pixx will be filled in, with the true"]
    #[doc = " pixel geometry of 'n'. if 'n' is NULL, only cdimy/cdimx, blitter,"]
    #[doc = " scaley/scalex, and maxpixely/maxpixelx are filled in. cdimy/cdimx and"]
    #[doc = " maxpixely/maxpixelx are only ever filled in if we know them."]
    pub fn ncvisual_geom(
        nc: *const notcurses,
        n: *const ncvisual,
        vopts: *const ncvisual_options,
        geom: *mut ncvgeom,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Destroy an ncvisual. Rendered elements will not be disrupted, but the visual"]
    #[doc = " can be neither decoded nor rendered any further."]
    pub fn ncvisual_destroy(ncv: *mut ncvisual);
}
extern "C" {
    #[doc = " extract the next frame from an ncvisual. returns 1 on end of file, 0 on"]
    #[doc = " success, and -1 on failure."]
    pub fn ncvisual_decode(nc: *mut ncvisual) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " decode the next frame ala ncvisual_decode(), but if we have reached the end,"]
    #[doc = " rewind to the first frame of the ncvisual. a subsequent 'ncvisual_blit()'"]
    #[doc = " will render the first frame, as if the ncvisual had been closed and reopened."]
    #[doc = " the return values remain the same as those of ncvisual_decode()."]
    pub fn ncvisual_decode_loop(nc: *mut ncvisual) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Rotate the visual 'rads' radians. Only M_PI/2 and -M_PI/2 are supported at"]
    #[doc = " the moment, but this might change in the future."]
    pub fn ncvisual_rotate(n: *mut ncvisual, rads: f64) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Scale the visual to 'rows' X 'columns' pixels, using the best scheme"]
    #[doc = " available. This is a lossy transformation, unless the size is unchanged."]
    pub fn ncvisual_resize(
        n: *mut ncvisual,
        rows: core::ffi::c_int,
        cols: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Scale the visual to 'rows' X 'columns' pixels, using non-interpolative"]
    #[doc = " (naive) scaling. No new colors will be introduced as a result."]
    pub fn ncvisual_resize_noninterpolative(
        n: *mut ncvisual,
        rows: core::ffi::c_int,
        cols: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Polyfill at the specified location within the ncvisual 'n', using 'rgba'."]
    pub fn ncvisual_polyfill_yx(
        n: *mut ncvisual,
        y: core::ffi::c_uint,
        x: core::ffi::c_uint,
        rgba: u32,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the specified pixel from the specified ncvisual."]
    pub fn ncvisual_at_yx(
        n: *const ncvisual,
        y: core::ffi::c_uint,
        x: core::ffi::c_uint,
        pixel: *mut u32,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the specified pixel in the specified ncvisual."]
    pub fn ncvisual_set_yx(
        n: *const ncvisual,
        y: core::ffi::c_uint,
        x: core::ffi::c_uint,
        pixel: u32,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Render the decoded frame according to the provided options (which may be"]
    #[doc = " NULL). The plane used for rendering depends on vopts->n and vopts->flags."]
    #[doc = " If NCVISUAL_OPTION_CHILDPLANE is set, vopts->n must not be NULL, and the"]
    #[doc = " plane will always be created as a child of vopts->n. If this flag is not"]
    #[doc = " set, and vopts->n is NULL, a new plane is created as root of a new pile."]
    #[doc = " If the flag is not set and vopts->n is not NULL, we render to vopts->n."]
    #[doc = " A subregion of the visual can be rendered using 'begx', 'begy', 'lenx', and"]
    #[doc = " 'leny'. Negative values for any of these are an error. It is an error to"]
    #[doc = " specify any region beyond the boundaries of the frame. Returns the (possibly"]
    #[doc = " newly-created) plane to which we drew. Pixels may not be blitted to the"]
    #[doc = " standard plane."]
    pub fn ncvisual_blit(
        nc: *mut notcurses,
        ncv: *mut ncvisual,
        vopts: *const ncvisual_options,
    ) -> *mut ncplane;
}
extern "C" {
    #[doc = " If a subtitle ought be displayed at this time, return a new plane (bound"]
    #[doc = " to 'parent' containing the subtitle, which might be text or graphics"]
    #[doc = " (depending on the input format)."]
    pub fn ncvisual_subtitle_plane(parent: *mut ncplane, ncv: *const ncvisual) -> *mut ncplane;
}
extern "C" {
    #[doc = " Get the default *media* (not plot) blitter for this environment when using"]
    #[doc = " the specified scaling method. Currently, this means:"]
    #[doc = "  - if lacking UTF-8, NCBLIT_1x1"]
    #[doc = "  - otherwise, if not NCSCALE_STRETCH, NCBLIT_2x1"]
    #[doc = "  - otherwise, if sextants are not known to be good, NCBLIT_2x2"]
    #[doc = "  - otherwise NCBLIT_3x2"]
    #[doc = " NCBLIT_2x2 and NCBLIT_3x2 both distort the original aspect ratio, thus"]
    #[doc = " NCBLIT_2x1 is used outside of NCSCALE_STRETCH."]
    pub fn ncvisual_media_defblitter(nc: *const notcurses, scale: ncscale_e) -> ncblitter_e;
}
#[doc = " Called for each frame rendered from 'ncv'. If anything but 0 is returned,"]
#[doc = " the streaming operation ceases immediately, and that value is propagated out."]
#[doc = " The recommended absolute display time target is passed in 'tspec'."]
pub type ncstreamcb = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ncvisual,
        arg2: *mut ncvisual_options,
        arg3: *const timespec,
        arg4: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
extern "C" {
    #[doc = " Shut up and display my frames! Provide as an argument to ncvisual_stream()."]
    #[doc = " If you'd like subtitles to be decoded, provide an ncplane as the curry. If the"]
    #[doc = " curry is NULL, subtitles will not be displayed."]
    pub fn ncvisual_simple_streamer(
        ncv: *mut ncvisual,
        vopts: *mut ncvisual_options,
        tspec: *const timespec,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Stream the entirety of the media, according to its own timing. Blocking,"]
    #[doc = " obviously. streamer may be NULL; it is otherwise called for each frame, and"]
    #[doc = " its return value handled as outlined for streamcb. If streamer() returns"]
    #[doc = " non-zero, the stream is aborted, and that value is returned. By convention,"]
    #[doc = " return a positive number to indicate intentional abort from within"]
    #[doc = " streamer(). 'timescale' allows the frame duration time to be scaled. For a"]
    #[doc = " visual naturally running at 30FPS, a 'timescale' of 0.1 will result in"]
    #[doc = " 300FPS, and a 'timescale' of 10 will result in 3FPS. It is an error to"]
    #[doc = " supply 'timescale' less than or equal to 0."]
    pub fn ncvisual_stream(
        nc: *mut notcurses,
        ncv: *mut ncvisual,
        timescale: f32,
        streamer: ncstreamcb,
        vopts: *const ncvisual_options,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Blit a flat array 'data' of RGBA 32-bit values to the ncplane 'vopts->n',"]
    #[doc = " which mustn't be NULL. the blit begins at 'vopts->y' and 'vopts->x' relative"]
    #[doc = " to the specified plane. Each source row ought occupy 'linesize' bytes (this"]
    #[doc = " might be greater than 'vopts->lenx' * 4 due to padding or partial blits). A"]
    #[doc = " subregion of the input can be specified with the 'begy'x'begx' and"]
    #[doc = " 'leny'x'lenx' fields from 'vopts'. Returns the number of pixels blitted, or"]
    #[doc = " -1 on error."]
    pub fn ncblit_rgba(
        data: *const core::ffi::c_void,
        linesize: core::ffi::c_int,
        vopts: *const ncvisual_options,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Same as ncblit_rgba(), but for BGRx."]
    pub fn ncblit_bgrx(
        data: *const core::ffi::c_void,
        linesize: core::ffi::c_int,
        vopts: *const ncvisual_options,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Supply an alpha value [0..255] to be applied throughout."]
    pub fn ncblit_rgb_packed(
        data: *const core::ffi::c_void,
        linesize: core::ffi::c_int,
        vopts: *const ncvisual_options,
        alpha: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Supply an alpha value [0..255] to be applied throughout. linesize must be"]
    #[doc = " a multiple of 4 for this RGBx data."]
    pub fn ncblit_rgb_loose(
        data: *const core::ffi::c_void,
        linesize: core::ffi::c_int,
        vopts: *const ncvisual_options,
        alpha: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncreel_options {
    #[doc = " bitfield; 1s will not be drawn (see bordermaskbits)"]
    pub bordermask: core::ffi::c_uint,
    #[doc = " attributes used for ncreel border"]
    pub borderchan: u64,
    #[doc = " bitfield; same as bordermask but for tablet borders"]
    pub tabletmask: core::ffi::c_uint,
    #[doc = " tablet border styling channel"]
    pub tabletchan: u64,
    #[doc = " focused tablet border styling channel"]
    pub focusedchan: u64,
    #[doc = " bitfield over NCREEL_OPTION_*"]
    pub flags: u64,
}
extern "C" {
    #[doc = " Take over the ncplane 'nc' and use it to draw a reel according to 'popts'."]
    #[doc = " The plane will be destroyed by ncreel_destroy(); this transfers ownership."]
    pub fn ncreel_create(n: *mut ncplane, popts: *const ncreel_options) -> *mut ncreel;
}
extern "C" {
    #[doc = " Returns the ncplane on which this ncreel lives."]
    pub fn ncreel_plane(nr: *mut ncreel) -> *mut ncplane;
}
#[doc = " Tablet draw callback, provided a tablet (from which the ncplane and userptr"]
#[doc = " may be extracted), and a bool indicating whether output ought be drawn from"]
#[doc = " the top (true) or bottom (false). Returns non-negative count of output lines,"]
#[doc = " which must be less than or equal to ncplane_dim_y(nctablet_plane(t))."]
pub type tabletcb = ::core::option::Option<
    unsafe extern "C" fn(t: *mut nctablet, drawfromtop: bool) -> core::ffi::c_int,
>;
extern "C" {
    #[doc = " Add a new nctablet to the provided ncreel 'nr', having the callback object"]
    #[doc = " 'opaque'. Neither, either, or both of 'after' and 'before' may be specified."]
    #[doc = " If neither is specified, the new tablet can be added anywhere on the reel."]
    #[doc = " If one or the other is specified, the tablet will be added before or after"]
    #[doc = " the specified tablet. If both are specified, the tablet will be added to the"]
    #[doc = " resulting location, assuming it is valid (after->next == before->prev); if"]
    #[doc = " it is not valid, or there is any other error, NULL will be returned."]
    pub fn ncreel_add(
        nr: *mut ncreel,
        after: *mut nctablet,
        before: *mut nctablet,
        cb: tabletcb,
        opaque: *mut core::ffi::c_void,
    ) -> *mut nctablet;
}
extern "C" {
    #[doc = " Return the number of nctablets in the ncreel 'nr'."]
    pub fn ncreel_tabletcount(nr: *const ncreel) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Delete the tablet specified by t from the ncreel 'nr'. Returns -1 if the"]
    #[doc = " tablet cannot be found."]
    pub fn ncreel_del(nr: *mut ncreel, t: *mut nctablet) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Redraw the ncreel 'nr' in its entirety. The reel will be cleared, and"]
    #[doc = " tablets will be lain out, using the focused tablet as a fulcrum. Tablet"]
    #[doc = " drawing callbacks will be invoked for each visible tablet."]
    pub fn ncreel_redraw(nr: *mut ncreel) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Offer input 'ni' to the ncreel 'nr'. If it's relevant, this function returns"]
    #[doc = " true, and the input ought not be processed further. If it's irrelevant to"]
    #[doc = " the reel, false is returned. Relevant inputs include:"]
    #[doc = "  * a mouse click on a tablet (focuses tablet)"]
    #[doc = "  * a mouse scrollwheel event (rolls reel)"]
    #[doc = "  * up, down, pgup, or pgdown (navigates among items)"]
    pub fn ncreel_offer_input(nr: *mut ncreel, ni: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Return the focused tablet, if any tablets are present. This is not a copy;"]
    #[doc = " be careful to use it only for the duration of a critical section."]
    pub fn ncreel_focused(nr: *mut ncreel) -> *mut nctablet;
}
extern "C" {
    #[doc = " Change focus to the next tablet, if one exists"]
    pub fn ncreel_next(nr: *mut ncreel) -> *mut nctablet;
}
extern "C" {
    #[doc = " Change focus to the previous tablet, if one exists"]
    pub fn ncreel_prev(nr: *mut ncreel) -> *mut nctablet;
}
extern "C" {
    #[doc = " Destroy an ncreel allocated with ncreel_create()."]
    pub fn ncreel_destroy(nr: *mut ncreel);
}
extern "C" {
    #[doc = " Returns a pointer to a user pointer associated with this nctablet."]
    pub fn nctablet_userptr(t: *mut nctablet) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Access the ncplane associated with nctablet 't', if one exists."]
    pub fn nctablet_plane(t: *mut nctablet) -> *mut ncplane;
}
extern "C" {
    #[doc = " snprintf(3) is used internally, with 's' as its size bound. If the output"]
    #[doc = " requires more size than is available, NULL will be returned."]
    #[doc = ""]
    #[doc = " Floating-point is never used, because an IEEE758 double can only losslessly"]
    #[doc = " represent integers through 2^53-1."]
    #[doc = ""]
    #[doc = " 2^64-1 is 18446744073709551615, 18.45E(xa). KMGTPEZY thus suffice to handle"]
    #[doc = " an 89-bit uintmax_t. Beyond Z(etta) and Y(otta) lie lands unspecified by SI."]
    #[doc = " 2^-63 is 0.000000000000000000108, 1.08a(tto)."]
    #[doc = " val: value to print"]
    #[doc = " s: maximum output size; see snprintf(3)"]
    #[doc = " decimal: scaling. '1' if none has taken place."]
    #[doc = " buf: buffer in which string will be generated"]
    #[doc = " omitdec: inhibit printing of all-0 decimal portions"]
    #[doc = " mult: base of suffix system (almost always 1000 or 1024)"]
    #[doc = " uprefix: character to print following suffix ('i' for kibibytes basically)."]
    #[doc = "   only printed if suffix is actually printed (input >= mult)."]
    #[doc = ""]
    #[doc = " You are encouraged to consult notcurses_metric(3)."]
    pub fn ncnmetric(
        val: uintmax_t,
        s: usize,
        decimal: uintmax_t,
        buf: *mut core::ffi::c_char,
        omitdec: core::ffi::c_int,
        mult: uintmax_t,
        uprefix: core::ffi::c_int,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get the default foreground color, if it is known. Returns -1 on error"]
    #[doc = " (unknown foreground). On success, returns 0, writing the RGB value to"]
    #[doc = " 'fg' (if non-NULL)"]
    pub fn notcurses_default_foreground(nc: *const notcurses, fg: *mut u32) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the default background color, if it is known. Returns -1 on error"]
    #[doc = " (unknown background). On success, returns 0, writing the RGB value to"]
    #[doc = " 'bg' (if non-NULL) and setting 'bgtrans' high iff the background color"]
    #[doc = " is treated as transparent."]
    pub fn notcurses_default_background(nc: *const notcurses, bg: *mut u32) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Enable or disable the terminal's cursor, if supported, placing it at"]
    #[doc = " 'y', 'x'. Immediate effect (no need for a call to notcurses_render())."]
    #[doc = " It is an error if 'y', 'x' lies outside the standard plane. Can be"]
    #[doc = " called while already visible to move the cursor."]
    pub fn notcurses_cursor_enable(
        nc: *mut notcurses,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Disable the hardware cursor. It is an error to call this while the"]
    #[doc = " cursor is already disabled."]
    pub fn notcurses_cursor_disable(nc: *mut notcurses) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the current location of the terminal's cursor, whether visible or not."]
    pub fn notcurses_cursor_yx(
        nc: *const notcurses,
        y: *mut core::ffi::c_int,
        x: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Convert the plane's content to greyscale."]
    pub fn ncplane_greyscale(n: *mut ncplane);
}
#[doc = " selection widget -- an ncplane with a title header and a body section. the"]
#[doc = " body section supports infinite scrolling up and down."]
#[doc = ""]
#[doc = " At all times, exactly one item is selected."]
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncselector_item {
    pub option: *const core::ffi::c_char,
    pub desc: *const core::ffi::c_char,
}
impl Default for ncselector_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncselector_options {
    #[doc = " title may be NULL, inhibiting riser, saving two rows."]
    pub title: *const core::ffi::c_char,
    #[doc = " secondary may be NULL"]
    pub secondary: *const core::ffi::c_char,
    #[doc = " footer may be NULL"]
    pub footer: *const core::ffi::c_char,
    #[doc = " initial items and descriptions"]
    pub items: *const ncselector_item,
    #[doc = " default item (selected at start), must be < itemcount unless itemcount is"]
    #[doc = " 0, in which case 'defidx' must also be 0"]
    pub defidx: core::ffi::c_uint,
    #[doc = " maximum number of options to display at once, 0 to use all available space"]
    pub maxdisplay: core::ffi::c_uint,
    #[doc = " option channels"]
    pub opchannels: u64,
    #[doc = " description channels"]
    pub descchannels: u64,
    #[doc = " title channels"]
    pub titlechannels: u64,
    #[doc = " secondary and footer channels"]
    pub footchannels: u64,
    #[doc = " border channels"]
    pub boxchannels: u64,
    #[doc = " bitfield of NCSELECTOR_OPTION_*, currently unused"]
    pub flags: u64,
}
impl Default for ncselector_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ncselector_create(n: *mut ncplane, opts: *const ncselector_options) -> *mut ncselector;
}
extern "C" {
    #[doc = " Dynamically add or delete items. It is usually sufficient to supply a static"]
    #[doc = " list of items via ncselector_options->items."]
    pub fn ncselector_additem(n: *mut ncselector, item: *const ncselector_item)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn ncselector_delitem(
        n: *mut ncselector,
        item: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return reference to the selected option, or NULL if there are no items."]
    pub fn ncselector_selected(n: *const ncselector) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Return a reference to the ncselector's underlying ncplane."]
    pub fn ncselector_plane(n: *mut ncselector) -> *mut ncplane;
}
extern "C" {
    #[doc = " Move up or down in the list. A reference to the newly-selected item is"]
    #[doc = " returned, or NULL if there are no items in the list."]
    pub fn ncselector_previtem(n: *mut ncselector) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn ncselector_nextitem(n: *mut ncselector) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Offer the input to the ncselector. If it's relevant, this function returns"]
    #[doc = " true, and the input ought not be processed further. If it's irrelevant to"]
    #[doc = " the selector, false is returned. Relevant inputs include:"]
    #[doc = "  * a mouse click on an item"]
    #[doc = "  * a mouse scrollwheel event"]
    #[doc = "  * a mouse click on the scrolling arrows"]
    #[doc = "  * up, down, pgup, or pgdown on an unrolled menu (navigates among items)"]
    pub fn ncselector_offer_input(n: *mut ncselector, nc: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Destroy the ncselector."]
    pub fn ncselector_destroy(n: *mut ncselector, item: *mut *mut core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmselector_item {
    pub option: *const core::ffi::c_char,
    pub desc: *const core::ffi::c_char,
    pub selected: bool,
}
impl Default for ncmselector_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " multiselection widget -- a selector supporting multiple selections."]
#[doc = ""]
#[doc = " Unlike the selector widget, zero to all of the items can be selected, but"]
#[doc = " also the widget does not support adding or removing items at runtime."]
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmultiselector_options {
    #[doc = " title may be NULL, inhibiting riser, saving two rows."]
    pub title: *const core::ffi::c_char,
    #[doc = " secondary may be NULL"]
    pub secondary: *const core::ffi::c_char,
    #[doc = " footer may be NULL"]
    pub footer: *const core::ffi::c_char,
    #[doc = " initial items, descriptions, and statuses"]
    pub items: *const ncmselector_item,
    #[doc = " maximum number of options to display at once, 0 to use all available space"]
    pub maxdisplay: core::ffi::c_uint,
    #[doc = " option channels"]
    pub opchannels: u64,
    #[doc = " description channels"]
    pub descchannels: u64,
    #[doc = " title channels"]
    pub titlechannels: u64,
    #[doc = " secondary and footer channels"]
    pub footchannels: u64,
    #[doc = " border channels"]
    pub boxchannels: u64,
    #[doc = " bitfield of NCMULTISELECTOR_OPTION_*, currently unused"]
    pub flags: u64,
}
impl Default for ncmultiselector_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ncmultiselector_create(
        n: *mut ncplane,
        opts: *const ncmultiselector_options,
    ) -> *mut ncmultiselector;
}
extern "C" {
    #[doc = " Return selected vector. An array of bools must be provided, along with its"]
    #[doc = " length. If that length doesn't match the itemcount, it is an error."]
    pub fn ncmultiselector_selected(
        n: *mut ncmultiselector,
        selected: *mut bool,
        count: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return a reference to the ncmultiselector's underlying ncplane."]
    pub fn ncmultiselector_plane(n: *mut ncmultiselector) -> *mut ncplane;
}
extern "C" {
    #[doc = " Offer the input to the ncmultiselector. If it's relevant, this function"]
    #[doc = " returns true, and the input ought not be processed further. If it's"]
    #[doc = " irrelevant to the multiselector, false is returned. Relevant inputs include:"]
    #[doc = "  * a mouse click on an item"]
    #[doc = "  * a mouse scrollwheel event"]
    #[doc = "  * a mouse click on the scrolling arrows"]
    #[doc = "  * up, down, pgup, or pgdown on an unrolled menu (navigates among items)"]
    pub fn ncmultiselector_offer_input(n: *mut ncmultiselector, nc: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Destroy the ncmultiselector."]
    pub fn ncmultiselector_destroy(n: *mut ncmultiselector);
}
#[doc = " each item has a curry, and zero or more subitems."]
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nctree_item {
    pub curry: *mut core::ffi::c_void,
    pub subs: *mut nctree_item,
    pub subcount: core::ffi::c_uint,
}
impl Default for nctree_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nctree_options {
    #[doc = " top-level nctree_item array"]
    pub items: *const nctree_item,
    #[doc = " size of |items|"]
    pub count: core::ffi::c_uint,
    #[doc = " item callback function"]
    pub nctreecb: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ncplane,
            arg2: *mut core::ffi::c_void,
            arg3: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    #[doc = " columns to indent per level of hierarchy"]
    pub indentcols: core::ffi::c_int,
    #[doc = " bitfield of NCTREE_OPTION_*"]
    pub flags: u64,
}
impl Default for nctree_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nctree {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " |opts| may *not* be NULL, since it is necessary to define a callback"]
    #[doc = " function."]
    pub fn nctree_create(n: *mut ncplane, opts: *const nctree_options) -> *mut nctree;
}
extern "C" {
    #[doc = " Returns the ncplane on which this nctree lives."]
    pub fn nctree_plane(n: *mut nctree) -> *mut ncplane;
}
extern "C" {
    #[doc = " Redraw the nctree 'n' in its entirety. The tree will be cleared, and items"]
    #[doc = " will be lain out, using the focused item as a fulcrum. Item-drawing"]
    #[doc = " callbacks will be invoked for each visible item."]
    pub fn nctree_redraw(n: *mut nctree) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Offer input 'ni' to the nctree 'n'. If it's relevant, this function returns"]
    #[doc = " true, and the input ought not be processed further. If it's irrelevant to"]
    #[doc = " the tree, false is returned. Relevant inputs include:"]
    #[doc = "  * a mouse click on an item (focuses item)"]
    #[doc = "  * a mouse scrollwheel event (srolls tree)"]
    #[doc = "  * up, down, pgup, or pgdown (navigates among items)"]
    pub fn nctree_offer_input(n: *mut nctree, ni: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Return the focused item, if any items are present. This is not a copy;"]
    #[doc = " be careful to use it only for the duration of a critical section."]
    pub fn nctree_focused(n: *mut nctree) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Change focus to the next item."]
    pub fn nctree_next(n: *mut nctree) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Change focus to the previous item."]
    pub fn nctree_prev(n: *mut nctree) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Go to the item specified by the array |spec| (a spec is a series of unsigned"]
    #[doc = " values, each identifying a subelement in the hierarchy thus far, terminated"]
    #[doc = " by UINT_MAX). If the spec is invalid, NULL is returned, and the depth of the"]
    #[doc = " first invalid spec is written to *|failspec|. Otherwise, the true depth is"]
    #[doc = " written to *|failspec|, and the curry is returned (|failspec| is necessary"]
    #[doc = " because the curry could itself be NULL)."]
    pub fn nctree_goto(
        n: *mut nctree,
        spec: *const core::ffi::c_uint,
        failspec: *mut core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Insert |add| into the nctree |n| at |spec|. The path up to the last element"]
    #[doc = " must already exist. If an item already exists at the path, it will be moved"]
    #[doc = " to make room for |add|."]
    pub fn nctree_add(
        n: *mut nctree,
        spec: *const core::ffi::c_uint,
        add: *const nctree_item,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Delete the item at |spec|, including any subitems."]
    pub fn nctree_del(n: *mut nctree, spec: *const core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Destroy the nctree."]
    pub fn nctree_destroy(n: *mut nctree);
}
#[doc = " Menus. Horizontal menu bars are supported, on the top and/or bottom rows."]
#[doc = " If the menu bar is longer than the screen, it will be only partially"]
#[doc = " visible. Menus may be either visible or invisible by default. In the event of"]
#[doc = " a plane resize, menus will be automatically moved/resized. Elements can be"]
#[doc = " dynamically enabled or disabled at all levels (menu, section, and item),"]
#[repr(C)]
#[derive(Debug, Hash)]
pub struct ncmenu_item {
    #[doc = " utf-8 menu item, NULL for horizontal separator"]
    pub desc: *const core::ffi::c_char,
    #[doc = " shortcut, all should be distinct"]
    pub shortcut: ncinput,
}
impl Default for ncmenu_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Hash)]
pub struct ncmenu_section {
    #[doc = " utf-8 c string"]
    pub name: *const core::ffi::c_char,
    pub itemcount: core::ffi::c_int,
    pub items: *mut ncmenu_item,
    #[doc = " shortcut, will be underlined if present in name"]
    pub shortcut: ncinput,
}
impl Default for ncmenu_section {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmenu_options {
    #[doc = " array of 'sectioncount' menu_sections"]
    pub sections: *mut ncmenu_section,
    #[doc = " must be positive"]
    pub sectioncount: core::ffi::c_int,
    #[doc = " styling for header"]
    pub headerchannels: u64,
    #[doc = " styling for sections"]
    pub sectionchannels: u64,
    #[doc = " flag word of NCMENU_OPTION_*"]
    pub flags: u64,
}
impl Default for ncmenu_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ncmenu {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a menu with the specified options, bound to the specified plane."]
    pub fn ncmenu_create(n: *mut ncplane, opts: *const ncmenu_options) -> *mut ncmenu;
}
extern "C" {
    #[doc = " Unroll the specified menu section, making the menu visible if it was"]
    #[doc = " invisible, and rolling up any menu section that is already unrolled."]
    pub fn ncmenu_unroll(n: *mut ncmenu, sectionidx: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Roll up any unrolled menu section, and hide the menu if using hiding."]
    pub fn ncmenu_rollup(n: *mut ncmenu) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Unroll the previous/next section (relative to current unrolled). If no"]
    #[doc = " section is unrolled, the first section will be unrolled."]
    pub fn ncmenu_nextsection(n: *mut ncmenu) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncmenu_prevsection(n: *mut ncmenu) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Move to the previous/next item within the currently unrolled section. If no"]
    #[doc = " section is unrolled, the first section will be unrolled."]
    pub fn ncmenu_nextitem(n: *mut ncmenu) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncmenu_previtem(n: *mut ncmenu) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Disable or enable a menu item. Returns 0 if the item was found."]
    pub fn ncmenu_item_set_status(
        n: *mut ncmenu,
        section: *const core::ffi::c_char,
        item: *const core::ffi::c_char,
        enabled: bool,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return the selected item description, or NULL if no section is unrolled. If"]
    #[doc = " 'ni' is not NULL, and the selected item has a shortcut, 'ni' will be filled"]
    #[doc = " in with that shortcut--this can allow faster matching."]
    pub fn ncmenu_selected(n: *const ncmenu, ni: *mut ncinput) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Return the item description corresponding to the mouse click 'click'. The"]
    #[doc = " item must be on an actively unrolled section, and the click must be in the"]
    #[doc = " area of a valid item. If 'ni' is not NULL, and the selected item has a"]
    #[doc = " shortcut, 'ni' will be filled in with the shortcut."]
    pub fn ncmenu_mouse_selected(
        n: *const ncmenu,
        click: *const ncinput,
        ni: *mut ncinput,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Return the ncplane backing this ncmenu."]
    pub fn ncmenu_plane(n: *mut ncmenu) -> *mut ncplane;
}
extern "C" {
    #[doc = " Offer the input to the ncmenu. If it's relevant, this function returns true,"]
    #[doc = " and the input ought not be processed further. If it's irrelevant to the"]
    #[doc = " menu, false is returned. Relevant inputs include:"]
    #[doc = "  * mouse movement over a hidden menu"]
    #[doc = "  * a mouse click on a menu section (the section is unrolled)"]
    #[doc = "  * a mouse click outside of an unrolled menu (the menu is rolled up)"]
    #[doc = "  * left or right on an unrolled menu (navigates among sections)"]
    #[doc = "  * up or down on an unrolled menu (navigates among items)"]
    #[doc = "  * escape on an unrolled menu (the menu is rolled up)"]
    pub fn ncmenu_offer_input(n: *mut ncmenu, nc: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Destroy a menu created with ncmenu_create()."]
    pub fn ncmenu_destroy(n: *mut ncmenu);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncprogbar_options {
    #[doc = " upper-left channel. in the context of a progress bar,"]
    pub ulchannel: u32,
    #[doc = " \"up\" is the direction we are progressing towards, and"]
    pub urchannel: u32,
    #[doc = " \"bottom\" is the direction of origin. for monochromatic"]
    pub blchannel: u32,
    #[doc = " bar, all four channels ought be the same."]
    pub brchannel: u32,
    pub flags: u64,
}
extern "C" {
    #[doc = " Takes ownership of the ncplane 'n', which will be destroyed by"]
    #[doc = " ncprogbar_destroy(). The progress bar is initially at 0%."]
    pub fn ncprogbar_create(n: *mut ncplane, opts: *const ncprogbar_options) -> *mut ncprogbar;
}
extern "C" {
    #[doc = " Return a reference to the ncprogbar's underlying ncplane."]
    pub fn ncprogbar_plane(n: *mut ncprogbar) -> *mut ncplane;
}
extern "C" {
    #[doc = " Set the progress bar's completion, a double 0 <= 'p' <= 1."]
    pub fn ncprogbar_set_progress(n: *mut ncprogbar, p: f64) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the progress bar's completion, a double on [0, 1]."]
    pub fn ncprogbar_progress(n: *const ncprogbar) -> f64;
}
extern "C" {
    #[doc = " Destroy the progress bar and its underlying ncplane."]
    pub fn ncprogbar_destroy(n: *mut ncprogbar);
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nctabbed_options {
    #[doc = " channel for the selected tab header"]
    pub selchan: u64,
    #[doc = " channel for unselected tab headers"]
    pub hdrchan: u64,
    #[doc = " channel for the tab separator"]
    pub sepchan: u64,
    #[doc = " separator string (copied by nctabbed_create())"]
    pub separator: *const core::ffi::c_char,
    #[doc = " bitmask of NCTABBED_OPTION_*"]
    pub flags: u64,
}
impl Default for nctabbed_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Tab content drawing callback. Takes the tab it was associated to, the ncplane"]
#[doc = " on which tab content is to be drawn, and the user pointer of the tab."]
#[doc = " It is called during nctabbed_redraw()."]
pub type tabcb = ::core::option::Option<
    unsafe extern "C" fn(t: *mut nctab, ncp: *mut ncplane, curry: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " Creates a new nctabbed widget, associated with the given ncplane 'n', and with"]
    #[doc = " additional options given in 'opts'. When 'opts' is NULL, it acts as if it were"]
    #[doc = " called with an all-zero opts. The widget takes ownership of 'n', and destroys"]
    #[doc = " it when the widget is destroyed. Returns the newly created widget. Returns"]
    #[doc = " NULL on failure, also destroying 'n'."]
    pub fn nctabbed_create(n: *mut ncplane, opts: *const nctabbed_options) -> *mut nctabbed;
}
extern "C" {
    #[doc = " Destroy an nctabbed widget. All memory belonging to 'nt' is deallocated,"]
    #[doc = " including all tabs and their names. The plane associated with 'nt' is also"]
    #[doc = " destroyed. Calling this with NULL does nothing."]
    pub fn nctabbed_destroy(nt: *mut nctabbed);
}
extern "C" {
    #[doc = " Redraw the widget. This calls the tab callback of the currently selected tab"]
    #[doc = " to draw tab contents, and draws tab headers. The tab content plane is not"]
    #[doc = " modified by this function, apart from resizing the plane is necessary."]
    pub fn nctabbed_redraw(nt: *mut nctabbed);
}
extern "C" {
    #[doc = " Make sure the tab header of the currently selected tab is at least partially"]
    #[doc = " visible. (by rotating tabs until at least one column is displayed)"]
    #[doc = " Does nothing if there are no tabs."]
    pub fn nctabbed_ensure_selected_header_visible(nt: *mut nctabbed);
}
extern "C" {
    #[doc = " Returns the currently selected tab, or NULL if there are no tabs."]
    pub fn nctabbed_selected(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Returns the leftmost tab, or NULL if there are no tabs."]
    pub fn nctabbed_leftmost(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Returns the number of tabs in the widget."]
    pub fn nctabbed_tabcount(nt: *mut nctabbed) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Returns the plane associated to 'nt'."]
    pub fn nctabbed_plane(nt: *mut nctabbed) -> *mut ncplane;
}
extern "C" {
    #[doc = " Returns the tab content plane."]
    pub fn nctabbed_content_plane(nt: *mut nctabbed) -> *mut ncplane;
}
extern "C" {
    #[doc = " Returns the tab callback."]
    pub fn nctab_cb(t: *mut nctab) -> tabcb;
}
extern "C" {
    #[doc = " Returns the tab name. This is not a copy and it should not be stored."]
    pub fn nctab_name(t: *mut nctab) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns the width (in columns) of the tab's name."]
    pub fn nctab_name_width(t: *mut nctab) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Returns the tab's user pointer."]
    pub fn nctab_userptr(t: *mut nctab) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Returns the tab to the right of 't'. This does not change which tab is selected."]
    pub fn nctab_next(t: *mut nctab) -> *mut nctab;
}
extern "C" {
    #[doc = " Returns the tab to the left of 't'. This does not change which tab is selected."]
    pub fn nctab_prev(t: *mut nctab) -> *mut nctab;
}
extern "C" {
    #[doc = " Add a new tab to 'nt' with the given tab callback, name, and user pointer."]
    #[doc = " If both 'before' and 'after' are NULL, the tab is inserted after the selected"]
    #[doc = " tab. Otherwise, it gets put after 'after' (if not NULL) and before 'before'"]
    #[doc = " (if not NULL). If both 'after' and 'before' are given, they must be two"]
    #[doc = " neighboring tabs (the tab list is circular, so the last tab is immediately"]
    #[doc = " before the leftmost tab), otherwise the function returns NULL. If 'name' is"]
    #[doc = " NULL or a string containing illegal characters, the function returns NULL."]
    #[doc = " On all other failures the function also returns NULL. If it returns NULL,"]
    #[doc = " none of the arguments are modified, and the widget state is not altered."]
    pub fn nctabbed_add(
        nt: *mut nctabbed,
        after: *mut nctab,
        before: *mut nctab,
        tcb: tabcb,
        name: *const core::ffi::c_char,
        opaque: *mut core::ffi::c_void,
    ) -> *mut nctab;
}
extern "C" {
    #[doc = " Remove a tab 't' from 'nt'. Its neighboring tabs become neighbors to each"]
    #[doc = " other. If 't' if the selected tab, the tab after 't' becomes selected."]
    #[doc = " Likewise if 't' is the leftmost tab, the tab after 't' becomes leftmost."]
    #[doc = " If 't' is the only tab, there will no more be a selected or leftmost tab,"]
    #[doc = " until a new tab is added. Returns -1 if 't' is NULL, and 0 otherwise."]
    pub fn nctabbed_del(nt: *mut nctabbed, t: *mut nctab) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Move 't' after 'after' (if not NULL) and before 'before' (if not NULL)."]
    #[doc = " If both 'after' and 'before' are NULL, the function returns -1, otherwise"]
    #[doc = " it returns 0."]
    pub fn nctab_move(
        nt: *mut nctabbed,
        t: *mut nctab,
        after: *mut nctab,
        before: *mut nctab,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Move 't' to the right by one tab, looping around to become leftmost if needed."]
    pub fn nctab_move_right(nt: *mut nctabbed, t: *mut nctab);
}
extern "C" {
    #[doc = " Move 't' to the right by one tab, looping around to become the last tab if needed."]
    pub fn nctab_move_left(nt: *mut nctabbed, t: *mut nctab);
}
extern "C" {
    #[doc = " Rotate the tabs of 'nt' right by 'amt' tabs, or '-amt' tabs left if 'amt' is"]
    #[doc = " negative. Tabs are rotated only by changing the leftmost tab; the selected tab"]
    #[doc = " stays the same. If there are no tabs, nothing happens."]
    pub fn nctabbed_rotate(nt: *mut nctabbed, amt: core::ffi::c_int);
}
extern "C" {
    #[doc = " Select the tab after the currently selected tab, and return the newly selected"]
    #[doc = " tab. Returns NULL if there are no tabs."]
    pub fn nctabbed_next(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Select the tab before the currently selected tab, and return the newly selected"]
    #[doc = " tab. Returns NULL if there are no tabs."]
    pub fn nctabbed_prev(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Change the selected tab to be 't'. Returns the previously selected tab."]
    pub fn nctabbed_select(nt: *mut nctabbed, t: *mut nctab) -> *mut nctab;
}
extern "C" {
    #[doc = " Write the channels for tab headers, the selected tab header, and the separator"]
    #[doc = " to '*hdrchan', '*selchan', and '*sepchan' respectively."]
    pub fn nctabbed_channels(
        nt: *mut nctabbed,
        hdrchan: *mut u64,
        selchan: *mut u64,
        sepchan: *mut u64,
    );
}
extern "C" {
    #[doc = " Returns the tab separator. This is not a copy and it should not be stored."]
    #[doc = " This can be NULL, if the separator was set to NULL in ncatbbed_create() or"]
    #[doc = " nctabbed_set_separator()."]
    pub fn nctabbed_separator(nt: *mut nctabbed) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns the tab separator width, or zero if there is no separator."]
    pub fn nctabbed_separator_width(nt: *mut nctabbed) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the tab headers channel for 'nt'."]
    pub fn nctabbed_set_hdrchan(nt: *mut nctabbed, chan: u64);
}
extern "C" {
    #[doc = " Set the selected tab header channel for 'nt'."]
    pub fn nctabbed_set_selchan(nt: *mut nctabbed, chan: u64);
}
extern "C" {
    #[doc = " Set the tab separator channel for 'nt'."]
    pub fn nctabbed_set_sepchan(nt: *mut nctabbed, chan: u64);
}
extern "C" {
    #[doc = " Set the tab callback function for 't'. Returns the previous tab callback."]
    pub fn nctab_set_cb(t: *mut nctab, newcb: tabcb) -> tabcb;
}
extern "C" {
    #[doc = " Change the name of 't'. Returns -1 if 'newname' is NULL, and 0 otherwise."]
    pub fn nctab_set_name(t: *mut nctab, newname: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the user pointer of 't'. Returns the previous user pointer."]
    pub fn nctab_set_userptr(
        t: *mut nctab,
        newopaque: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Change the tab separator for 'nt'. Returns -1 if 'separator' is not NULL and"]
    #[doc = " is not a valid string, and 0 otherwise."]
    pub fn nctabbed_set_separator(
        nt: *mut nctabbed,
        separator: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncplot_options {
    #[doc = " channels for the maximum and minimum levels. linear or exponential"]
    #[doc = " interpolation will be applied across the domain between these two."]
    pub maxchannels: u64,
    pub minchannels: u64,
    #[doc = " styling used for the legend, if NCPLOT_OPTION_LABELTICKSD is set"]
    pub legendstyle: u16,
    #[doc = " number of \"pixels\" per row x column"]
    pub gridtype: ncblitter_e,
    #[doc = " independent variable can either be a contiguous range, or a finite set"]
    #[doc = " of keys. for a time range, say the previous hour sampled with second"]
    #[doc = " resolution, the independent variable would be the range [0..3600): 3600."]
    #[doc = " if rangex is 0, it is dynamically set to the number of columns."]
    pub rangex: core::ffi::c_int,
    #[doc = " optional, printed by the labels"]
    pub title: *const core::ffi::c_char,
    #[doc = " bitfield over NCPLOT_OPTION_*"]
    pub flags: u64,
}
impl Default for ncplot_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Use the provided plane 'n' for plotting according to the options 'opts'. The"]
    #[doc = " plot will make free use of the entirety of the plane. For domain"]
    #[doc = " autodiscovery, set miny == maxy == 0. ncuplot holds uint64_ts, while"]
    #[doc = " ncdplot holds doubles."]
    pub fn ncuplot_create(
        n: *mut ncplane,
        opts: *const ncplot_options,
        miny: u64,
        maxy: u64,
    ) -> *mut ncuplot;
}
extern "C" {
    pub fn ncdplot_create(
        n: *mut ncplane,
        opts: *const ncplot_options,
        miny: f64,
        maxy: f64,
    ) -> *mut ncdplot;
}
extern "C" {
    #[doc = " Return a reference to the ncplot's underlying ncplane."]
    pub fn ncuplot_plane(n: *mut ncuplot) -> *mut ncplane;
}
extern "C" {
    pub fn ncdplot_plane(n: *mut ncdplot) -> *mut ncplane;
}
extern "C" {
    #[doc = " Add to or set the value corresponding to this x. If x is beyond the current"]
    #[doc = " x window, the x window is advanced to include x, and values passing beyond"]
    #[doc = " the window are lost. The first call will place the initial window. The plot"]
    #[doc = " will be redrawn, but notcurses_render() is not called."]
    pub fn ncuplot_add_sample(n: *mut ncuplot, x: u64, y: u64) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdplot_add_sample(n: *mut ncdplot, x: u64, y: f64) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncuplot_set_sample(n: *mut ncuplot, x: u64, y: u64) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdplot_set_sample(n: *mut ncdplot, x: u64, y: f64) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncuplot_sample(n: *const ncuplot, x: u64, y: *mut u64) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdplot_sample(n: *const ncdplot, x: u64, y: *mut f64) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncuplot_destroy(n: *mut ncuplot);
}
extern "C" {
    pub fn ncdplot_destroy(n: *mut ncdplot);
}
pub type ncfdplane_callback = ::core::option::Option<
    unsafe extern "C" fn(
        n: *mut ncfdplane,
        buf: *const core::ffi::c_void,
        s: usize,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
pub type ncfdplane_done_cb = ::core::option::Option<
    unsafe extern "C" fn(
        n: *mut ncfdplane,
        fderrno: core::ffi::c_int,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[doc = " read from an fd until EOF (or beyond, if follow is set), invoking the user's"]
#[doc = " callback each time. runs in its own context. on EOF or error, the finalizer"]
#[doc = " callback will be invoked, and the user ought destroy the ncfdplane. the"]
#[doc = " data is *not* guaranteed to be nul-terminated, and may contain arbitrary"]
#[doc = " zeroes."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncfdplane_options {
    #[doc = " parameter provided to callbacks"]
    pub curry: *mut core::ffi::c_void,
    #[doc = " keep reading after hitting end? (think tail -f)"]
    pub follow: bool,
    #[doc = " bitfield over NCOPTION_FDPLANE_*"]
    pub flags: u64,
}
impl Default for ncfdplane_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Create an ncfdplane around the fd 'fd'. Consider this function to take"]
    #[doc = " ownership of the file descriptor, which will be closed in ncfdplane_destroy()."]
    pub fn ncfdplane_create(
        n: *mut ncplane,
        opts: *const ncfdplane_options,
        fd: core::ffi::c_int,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncfdplane;
}
extern "C" {
    pub fn ncfdplane_plane(n: *mut ncfdplane) -> *mut ncplane;
}
extern "C" {
    pub fn ncfdplane_destroy(n: *mut ncfdplane) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncsubproc_options {
    pub curry: *mut core::ffi::c_void,
    #[doc = " restart this many seconds after an exit (watch)"]
    pub restart_period: u64,
    #[doc = " bitfield over NCOPTION_SUBPROC_*"]
    pub flags: u64,
}
impl Default for ncsubproc_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " see exec(2). p-types use $PATH. e-type passes environment vars."]
    pub fn ncsubproc_createv(
        n: *mut ncplane,
        opts: *const ncsubproc_options,
        bin: *const core::ffi::c_char,
        arg: *const *const core::ffi::c_char,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncsubproc;
}
extern "C" {
    pub fn ncsubproc_createvp(
        n: *mut ncplane,
        opts: *const ncsubproc_options,
        bin: *const core::ffi::c_char,
        arg: *const *const core::ffi::c_char,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncsubproc;
}
extern "C" {
    pub fn ncsubproc_createvpe(
        n: *mut ncplane,
        opts: *const ncsubproc_options,
        bin: *const core::ffi::c_char,
        arg: *const *const core::ffi::c_char,
        env: *const *const core::ffi::c_char,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncsubproc;
}
extern "C" {
    pub fn ncsubproc_plane(n: *mut ncsubproc) -> *mut ncplane;
}
extern "C" {
    pub fn ncsubproc_destroy(n: *mut ncsubproc) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Draw a QR code at the current position on the plane. If there is insufficient"]
    #[doc = " room to draw the code here, or there is any other error, non-zero will be"]
    #[doc = " returned. Otherwise, the QR code \"version\" (size) is returned. The QR code"]
    #[doc = " is (version * 4 + 17) columns wide, and âŒˆversion * 4 + 17âŒ‰ rows tall (the"]
    #[doc = " properly-scaled values are written back to '*ymax' and '*xmax')."]
    pub fn ncplane_qrcode(
        n: *mut ncplane,
        ymax: *mut core::ffi::c_uint,
        xmax: *mut core::ffi::c_uint,
        data: *const core::ffi::c_void,
        len: usize,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncreader_options {
    #[doc = " channels used for input"]
    pub tchannels: u64,
    #[doc = " attributes used for input"]
    pub tattrword: u32,
    #[doc = " bitfield of NCREADER_OPTION_*"]
    pub flags: u64,
}
extern "C" {
    #[doc = " ncreaders provide freeform input in a (possibly multiline) region, supporting"]
    #[doc = " optional readline keybindings. takes ownership of 'n', destroying it on any"]
    #[doc = " error (ncreader_destroy() otherwise destroys the ncplane)."]
    pub fn ncreader_create(n: *mut ncplane, opts: *const ncreader_options) -> *mut ncreader;
}
extern "C" {
    #[doc = " empty the ncreader of any user input, and home the cursor."]
    pub fn ncreader_clear(n: *mut ncreader) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncreader_plane(n: *mut ncreader) -> *mut ncplane;
}
extern "C" {
    #[doc = " Offer the input to the ncreader. If it's relevant, this function returns"]
    #[doc = " true, and the input ought not be processed further. Almost all inputs"]
    #[doc = " are relevant to an ncreader, save synthesized ones."]
    pub fn ncreader_offer_input(n: *mut ncreader, ni: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Atttempt to move in the specified direction. Returns 0 if a move was"]
    #[doc = " successfully executed, -1 otherwise. Scrolling is taken into account."]
    pub fn ncreader_move_left(n: *mut ncreader) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncreader_move_right(n: *mut ncreader) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncreader_move_up(n: *mut ncreader) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncreader_move_down(n: *mut ncreader) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Destructively write the provided EGC to the current cursor location. Move"]
    #[doc = " the cursor as necessary, scrolling if applicable."]
    pub fn ncreader_write_egc(n: *mut ncreader, egc: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " return a heap-allocated copy of the current (UTF-8) contents."]
    pub fn ncreader_contents(n: *const ncreader) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " destroy the reader and its bound plane. if 'contents' is not NULL, the"]
    #[doc = " UTF-8 input will be heap-duplicated and written to 'contents'."]
    pub fn ncreader_destroy(n: *mut ncreader, contents: *mut *mut core::ffi::c_char);
}
extern "C" {
    #[doc = " Returns a heap-allocated copy of the user name under which we are running."]
    pub fn notcurses_accountname() -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns a heap-allocated copy of the local host name."]
    pub fn notcurses_hostname() -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns a heap-allocated copy of human-readable OS name and version."]
    pub fn notcurses_osversion() -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Dump selected Notcurses state to the supplied 'debugfp'. Output is freeform,"]
    #[doc = " newline-delimited, and subject to change. It includes geometry of all"]
    #[doc = " planes, from all piles. No line has more than 80 columns' worth of output."]
    pub fn notcurses_debug(nc: *const notcurses, debugfp: *mut FILE);
}
extern "C" {
    #[doc = " Initialize a direct-mode Notcurses context on the connected terminal at 'fp'."]
    #[doc = " 'fp' must be a tty. You'll usually want stdout. Direct mode supports a"]
    #[doc = " limited subset of Notcurses routines which directly affect 'fp', and neither"]
    #[doc = " supports nor requires notcurses_render(). This can be used to add color and"]
    #[doc = " styling to text in the standard output paradigm. 'flags' is a bitmask over"]
    #[doc = " NCDIRECT_OPTION_*."]
    #[doc = " Returns NULL on error, including any failure initializing terminfo."]
    pub fn ncdirect_init(
        termtype: *const core::ffi::c_char,
        fp: *mut FILE,
        flags: u64,
    ) -> *mut ncdirect;
}
extern "C" {
    #[doc = " The same as ncdirect_init(), but without any multimedia functionality,"]
    #[doc = " allowing for a svelter binary. Link with notcurses-core if this is used."]
    pub fn ncdirect_core_init(
        termtype: *const core::ffi::c_char,
        fp: *mut FILE,
        flags: u64,
    ) -> *mut ncdirect;
}
extern "C" {
    #[doc = " Read a (heap-allocated) newline-delimited chunk of text, after printing the"]
    #[doc = " prompt. The newline itself, if present, is included. Returns NULL on error."]
    pub fn ncdirect_readline(
        nc: *mut ncdirect,
        prompt: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Direct mode. This API can be used to colorize and stylize output generated"]
    #[doc = " outside of notcurses, without ever calling notcurses_render(). These should"]
    #[doc = " not be intermixed with standard Notcurses rendering."]
    pub fn ncdirect_set_fg_rgb(nc: *mut ncdirect, rgb: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_set_bg_rgb(nc: *mut ncdirect, rgb: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_set_fg_palindex(nc: *mut ncdirect, pidx: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_set_bg_palindex(nc: *mut ncdirect, pidx: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Returns the number of simultaneous colors claimed to be supported, or 1 if"]
    #[doc = " there is no color support. Note that several terminal emulators advertise"]
    #[doc = " more colors than they actually support, downsampling internally."]
    pub fn ncdirect_palette_size(nc: *const ncdirect) -> core::ffi::c_uint;
}
extern "C" {
    #[doc = " Output the string |utf8| according to the channels |channels|. Note that"]
    #[doc = " ncdirect_putstr() does not explicitly flush output buffers, so it will not"]
    #[doc = " necessarily be immediately visible. Returns EOF on error."]
    pub fn ncdirect_putstr(
        nc: *mut ncdirect,
        channels: u64,
        utf8: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Output a single EGC (this might be several characters) from |utf8|,"]
    #[doc = " according to the channels |channels|. On success, the number of columns"]
    #[doc = " thought to have been used is returned, and if |sbytes| is not NULL,"]
    #[doc = " the number of bytes consumed will be written there."]
    pub fn ncdirect_putegc(
        nc: *mut ncdirect,
        channels: u64,
        utf8: *const core::ffi::c_char,
        sbytes: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Formatted printing (plus alignment relative to the terminal). Returns the"]
    #[doc = " number of columns printed on success."]
    pub fn ncdirect_printf_aligned(
        n: *mut ncdirect,
        y: core::ffi::c_int,
        align: ncalign_e,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Force a flush. Returns 0 on success, -1 on failure."]
    pub fn ncdirect_flush(nc: *const ncdirect) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_set_fg_default(nc: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_set_bg_default(nc: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the current number of columns/rows."]
    pub fn ncdirect_dim_x(nc: *mut ncdirect) -> core::ffi::c_uint;
}
extern "C" {
    pub fn ncdirect_dim_y(nc: *mut ncdirect) -> core::ffi::c_uint;
}
extern "C" {
    #[doc = " Returns a 16-bit bitmask of supported curses-style attributes"]
    #[doc = " (NCSTYLE_UNDERLINE, NCSTYLE_BOLD, etc.) The attribute is only"]
    #[doc = " indicated as supported if the terminal can support it together with color."]
    #[doc = " For more information, see the \"ncv\" capability in terminfo(5)."]
    pub fn ncdirect_supported_styles(nc: *const ncdirect) -> u16;
}
extern "C" {
    #[doc = " ncplane_styles_*() analogues"]
    pub fn ncdirect_set_styles(n: *mut ncdirect, stylebits: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_on_styles(n: *mut ncdirect, stylebits: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_off_styles(n: *mut ncdirect, stylebits: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_styles(n: *const ncdirect) -> u16;
}
extern "C" {
    #[doc = " Move the cursor in direct mode. -1 to retain current location on that axis."]
    pub fn ncdirect_cursor_move_yx(
        n: *mut ncdirect,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_enable(nc: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_disable(nc: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_up(nc: *mut ncdirect, num: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_left(nc: *mut ncdirect, num: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_right(nc: *mut ncdirect, num: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_down(nc: *mut ncdirect, num: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the cursor position, when supported. This requires writing to the"]
    #[doc = " terminal, and then reading from it. If the terminal doesn't reply, or"]
    #[doc = " doesn't reply in a way we understand, the results might be deleterious."]
    pub fn ncdirect_cursor_yx(
        n: *mut ncdirect,
        y: *mut core::ffi::c_uint,
        x: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Push or pop the cursor location to the terminal's stack. The depth of this"]
    #[doc = " stack, and indeed its existence, is terminal-dependent."]
    pub fn ncdirect_cursor_push(n: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_pop(n: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Clear the screen."]
    pub fn ncdirect_clear(nc: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_capabilities(n: *const ncdirect) -> *const nccapabilities;
}
extern "C" {
    #[doc = " Draw horizontal/vertical lines using the specified channels, interpolating"]
    #[doc = " between them as we go. The EGC may not use more than one column. For a"]
    #[doc = " horizontal line, |len| cannot exceed the screen width minus the cursor's"]
    #[doc = " offset. For a vertical line, it may be as long as you'd like; the screen"]
    #[doc = " will scroll as necessary. All lines start at the current cursor position."]
    pub fn ncdirect_hline_interp(
        n: *mut ncdirect,
        egc: *const core::ffi::c_char,
        len: core::ffi::c_uint,
        h1: u64,
        h2: u64,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_vline_interp(
        n: *mut ncdirect,
        egc: *const core::ffi::c_char,
        len: core::ffi::c_uint,
        h1: u64,
        h2: u64,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Draw a box with its upper-left corner at the current cursor position, having"]
    #[doc = " dimensions |ylen|x|xlen|. See ncplane_box() for more information. The"]
    #[doc = " minimum box size is 2x2, and it cannot be drawn off-screen. |wchars| is an"]
    #[doc = " array of 6 wide characters: UL, UR, LL, LR, HL, VL."]
    pub fn ncdirect_box(
        n: *mut ncdirect,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
        wchars: *const wchar_t,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
        ctlword: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " ncdirect_box() with the rounded box-drawing characters"]
    pub fn ncdirect_rounded_box(
        n: *mut ncdirect,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
        ctlword: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " ncdirect_box() with the double box-drawing characters"]
    pub fn ncdirect_double_box(
        n: *mut ncdirect,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
        ctlword: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Provide a NULL 'ts' to block at length, a 'ts' of 0 for non-blocking"]
    #[doc = " operation, and otherwise an absolute deadline in terms of CLOCK_MONOTONIC."]
    #[doc = " Returns a single Unicode code point, a synthesized special key constant,"]
    #[doc = " or (uint32_t)-1 on error. Returns 0 on a timeout. If an event is processed,"]
    #[doc = " the return value is the 'id' field from that event. 'ni' may be NULL."]
    pub fn ncdirect_get(n: *mut ncdirect, absdl: *const timespec, ni: *mut ncinput) -> u32;
}
extern "C" {
    #[doc = " Get a file descriptor suitable for input event poll()ing. When this"]
    #[doc = " descriptor becomes available, you can call ncdirect_get_nblock(),"]
    #[doc = " and input ought be ready. This file descriptor is *not* necessarily"]
    #[doc = " the file descriptor associated with stdin (but it might be!)."]
    pub fn ncdirect_inputready_fd(n: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Release 'nc' and any associated resources. 0 on success, non-0 on failure."]
    pub fn ncdirect_stop(nc: *mut ncdirect) -> core::ffi::c_int;
}
pub type ncdirectv = ncplane;
pub type ncdirectf = ncvisual;
extern "C" {
    #[doc = " Display an image using the specified blitter and scaling. The image may"]
    #[doc = " be arbitrarily many rows -- the output will scroll -- but will only occupy"]
    #[doc = " the column of the cursor, and those to the right. The render/raster process"]
    #[doc = " can be split by using ncdirect_render_frame() and ncdirect_raster_frame()."]
    pub fn ncdirect_render_image(
        n: *mut ncdirect,
        filename: *const core::ffi::c_char,
        align: ncalign_e,
        blitter: ncblitter_e,
        scale: ncscale_e,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Render an image using the specified blitter and scaling, but do not write"]
    #[doc = " the result. The image may be arbitrarily many rows -- the output will scroll"]
    #[doc = " -- but will only occupy the column of the cursor, and those to the right."]
    #[doc = " To actually write (and free) this, invoke ncdirect_raster_frame(). 'maxx'"]
    #[doc = " and 'maxy' (cell geometry, *not* pixel), if greater than 0, are used for"]
    #[doc = " scaling; the terminal's geometry is otherwise used."]
    pub fn ncdirect_render_frame(
        n: *mut ncdirect,
        filename: *const core::ffi::c_char,
        blitter: ncblitter_e,
        scale: ncscale_e,
        maxy: core::ffi::c_int,
        maxx: core::ffi::c_int,
    ) -> *mut ncdirectv;
}
extern "C" {
    #[doc = " Takes the result of ncdirect_render_frame() and writes it to the output,"]
    #[doc = " freeing it on all paths."]
    pub fn ncdirect_raster_frame(
        n: *mut ncdirect,
        ncdv: *mut ncdirectv,
        align: ncalign_e,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Load media from disk, but do not yet render it (presumably because you want"]
    #[doc = " to get its geometry via ncdirectf_geom(), or to use the same file with"]
    #[doc = " ncdirect_render_loaded_frame() multiple times). You must destroy the result"]
    #[doc = " with ncdirectf_free();"]
    pub fn ncdirectf_from_file(
        n: *mut ncdirect,
        filename: *const core::ffi::c_char,
    ) -> *mut ncdirectf;
}
extern "C" {
    #[doc = " Free a ncdirectf returned from ncdirectf_from_file()."]
    pub fn ncdirectf_free(frame: *mut ncdirectf);
}
extern "C" {
    #[doc = " Same as ncdirect_render_frame(), except 'frame' must already have been"]
    #[doc = " loaded. A loaded frame may be rendered in different ways before it is"]
    #[doc = " destroyed."]
    pub fn ncdirectf_render(
        n: *mut ncdirect,
        frame: *mut ncdirectf,
        vopts: *const ncvisual_options,
    ) -> *mut ncdirectv;
}
extern "C" {
    #[doc = " Having loaded the frame 'frame', get the geometry of a potential render."]
    pub fn ncdirectf_geom(
        n: *mut ncdirect,
        frame: *mut ncdirectf,
        vopts: *const ncvisual_options,
        geom: *mut ncvgeom,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Load successive frames from a file, invoking 'streamer' on each."]
    pub fn ncdirect_stream(
        n: *mut ncdirect,
        filename: *const core::ffi::c_char,
        streamer: ncstreamcb,
        vopts: *mut ncvisual_options,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Capabilites"]
    pub fn ncdirect_detected_terminal(n: *const ncdirect) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Is our encoding UTF-8? Requires LANG being set to a UTF8 locale."]
    pub fn ncdirect_canutf8(n: *const ncdirect) -> bool;
}
extern "C" {
    #[doc = " Can we blit pixel-accurate bitmaps?"]
    pub fn ncdirect_check_pixel_support(n: *const ncdirect) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Is there support for acquiring the cursor's current position? Requires the"]
    #[doc = " u7 terminfo capability, and that we are connected to an actual terminal."]
    pub fn ncdirect_canget_cursor(nc: *const ncdirect) -> bool;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: core::ffi::c_uint,
    pub fp_offset: core::ffi::c_uint,
    pub overflow_arg_area: *mut core::ffi::c_void,
    pub reg_save_area: *mut core::ffi::c_void,
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
