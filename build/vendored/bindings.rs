/* automatically generated by rust-bindgen 0.66.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::core::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::core::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::core::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::core::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::core::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub const _TIME_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _STDC_PREDEF_H: u32 = 1;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const _STRUCT_TIMESPEC: u32 = 1;
pub const _CTYPE_H: u32 = 1;
pub const _WCHAR_H: u32 = 1;
pub const __wint_t_defined: u32 = 1;
pub const _WINT_T: u32 = 1;
pub const __mbstate_t_defined: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const _____fpos_t_defined: u32 = 1;
pub const _____fpos64_t_defined: u32 = 1;
pub const __struct_FILE_defined: u32 = 1;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const EOF: i32 = -1;
pub const P_tmpdir: &[u8; 5] = b"/tmp\0";
pub const FILENAME_MAX: u32 = 4096;
pub const FOPEN_MAX: u32 = 16;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const _STDINT_H: u32 = 1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const _STDLIB_H: u32 = 1;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _STRING_H: u32 = 1;
pub const _NSIG: u32 = 65;
pub const __sig_atomic_t_defined: u32 = 1;
pub const __sigset_t_defined: u32 = 1;
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const _XOPEN_LIM_H: u32 = 1;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _NETINET_IN_H: u32 = 1;
pub const _SYS_SOCKET_H: u32 = 1;
pub const __iovec_defined: u32 = 1;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const _SS_SIZE: u32 = 128;
pub const _ENDIAN_H: u32 = 1;
pub const _BYTESWAP_H: u32 = 1;
pub const PRETERUNICODEBASE: u32 = 1115000;
pub const NCKEY_TAB: u32 = 9;
pub const NCKEY_ESC: u32 = 27;
pub const NCKEY_SPACE: u32 = 32;
pub const NCKEY_MOD_SHIFT: u32 = 1;
pub const NCKEY_MOD_ALT: u32 = 2;
pub const NCKEY_MOD_CTRL: u32 = 4;
pub const NCKEY_MOD_SUPER: u32 = 8;
pub const NCKEY_MOD_HYPER: u32 = 16;
pub const NCKEY_MOD_META: u32 = 32;
pub const NCKEY_MOD_CAPSLOCK: u32 = 64;
pub const NCKEY_MOD_NUMLOCK: u32 = 128;
pub const NCBOXLIGHTW: &[u8; 19] =
    b"\xE2\x94\x8C\xE2\x94\x90\xE2\x94\x94\xE2\x94\x98\xE2\x94\x80\xE2\x94\x82\0";
pub const NCBOXHEAVYW: &[u8; 19] =
    b"\xE2\x94\x8F\xE2\x94\x93\xE2\x94\x97\xE2\x94\x9B\xE2\x94\x81\xE2\x94\x83\0";
pub const NCBOXROUNDW: &[u8; 19] =
    b"\xE2\x95\xAD\xE2\x95\xAE\xE2\x95\xB0\xE2\x95\xAF\xE2\x94\x80\xE2\x94\x82\0";
pub const NCBOXDOUBLEW: &[u8; 19] =
    b"\xE2\x95\x94\xE2\x95\x97\xE2\x95\x9A\xE2\x95\x9D\xE2\x95\x90\xE2\x95\x91\0";
pub const NCBOXASCIIW: &[u8; 7] = b"/\\\\/-|\0";
pub const NCBOXOUTERW : & [u8 ; 32] = b"\xF0\x9F\xAD\xBD\xF0\x9F\xAD\xBE\xF0\x9F\xAD\xBC\xF0\x9F\xAD\xBF\xE2\x96\x81\xF0\x9F\xAD\xB5\xF0\x9F\xAD\xB6\xF0\x9F\xAD\xB0\0" ;
pub const NCWHITESQUARESW: &[u8; 13] = b"\xE2\x97\xB2\xE2\x97\xB1\xE2\x97\xB3\xE2\x97\xB0\0";
pub const NCWHITECIRCLESW: &[u8; 13] = b"\xE2\x97\xB6\xE2\x97\xB5\xE2\x97\xB7\xE2\x97\xB4\0";
pub const NCCIRCULARARCSW: &[u8; 13] = b"\xE2\x97\x9C\xE2\x97\x9D\xE2\x97\x9F\xE2\x97\x9E\0";
pub const NCWHITETRIANGLESW: &[u8; 13] = b"\xE2\x97\xBF\xE2\x97\xBA\xE2\x97\xB9\xE2\x97\xB8\0";
pub const NCBLACKTRIANGLESW: &[u8; 13] = b"\xE2\x97\xA2\xE2\x97\xA3\xE2\x97\xA5\xE2\x97\xA4\0";
pub const NCSHADETRIANGLESW: &[u8; 17] =
    b"\xF0\x9F\xAE\x9E\xF0\x9F\xAE\x9F\xF0\x9F\xAE\x9D\xF0\x9F\xAE\x9C\0";
pub const NCBLACKARROWHEADSW: &[u8; 13] = b"\xE2\xAE\x9D\xE2\xAE\x9F\xE2\xAE\x9C\xE2\xAE\x9E\0";
pub const NCLIGHTARROWHEADSW: &[u8; 13] = b"\xE2\xAE\x99\xE2\xAE\x9B\xE2\xAE\x98\xE2\xAE\x9A\0";
pub const NCARROWDOUBLEW: &[u8; 13] = b"\xE2\xAE\x85\xE2\xAE\x87\xE2\xAE\x84\xE2\xAE\x86\0";
pub const NCARROWDASHEDW: &[u8; 13] = b"\xE2\xAD\xAB\xE2\xAD\xAD\xE2\xAD\xAA\xE2\xAD\xAC\0";
pub const NCARROWCIRCLEDW: &[u8; 13] = b"\xE2\xAE\x89\xE2\xAE\x8B\xE2\xAE\x88\xE2\xAE\x8A\0";
pub const NCARROWANTICLOCKW: &[u8; 13] = b"\xE2\xAE\x8F\xE2\xAE\x8D\xE2\xAE\x8E\xE2\xAE\x8C\0";
pub const NCBOXDRAWW: &[u8; 13] = b"\xE2\x95\xB5\xE2\x95\xB7\xE2\x95\xB4\xE2\x95\xB6\0";
pub const NCBOXDRAWHEAVYW: &[u8; 13] = b"\xE2\x95\xB9\xE2\x95\xBB\xE2\x95\xB8\xE2\x95\xBA\0";
pub const NCARROWW : & [u8 ; 25] = b"\xE2\xAD\xA1\xE2\xAD\xA3\xE2\xAD\xA0\xE2\xAD\xA2\xE2\xAD\xA7\xE2\xAD\xA9\xE2\xAD\xA6\xE2\xAD\xA8\0" ;
pub const NCDIAGONALSW : & [u8 ; 33] = b"\xF0\x9F\xAE\xA3\xF0\x9F\xAE\xA0\xF0\x9F\xAE\xA1\xF0\x9F\xAE\xA2\xF0\x9F\xAE\xA4\xF0\x9F\xAE\xA5\xF0\x9F\xAE\xA6\xF0\x9F\xAE\xA7\0" ;
pub const NCDIGITSSUPERW : & [u8 ; 28] = b"\xE2\x81\xB0\xC2\xB9\xC2\xB2\xC2\xB3\xE2\x81\xB4\xE2\x81\xB5\xE2\x81\xB6\xE2\x81\xB7\xE2\x81\xB8\xE2\x81\xB9\0" ;
pub const NCDIGITSSUBW : & [u8 ; 31] = b"\xE2\x82\x80\xE2\x82\x81\xE2\x82\x82\xE2\x82\x83\xE2\x82\x84\xE2\x82\x85\xE2\x82\x86\xE2\x82\x87\xE2\x82\x88\xE2\x82\x89\0" ;
pub const NCASTERISKS5 : & [u8 ; 25] = b"\xF0\x9F\x9E\xAF\xF0\x9F\x9E\xB0\xF0\x9F\x9E\xB1\xF0\x9F\x9E\xB2\xF0\x9F\x9E\xB3\xF0\x9F\x9E\xB4\0" ;
pub const NCASTERISKS6 : & [u8 ; 25] = b"\xF0\x9F\x9E\xB5\xF0\x9F\x9E\xB6\xF0\x9F\x9E\xB7\xF0\x9F\x9E\xB8\xF0\x9F\x9E\xB9\xF0\x9F\x9E\xBA\0" ;
pub const NCASTERISKS8 : & [u8 ; 24] = b"\xF0\x9F\x9E\xBB\xF0\x9F\x9E\xBC\xE2\x9C\xB3\xF0\x9F\x9E\xBD\xF0\x9F\x9E\xBE\xF0\x9F\x9E\xBF\0" ;
pub const NCANGLESBR : & [u8 ; 45] = b"\xF0\x9F\xAD\x81\xF0\x9F\xAD\x82\xF0\x9F\xAD\x83\xF0\x9F\xAD\x84\xF0\x9F\xAD\x85\xF0\x9F\xAD\x86\xF0\x9F\xAD\x87\xF0\x9F\xAD\x88\xF0\x9F\xAD\x89\xF0\x9F\xAD\x8A\xF0\x9F\xAD\x8B\0" ;
pub const NCANGLESTR : & [u8 ; 45] = b"\xF0\x9F\xAD\x92\xF0\x9F\xAD\x93\xF0\x9F\xAD\x94\xF0\x9F\xAD\x95\xF0\x9F\xAD\x96\xF0\x9F\xAD\xA7\xF0\x9F\xAD\xA2\xF0\x9F\xAD\xA3\xF0\x9F\xAD\xA4\xF0\x9F\xAD\xA5\xF0\x9F\xAD\xA6\0" ;
pub const NCANGLESBL : & [u8 ; 45] = b"\xF0\x9F\xAD\x8C\xF0\x9F\xAD\x8D\xF0\x9F\xAD\x8E\xF0\x9F\xAD\x8F\xF0\x9F\xAD\x90\xF0\x9F\xAD\x91\xF0\x9F\xAC\xBC\xF0\x9F\xAC\xBD\xF0\x9F\xAC\xBE\xF0\x9F\xAC\xBF\xF0\x9F\xAD\x80\0" ;
pub const NCANGLESTL : & [u8 ; 45] = b"\xF0\x9F\xAD\x9D\xF0\x9F\xAD\x9E\xF0\x9F\xAD\x9F\xF0\x9F\xAD\xA0\xF0\x9F\xAD\xA1\xF0\x9F\xAD\x9C\xF0\x9F\xAD\x97\xF0\x9F\xAD\x98\xF0\x9F\xAD\x99\xF0\x9F\xAD\x9A\xF0\x9F\xAD\x9B\0" ;
pub const NCEIGHTHSB : & [u8 ; 26] = b" \xE2\x96\x81\xE2\x96\x82\xE2\x96\x83\xE2\x96\x84\xE2\x96\x85\xE2\x96\x86\xE2\x96\x87\xE2\x96\x88\0" ;
pub const NCEIGHTHST : & [u8 ; 31] = b" \xE2\x96\x94\xF0\x9F\xAE\x82\xF0\x9F\xAE\x83\xE2\x96\x80\xF0\x9F\xAE\x84\xF0\x9F\xAE\x85\xF0\x9F\xAE\x86\xE2\x96\x88\0" ;
pub const NCEIGHTHSL : & [u8 ; 25] = b"\xE2\x96\x8F\xE2\x96\x8E\xE2\x96\x8D\xE2\x96\x8C\xE2\x96\x8B\xE2\x96\x8A\xE2\x96\x89\xE2\x96\x88\0" ;
pub const NCEIGHTHSR : & [u8 ; 30] = b"\xE2\x96\x95\xF0\x9F\xAE\x87\xF0\x9F\xAE\x88\xE2\x96\x90\xF0\x9F\xAE\x89\xF0\x9F\xAE\x8A\xF0\x9F\xAE\x8B\xE2\x96\x88\0" ;
pub const NCHALFBLOCKS: &[u8; 11] = b" \xE2\x96\x80\xE2\x96\x84\xE2\x96\x88\0";
pub const NCQUADBLOCKS : & [u8 ; 47] = b" \xE2\x96\x98\xE2\x96\x9D\xE2\x96\x80\xE2\x96\x96\xE2\x96\x8C\xE2\x96\x9E\xE2\x96\x9B\xE2\x96\x97\xE2\x96\x9A\xE2\x96\x90\xE2\x96\x9C\xE2\x96\x84\xE2\x96\x99\xE2\x96\x9F\xE2\x96\x88\0" ;
pub const NCSEXBLOCKS : & [u8 ; 247] = b" \xF0\x9F\xAC\x80\xF0\x9F\xAC\x81\xF0\x9F\xAC\x82\xF0\x9F\xAC\x83\xF0\x9F\xAC\x84\xF0\x9F\xAC\x85\xF0\x9F\xAC\x86\xF0\x9F\xAC\x87\xF0\x9F\xAC\x88\xF0\x9F\xAC\x8A\xF0\x9F\xAC\x8B\xF0\x9F\xAC\x8C\xF0\x9F\xAC\x8D\xF0\x9F\xAC\x8E\xF0\x9F\xAC\x8F\xF0\x9F\xAC\x90\xF0\x9F\xAC\x91\xF0\x9F\xAC\x92\xF0\x9F\xAC\x93\xE2\x96\x8C\xF0\x9F\xAC\x94\xF0\x9F\xAC\x95\xF0\x9F\xAC\x96\xF0\x9F\xAC\x97\xF0\x9F\xAC\x98\xF0\x9F\xAC\x99\xF0\x9F\xAC\x9A\xF0\x9F\xAC\x9B\xF0\x9F\xAC\x9C\xF0\x9F\xAC\x9D\xF0\x9F\xAC\x9E\xF0\x9F\xAC\x9F\xF0\x9F\xAC\xA0\xF0\x9F\xAC\xA1\xF0\x9F\xAC\xA2\xF0\x9F\xAC\xA3\xF0\x9F\xAC\xA4\xF0\x9F\xAC\xA5\xF0\x9F\xAC\xA6\xF0\x9F\xAC\xA7\xE2\x96\x90\xF0\x9F\xAC\xA8\xF0\x9F\xAC\xA9\xF0\x9F\xAC\xAA\xF0\x9F\xAC\xAB\xF0\x9F\xAC\xAC\xF0\x9F\xAC\xAD\xF0\x9F\xAC\xAE\xF0\x9F\xAC\xAF\xF0\x9F\xAC\xB0\xF0\x9F\xAC\xB1\xF0\x9F\xAC\xB2\xF0\x9F\xAC\xB3\xF0\x9F\xAC\xB4\xF0\x9F\xAC\xB5\xF0\x9F\xAC\xB6\xF0\x9F\xAC\xB7\xF0\x9F\xAC\xB8\xF0\x9F\xAC\xB9\xF0\x9F\xAC\xBA\xF0\x9F\xAC\xBB\xE2\x96\x88\0" ;
pub const NCBRAILLEEGCS : & [u8 ; 769] = b"\xE2\xA0\x80\xE2\xA0\x81\xE2\xA0\x88\xE2\xA0\x89\xE2\xA0\x82\xE2\xA0\x83\xE2\xA0\x8A\xE2\xA0\x8B\xE2\xA0\x90\xE2\xA0\x91\xE2\xA0\x98\xE2\xA0\x99\xE2\xA0\x92\xE2\xA0\x93\xE2\xA0\x9A\xE2\xA0\x9B\xE2\xA0\x84\xE2\xA0\x85\xE2\xA0\x8C\xE2\xA0\x8D\xE2\xA0\x86\xE2\xA0\x87\xE2\xA0\x8E\xE2\xA0\x8F\xE2\xA0\x94\xE2\xA0\x95\xE2\xA0\x9C\xE2\xA0\x9D\xE2\xA0\x96\xE2\xA0\x97\xE2\xA0\x9E\xE2\xA0\x9F\xE2\xA0\xA0\xE2\xA0\xA1\xE2\xA0\xA8\xE2\xA0\xA9\xE2\xA0\xA2\xE2\xA0\xA3\xE2\xA0\xAA\xE2\xA0\xAB\xE2\xA0\xB0\xE2\xA0\xB1\xE2\xA0\xB8\xE2\xA0\xB9\xE2\xA0\xB2\xE2\xA0\xB3\xE2\xA0\xBA\xE2\xA0\xBB\xE2\xA0\xA4\xE2\xA0\xA5\xE2\xA0\xAC\xE2\xA0\xAD\xE2\xA0\xA6\xE2\xA0\xA7\xE2\xA0\xAE\xE2\xA0\xAF\xE2\xA0\xB4\xE2\xA0\xB5\xE2\xA0\xBC\xE2\xA0\xBD\xE2\xA0\xB6\xE2\xA0\xB7\xE2\xA0\xBE\xE2\xA0\xBF\xE2\xA1\x80\xE2\xA1\x81\xE2\xA1\x88\xE2\xA1\x89\xE2\xA1\x82\xE2\xA1\x83\xE2\xA1\x8A\xE2\xA1\x8B\xE2\xA1\x90\xE2\xA1\x91\xE2\xA1\x98\xE2\xA1\x99\xE2\xA1\x92\xE2\xA1\x93\xE2\xA1\x9A\xE2\xA1\x9B\xE2\xA1\x84\xE2\xA1\x85\xE2\xA1\x8C\xE2\xA1\x8D\xE2\xA1\x86\xE2\xA1\x87\xE2\xA1\x8E\xE2\xA1\x8F\xE2\xA1\x94\xE2\xA1\x95\xE2\xA1\x9C\xE2\xA1\x9D\xE2\xA1\x96\xE2\xA1\x97\xE2\xA1\x9E\xE2\xA1\x9F\xE2\xA1\xA0\xE2\xA1\xA1\xE2\xA1\xA8\xE2\xA1\xA9\xE2\xA1\xA2\xE2\xA1\xA3\xE2\xA1\xAA\xE2\xA1\xAB\xE2\xA1\xB0\xE2\xA1\xB1\xE2\xA1\xB8\xE2\xA1\xB9\xE2\xA1\xB2\xE2\xA1\xB3\xE2\xA1\xBA\xE2\xA1\xBB\xE2\xA1\xA4\xE2\xA1\xA5\xE2\xA1\xAC\xE2\xA1\xAD\xE2\xA1\xA6\xE2\xA1\xA7\xE2\xA1\xAE\xE2\xA1\xAF\xE2\xA1\xB4\xE2\xA1\xB5\xE2\xA1\xBC\xE2\xA1\xBD\xE2\xA1\xB6\xE2\xA1\xB7\xE2\xA1\xBE\xE2\xA1\xBF\xE2\xA2\x80\xE2\xA2\x81\xE2\xA2\x88\xE2\xA2\x89\xE2\xA2\x82\xE2\xA2\x83\xE2\xA2\x8A\xE2\xA2\x8B\xE2\xA2\x90\xE2\xA2\x91\xE2\xA2\x98\xE2\xA2\x99\xE2\xA2\x92\xE2\xA2\x93\xE2\xA2\x9A\xE2\xA2\x9B\xE2\xA2\x84\xE2\xA2\x85\xE2\xA2\x8C\xE2\xA2\x8D\xE2\xA2\x86\xE2\xA2\x87\xE2\xA2\x8E\xE2\xA2\x8F\xE2\xA2\x94\xE2\xA2\x95\xE2\xA2\x9C\xE2\xA2\x9D\xE2\xA2\x96\xE2\xA2\x97\xE2\xA2\x9E\xE2\xA2\x9F\xE2\xA2\xA0\xE2\xA2\xA1\xE2\xA2\xA8\xE2\xA2\xA9\xE2\xA2\xA2\xE2\xA2\xA3\xE2\xA2\xAA\xE2\xA2\xAB\xE2\xA2\xB0\xE2\xA2\xB1\xE2\xA2\xB8\xE2\xA2\xB9\xE2\xA2\xB2\xE2\xA2\xB3\xE2\xA2\xBA\xE2\xA2\xBB\xE2\xA2\xA4\xE2\xA2\xA5\xE2\xA2\xAC\xE2\xA2\xAD\xE2\xA2\xA6\xE2\xA2\xA7\xE2\xA2\xAE\xE2\xA2\xAF\xE2\xA2\xB4\xE2\xA2\xB5\xE2\xA2\xBC\xE2\xA2\xBD\xE2\xA2\xB6\xE2\xA2\xB7\xE2\xA2\xBE\xE2\xA2\xBF\xE2\xA3\x80\xE2\xA3\x81\xE2\xA3\x88\xE2\xA3\x89\xE2\xA3\x82\xE2\xA3\x83\xE2\xA3\x8A\xE2\xA3\x8B\xE2\xA3\x90\xE2\xA3\x91\xE2\xA3\x98\xE2\xA3\x99\xE2\xA3\x92\xE2\xA3\x93\xE2\xA3\x9A\xE2\xA3\x9B\xE2\xA3\x84\xE2\xA3\x85\xE2\xA3\x8C\xE2\xA3\x8D\xE2\xA3\x86\xE2\xA3\x87\xE2\xA3\x8E\xE2\xA3\x8F\xE2\xA3\x94\xE2\xA3\x95\xE2\xA3\x9C\xE2\xA3\x9D\xE2\xA3\x96\xE2\xA3\x97\xE2\xA3\x9E\xE2\xA3\x9F\xE2\xA3\xA0\xE2\xA3\xA1\xE2\xA3\xA8\xE2\xA3\xA9\xE2\xA3\xA2\xE2\xA3\xA3\xE2\xA3\xAA\xE2\xA3\xAB\xE2\xA3\xB0\xE2\xA3\xB1\xE2\xA3\xB8\xE2\xA3\xB9\xE2\xA3\xB2\xE2\xA3\xB3\xE2\xA3\xBA\xE2\xA3\xBB\xE2\xA3\xA4\xE2\xA3\xA5\xE2\xA3\xAC\xE2\xA3\xAD\xE2\xA3\xA6\xE2\xA3\xA7\xE2\xA3\xAE\xE2\xA3\xAF\xE2\xA3\xB4\xE2\xA3\xB5\xE2\xA3\xBC\xE2\xA3\xBD\xE2\xA3\xB6\xE2\xA3\xB7\xE2\xA3\xBE\xE2\xA3\xBF\0" ;
pub const NCSEGDIGITS : & [u8 ; 41] = b"\xF0\x9F\xAF\xB0\xF0\x9F\xAF\xB1\xF0\x9F\xAF\xB2\xF0\x9F\xAF\xB3\xF0\x9F\xAF\xB4\xF0\x9F\xAF\xB5\xF0\x9F\xAF\xB6\xF0\x9F\xAF\xB7\xF0\x9F\xAF\xB8\xF0\x9F\xAF\xB9\0" ;
pub const NCSUITSBLACK: &[u8; 13] = b"\xE2\x99\xA0\xE2\x99\xA3\xE2\x99\xA5\xE2\x99\xA6\0";
pub const NCSUITSWHITE: &[u8; 13] = b"\xE2\x99\xA1\xE2\x99\xA2\xE2\x99\xA4\xE2\x99\xA7\0";
pub const NCCHESSBLACK: &[u8; 19] =
    b"\xE2\x99\x9F\xE2\x99\x9C\xE2\x99\x9E\xE2\x99\x9D\xE2\x99\x9B\xE2\x99\x9A\0";
pub const NCCHESSWHITE: &[u8; 19] =
    b"\xE2\x99\x99\xE2\x99\x96\xE2\x99\x98\xE2\x99\x97\xE2\x99\x95\xE2\x99\x94\0";
pub const NCDICE: &[u8; 19] =
    b"\xE2\x9A\x80\xE2\x9A\x81\xE2\x9A\x82\xE2\x9A\x83\xE2\x9A\x84\xE2\x9A\x85\0";
pub const NCMUSICSYM: &[u8; 22] =
    b"\xE2\x99\xA9\xE2\x99\xAA\xE2\x99\xAB\xE2\x99\xAC\xE2\x99\xAD\xE2\x99\xAE\xE2\x99\xAF\0";
pub const NCBOXLIGHT: &[u8; 19] =
    b"\xE2\x94\x8C\xE2\x94\x90\xE2\x94\x94\xE2\x94\x98\xE2\x94\x80\xE2\x94\x82\0";
pub const NCBOXHEAVY: &[u8; 19] =
    b"\xE2\x94\x8F\xE2\x94\x93\xE2\x94\x97\xE2\x94\x9B\xE2\x94\x81\xE2\x94\x83\0";
pub const NCBOXROUND: &[u8; 19] =
    b"\xE2\x95\xAD\xE2\x95\xAE\xE2\x95\xB0\xE2\x95\xAF\xE2\x94\x80\xE2\x94\x82\0";
pub const NCBOXDOUBLE: &[u8; 19] =
    b"\xE2\x95\x94\xE2\x95\x97\xE2\x95\x9A\xE2\x95\x9D\xE2\x95\x90\xE2\x95\x91\0";
pub const NCBOXASCII: &[u8; 7] = b"/\\\\/-|\0";
pub const NCBOXOUTER : & [u8 ; 32] = b"\xF0\x9F\xAD\xBD\xF0\x9F\xAD\xBE\xF0\x9F\xAD\xBC\xF0\x9F\xAD\xBF\xE2\x96\x81\xF0\x9F\xAD\xB5\xF0\x9F\xAD\xB6\xF0\x9F\xAD\xB0\0" ;
pub const NCALPHA_HIGHCONTRAST: u32 = 805306368;
pub const NCALPHA_TRANSPARENT: u32 = 536870912;
pub const NCALPHA_BLEND: u32 = 268435456;
pub const NCALPHA_OPAQUE: u32 = 0;
pub const NCPALETTESIZE: u32 = 256;
pub const NC_NOBACKGROUND_MASK: i64 = -8718968878589280256;
pub const NC_BGDEFAULT_MASK: u32 = 1073741824;
pub const NC_BG_RGB_MASK: u32 = 16777215;
pub const NC_BG_PALETTE: u32 = 134217728;
pub const NC_BG_ALPHA_MASK: u32 = 805306368;
pub const NCSTYLE_MASK: u32 = 65535;
pub const NCSTYLE_ITALIC: u32 = 16;
pub const NCSTYLE_UNDERLINE: u32 = 8;
pub const NCSTYLE_UNDERCURL: u32 = 4;
pub const NCSTYLE_BOLD: u32 = 2;
pub const NCSTYLE_STRUCK: u32 = 1;
pub const NCSTYLE_NONE: u32 = 0;
pub const NCOPTION_INHIBIT_SETLOCALE: u32 = 1;
pub const NCOPTION_NO_CLEAR_BITMAPS: u32 = 2;
pub const NCOPTION_NO_WINCH_SIGHANDLER: u32 = 4;
pub const NCOPTION_NO_QUIT_SIGHANDLERS: u32 = 8;
pub const NCOPTION_PRESERVE_CURSOR: u32 = 16;
pub const NCOPTION_SUPPRESS_BANNERS: u32 = 32;
pub const NCOPTION_NO_ALTERNATE_SCREEN: u32 = 64;
pub const NCOPTION_NO_FONT_CHANGES: u32 = 128;
pub const NCOPTION_DRAIN_INPUT: u32 = 256;
pub const NCOPTION_SCROLLING: u32 = 512;
pub const NCOPTION_CLI_MODE: u32 = 594;
pub const NCINPUT_MAX_EFF_TEXT_CODEPOINTS: u32 = 4;
pub const NCMICE_NO_EVENTS: u32 = 0;
pub const NCMICE_MOVE_EVENT: u32 = 1;
pub const NCMICE_BUTTON_EVENT: u32 = 2;
pub const NCMICE_DRAG_EVENT: u32 = 4;
pub const NCMICE_ALL_EVENTS: u32 = 7;
pub const NCPLANE_OPTION_HORALIGNED: u32 = 1;
pub const NCPLANE_OPTION_VERALIGNED: u32 = 2;
pub const NCPLANE_OPTION_MARGINALIZED: u32 = 4;
pub const NCPLANE_OPTION_FIXED: u32 = 8;
pub const NCPLANE_OPTION_AUTOGROW: u32 = 16;
pub const NCPLANE_OPTION_VSCROLL: u32 = 32;
pub const NCBOXMASK_TOP: u32 = 1;
pub const NCBOXMASK_RIGHT: u32 = 2;
pub const NCBOXMASK_BOTTOM: u32 = 4;
pub const NCBOXMASK_LEFT: u32 = 8;
pub const NCBOXGRAD_TOP: u32 = 16;
pub const NCBOXGRAD_RIGHT: u32 = 32;
pub const NCBOXGRAD_BOTTOM: u32 = 64;
pub const NCBOXGRAD_LEFT: u32 = 128;
pub const NCBOXCORNER_MASK: u32 = 768;
pub const NCBOXCORNER_SHIFT: u32 = 8;
pub const NCVISUAL_OPTION_NODEGRADE: u32 = 1;
pub const NCVISUAL_OPTION_BLEND: u32 = 2;
pub const NCVISUAL_OPTION_HORALIGNED: u32 = 4;
pub const NCVISUAL_OPTION_VERALIGNED: u32 = 8;
pub const NCVISUAL_OPTION_ADDALPHA: u32 = 16;
pub const NCVISUAL_OPTION_CHILDPLANE: u32 = 32;
pub const NCVISUAL_OPTION_NOINTERPOLATE: u32 = 64;
pub const NCREEL_OPTION_INFINITESCROLL: u32 = 1;
pub const NCREEL_OPTION_CIRCULAR: u32 = 2;
pub const NCPREFIXCOLUMNS: u32 = 7;
pub const NCIPREFIXCOLUMNS: u32 = 8;
pub const NCBPREFIXCOLUMNS: u32 = 9;
pub const NCPREFIXSTRLEN: u32 = 8;
pub const NCIPREFIXSTRLEN: u32 = 9;
pub const NCBPREFIXSTRLEN: u32 = 10;
pub const NCMENU_OPTION_BOTTOM: u32 = 1;
pub const NCMENU_OPTION_HIDING: u32 = 2;
pub const NCPROGBAR_OPTION_RETROGRADE: u32 = 1;
pub const NCTABBED_OPTION_BOTTOM: u32 = 1;
pub const NCPLOT_OPTION_LABELTICKSD: u32 = 1;
pub const NCPLOT_OPTION_EXPONENTIALD: u32 = 2;
pub const NCPLOT_OPTION_VERTICALI: u32 = 4;
pub const NCPLOT_OPTION_NODEGRADE: u32 = 8;
pub const NCPLOT_OPTION_DETECTMAXONLY: u32 = 16;
pub const NCPLOT_OPTION_PRINTSAMPLE: u32 = 32;
pub const NCREADER_OPTION_HORSCROLL: u32 = 1;
pub const NCREADER_OPTION_VERSCROLL: u32 = 2;
pub const NCREADER_OPTION_NOCMDKEYS: u32 = 4;
pub const NCREADER_OPTION_CURSOR: u32 = 8;
pub const NCDIRECT_OPTION_INHIBIT_SETLOCALE: u32 = 1;
pub const NCDIRECT_OPTION_INHIBIT_CBREAK: u32 = 2;
pub const NCDIRECT_OPTION_DRAIN_INPUT: u32 = 4;
pub const NCDIRECT_OPTION_NO_QUIT_SIGHANDLERS: u32 = 8;
pub const NCDIRECT_OPTION_VERBOSE: u32 = 16;
pub const NCDIRECT_OPTION_VERY_VERBOSE: u32 = 32;
#[doc = " Convenience types."]
pub type __u_char = core::ffi::c_uchar;
pub type __u_short = core::ffi::c_ushort;
pub type __u_int = core::ffi::c_uint;
pub type __u_long = core::ffi::c_ulong;
#[doc = " Fixed-size types, underlying types depend on word size and compiler."]
pub type __int8_t = core::ffi::c_schar;
pub type __uint8_t = core::ffi::c_uchar;
pub type __int16_t = core::ffi::c_short;
pub type __uint16_t = core::ffi::c_ushort;
pub type __int32_t = core::ffi::c_int;
pub type __uint32_t = core::ffi::c_uint;
pub type __int64_t = core::ffi::c_long;
pub type __uint64_t = core::ffi::c_ulong;
#[doc = " Smallest types with at least a given width."]
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = core::ffi::c_long;
pub type __u_quad_t = core::ffi::c_ulong;
pub type __intmax_t = core::ffi::c_long;
pub type __uintmax_t = core::ffi::c_ulong;
pub type __dev_t = core::ffi::c_ulong;
pub type __uid_t = core::ffi::c_uint;
pub type __gid_t = core::ffi::c_uint;
pub type __ino_t = core::ffi::c_ulong;
pub type __ino64_t = core::ffi::c_ulong;
pub type __mode_t = core::ffi::c_uint;
pub type __nlink_t = core::ffi::c_ulong;
pub type __off_t = core::ffi::c_long;
pub type __off64_t = core::ffi::c_long;
pub type __pid_t = core::ffi::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __fsid_t {
    pub __val: [core::ffi::c_int; 2usize],
}
pub type __clock_t = core::ffi::c_long;
pub type __rlim_t = core::ffi::c_ulong;
pub type __rlim64_t = core::ffi::c_ulong;
pub type __id_t = core::ffi::c_uint;
pub type __time_t = core::ffi::c_long;
pub type __useconds_t = core::ffi::c_uint;
pub type __suseconds_t = core::ffi::c_long;
pub type __suseconds64_t = core::ffi::c_long;
pub type __daddr_t = core::ffi::c_int;
pub type __key_t = core::ffi::c_int;
pub type __clockid_t = core::ffi::c_int;
pub type __timer_t = *mut core::ffi::c_void;
pub type __blksize_t = core::ffi::c_long;
pub type __blkcnt_t = core::ffi::c_long;
pub type __blkcnt64_t = core::ffi::c_long;
pub type __fsblkcnt_t = core::ffi::c_ulong;
pub type __fsblkcnt64_t = core::ffi::c_ulong;
pub type __fsfilcnt_t = core::ffi::c_ulong;
pub type __fsfilcnt64_t = core::ffi::c_ulong;
pub type __fsword_t = core::ffi::c_long;
pub type __ssize_t = core::ffi::c_long;
pub type __syscall_slong_t = core::ffi::c_long;
pub type __syscall_ulong_t = core::ffi::c_ulong;
#[doc = " These few don't really vary by system, they always correspond\nto one of the other defined types."]
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut core::ffi::c_char;
pub type __intptr_t = core::ffi::c_long;
pub type __socklen_t = core::ffi::c_uint;
#[doc = " C99: An integer type that can be accessed as an atomic entity,\neven in the presence of asynchronous interrupts.\nIt is not currently necessary for this to be machine-specific."]
pub type __sig_atomic_t = core::ffi::c_int;
extern "C" {
    #[doc = " Even though CLOCKS_PER_SEC has such a strange value CLK_TCK\npresents the real value for clock ticks per second for the system."]
    pub fn __sysconf(arg1: core::ffi::c_int) -> core::ffi::c_long;
}
#[doc = " Returned by `clock'."]
pub type clock_t = __clock_t;
pub type time_t = __time_t;
#[doc = " ISO C `broken-down time' structure."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct tm {
    #[doc = " Seconds.\t[0-60] (1 leap second)"]
    pub tm_sec: core::ffi::c_int,
    #[doc = " Minutes.\t[0-59]"]
    pub tm_min: core::ffi::c_int,
    #[doc = " Hours.\t[0-23]"]
    pub tm_hour: core::ffi::c_int,
    #[doc = " Day.\t\t[1-31]"]
    pub tm_mday: core::ffi::c_int,
    #[doc = " Month.\t[0-11]"]
    pub tm_mon: core::ffi::c_int,
    #[doc = " Year\t- 1900."]
    pub tm_year: core::ffi::c_int,
    #[doc = " Day of week.\t[0-6]"]
    pub tm_wday: core::ffi::c_int,
    #[doc = " Days in year.[0-365]"]
    pub tm_yday: core::ffi::c_int,
    #[doc = " DST.\t\t[-1/0/1]"]
    pub tm_isdst: core::ffi::c_int,
    #[doc = " Seconds east of UTC."]
    pub __tm_gmtoff: core::ffi::c_long,
    #[doc = " Timezone abbreviation."]
    pub __tm_zone: *const core::ffi::c_char,
}
impl Default for tm {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " POSIX.1b structure for a time value.  This is like a `struct timeval' but\nhas nanoseconds instead of microseconds."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct timespec {
    #[doc = " Seconds."]
    pub tv_sec: __time_t,
    #[doc = " Nanoseconds."]
    pub tv_nsec: __syscall_slong_t,
}
extern "C" {
    #[doc = " Time used by the program so far (user time + system time).\nThe result / CLOCKS_PER_SEC is program time in seconds."]
    pub fn clock() -> clock_t;
}
extern "C" {
    #[doc = " Return the current time and put it in *TIMER if TIMER is not NULL."]
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    #[doc = " Return the difference between TIME1 and TIME0."]
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    #[doc = " Return the `struct tm' representation of *TIMER\nin Universal Coordinated Time (aka Greenwich Mean Time)."]
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    #[doc = " Return the `struct tm' representation\nof *TIMER in the local timezone."]
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    #[doc = " Return the `struct tm' representation of *TIMER in UTC,\nusing *TP to store the result."]
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    #[doc = " Return the `struct tm' representation of *TIMER in local time,\nusing *TP to store the result."]
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    #[doc = " Return a string of the form \"Day Mon dd hh:mm:ss yyyy\\n\"\nthat is the representation of TP in this format."]
    pub fn asctime(__tp: *const tm) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Return in BUF a string of the form \"Day Mon dd hh:mm:ss yyyy\\n\"\nthat is the representation of TP in this format."]
    pub fn asctime_r(__tp: *const tm, __buf: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut core::ffi::c_char)
        -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Current time zone abbreviations."]
    pub static mut __tzname: [*mut core::ffi::c_char; 2usize];
}
extern "C" {
    #[doc = " If daylight-saving time is ever in use."]
    pub static mut __daylight: core::ffi::c_int;
}
extern "C" {
    #[doc = " Seconds west of UTC."]
    pub static mut __timezone: core::ffi::c_long;
}
extern "C" {
    #[doc = " Same as above."]
    pub static mut tzname: [*mut core::ffi::c_char; 2usize];
}
extern "C" {
    #[doc = " Set time conversion information from the TZ environment variable.\nIf TZ is not defined, a locale-dependent default is used."]
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: core::ffi::c_int;
}
extern "C" {
    pub static mut timezone: core::ffi::c_long;
}
extern "C" {
    #[doc = " Set TS to calendar time based in time base BASE."]
    pub fn timespec_get(__ts: *mut timespec, __base: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " These are defined in ctype-info.c.\nThe declarations here must match those in localeinfo.h.\n\nIn the thread-specific locale model (see `uselocale' in <locale.h>)\nwe cannot use global variables for these as was done in the past.\nInstead, the following accessor functions return the address of\neach variable, which is local to the current thread if multithreaded.\n\nThese point into arrays of 384, so they can be indexed by any `unsigned\nchar' value [0,255]; by EOF (-1); or by any `signed char' value\n[-128,-1).  ISO C requires that the ctype functions work for `unsigned\nchar' values and for EOF; we also support negative `signed char' values\nfor broken old programs.  The case conversion arrays are of `int's\nrather than `unsigned char's because tolower (EOF) must be EOF, which\ndoesn't fit into an `unsigned char'.  But today more important is that\nthe arrays are also used for multi-byte character sets."]
    pub fn __ctype_b_loc() -> *mut *const core::ffi::c_ushort;
}
extern "C" {
    pub fn __ctype_tolower_loc() -> *mut *const __int32_t;
}
extern "C" {
    pub fn __ctype_toupper_loc() -> *mut *const __int32_t;
}
extern "C" {
    #[doc = " The following names are all functions:\nint isCHARACTERISTIC(int c);\nwhich return nonzero iff C has CHARACTERISTIC.\nFor the meaning of the characteristic names, see the `enum' above."]
    pub fn isalnum(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn isalpha(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn iscntrl(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn isdigit(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn islower(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn isgraph(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn isprint(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ispunct(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn isspace(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn isupper(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn isxdigit(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return the lowercase version of C."]
    pub fn tolower(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return the uppercase version of C."]
    pub fn toupper(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn isblank(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return nonzero iff C is in the ASCII set\n(i.e., is no more than 7 bits wide)."]
    pub fn isascii(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return the part of C that is in the ASCII set\n(i.e., the low-order 7 bits of C)."]
    pub fn toascii(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " These are the same as `toupper' and `tolower' except that they do not\ncheck the argument for being in the range of a `char'."]
    pub fn _toupper(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn _tolower(arg1: core::ffi::c_int) -> core::ffi::c_int;
}
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = u128;
pub type wchar_t = core::ffi::c_int;
pub type __gnuc_va_list = __builtin_va_list;
pub type wint_t = core::ffi::c_uint;
#[doc = " Conversion state information."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: core::ffi::c_int,
    #[doc = " Value so far."]
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: core::ffi::c_uint,
    pub __wchb: [core::ffi::c_char; 4usize],
}
impl Default for __mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for __mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Scalar type that can hold values which represent locale-specific\ncharacter classifications."]
pub type wctype_t = core::ffi::c_ulong;
extern "C" {
    #[doc = " Test for any wide character for which `iswalpha' or `iswdigit' is\ntrue."]
    pub fn iswalnum(__wc: wint_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Test for any wide character for which `iswupper' or 'iswlower' is\ntrue, or any wide character that is one of a locale-specific set of\nwide-characters for which none of `iswcntrl', `iswdigit',\n`iswpunct', or `iswspace' is true."]
    pub fn iswalpha(__wc: wint_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Test for any control wide character."]
    pub fn iswcntrl(__wc: wint_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Test for any wide character that corresponds to a decimal-digit\ncharacter."]
    pub fn iswdigit(__wc: wint_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Test for any wide character for which `iswprint' is true and\n`iswspace' is false."]
    pub fn iswgraph(__wc: wint_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Test for any wide character that corresponds to a lowercase letter\nor is one of a locale-specific set of wide characters for which\nnone of `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true."]
    pub fn iswlower(__wc: wint_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Test for any printing wide character."]
    pub fn iswprint(__wc: wint_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Test for any printing wide character that is one of a\nlocale-specific et of wide characters for which neither `iswspace'\nnor `iswalnum' is true."]
    pub fn iswpunct(__wc: wint_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Test for any wide character that corresponds to a locale-specific\nset of wide characters for which none of `iswalnum', `iswgraph', or\n`iswpunct' is true."]
    pub fn iswspace(__wc: wint_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Test for any wide character that corresponds to an uppercase letter\nor is one of a locale-specific set of wide character for which none\nof `iswcntrl', `iswdigit', `iswpunct', or `iswspace' is true."]
    pub fn iswupper(__wc: wint_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Test for any wide character that corresponds to a hexadecimal-digit\ncharacter equivalent to that performed be the functions described\nin the previous subclause."]
    pub fn iswxdigit(__wc: wint_t) -> core::ffi::c_int;
}
extern "C" {
    pub fn iswblank(__wc: wint_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Construct value that describes a class of wide characters identified\nby the string argument PROPERTY."]
    pub fn wctype(__property: *const core::ffi::c_char) -> wctype_t;
}
extern "C" {
    #[doc = " Determine whether the wide-character WC has the property described by\nDESC."]
    pub fn iswctype(__wc: wint_t, __desc: wctype_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Converts an uppercase letter to the corresponding lowercase letter."]
    pub fn towlower(__wc: wint_t) -> wint_t;
}
extern "C" {
    #[doc = " Converts an lowercase letter to the corresponding uppercase letter."]
    pub fn towupper(__wc: wint_t) -> wint_t;
}
extern "C" {
    #[doc = " Copy SRC to DEST."]
    pub fn wcscpy(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Copy no more than N wide-characters of SRC to DEST."]
    pub fn wcsncpy(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Append SRC onto DEST."]
    pub fn wcscat(__dest: *mut wchar_t, __src: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Append no more than N wide-characters of SRC onto DEST."]
    pub fn wcsncat(__dest: *mut wchar_t, __src: *const wchar_t, __n: usize) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Compare S1 and S2."]
    pub fn wcscmp(__s1: *const core::ffi::c_int, __s2: *const core::ffi::c_int)
        -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Compare N wide-characters of S1 and S2."]
    pub fn wcsncmp(
        __s1: *const core::ffi::c_int,
        __s2: *const core::ffi::c_int,
        __n: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Compare S1 and S2, both interpreted as appropriate to the\nLC_COLLATE category of the current locale."]
    pub fn wcscoll(__s1: *const wchar_t, __s2: *const wchar_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Transform S2 into array pointed to by S1 such that if wcscmp is\napplied to two transformed strings the result is the as applying\n`wcscoll' to the original strings."]
    pub fn wcsxfrm(__s1: *mut wchar_t, __s2: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn wcschr(__wcs: *const core::ffi::c_int, __wc: core::ffi::c_int) -> *mut core::ffi::c_int;
}
extern "C" {
    pub fn wcsrchr(__wcs: *const wchar_t, __wc: wchar_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Return the length of the initial segmet of WCS which\nconsists entirely of wide characters not in REJECT."]
    pub fn wcscspn(__wcs: *const wchar_t, __reject: *const wchar_t) -> usize;
}
extern "C" {
    #[doc = " Return the length of the initial segmet of WCS which\nconsists entirely of wide characters in  ACCEPT."]
    pub fn wcsspn(__wcs: *const wchar_t, __accept: *const wchar_t) -> usize;
}
extern "C" {
    pub fn wcspbrk(__wcs: *const wchar_t, __accept: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wcsstr(__haystack: *const wchar_t, __needle: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Divide WCS into tokens separated by characters in DELIM."]
    pub fn wcstok(
        __s: *mut wchar_t,
        __delim: *const wchar_t,
        __ptr: *mut *mut wchar_t,
    ) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Return the number of wide characters in S."]
    pub fn wcslen(__s: *const core::ffi::c_int) -> core::ffi::c_ulong;
}
extern "C" {
    pub fn wcswcs(__haystack: *const wchar_t, __needle: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn wmemchr(
        __s: *const core::ffi::c_int,
        __c: core::ffi::c_int,
        __n: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_int;
}
extern "C" {
    #[doc = " Compare N wide characters of S1 and S2."]
    pub fn wmemcmp(
        __s1: *const core::ffi::c_int,
        __s2: *const core::ffi::c_int,
        __n: core::ffi::c_ulong,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Copy N wide characters of SRC to DEST."]
    pub fn wmemcpy(
        __s1: *mut core::ffi::c_int,
        __s2: *const core::ffi::c_int,
        __n: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_int;
}
extern "C" {
    #[doc = " Copy N wide characters of SRC to DEST, guaranteeing\ncorrect behavior for overlapping strings."]
    pub fn wmemmove(
        __s1: *mut core::ffi::c_int,
        __s2: *const core::ffi::c_int,
        __n: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_int;
}
extern "C" {
    #[doc = " Set N wide characters of S to C."]
    pub fn wmemset(__s: *mut wchar_t, __c: wchar_t, __n: usize) -> *mut wchar_t;
}
extern "C" {
    #[doc = " Determine whether C constitutes a valid (one-byte) multibyte\ncharacter."]
    pub fn btowc(__c: core::ffi::c_int) -> wint_t;
}
extern "C" {
    #[doc = " Determine whether C corresponds to a member of the extended\ncharacter set whose multibyte representation is a single byte."]
    pub fn wctob(__c: wint_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Determine number of column positions required for C."]
    pub fn wcwidth(__c: wchar_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Determine number of column positions required for first N wide\ncharacters (or fewer if S ends before this) in S."]
    pub fn wcswidth(__s: *const wchar_t, __n: usize) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Convert initial portion of the wide string NPTR to `double'\nrepresentation."]
    pub fn wcstod(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    #[doc = " Likewise for `float' and `long double' sizes of floating-point numbers."]
    pub fn wcstof(__nptr: *const wchar_t, __endptr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    #[doc = " Convert initial portion of wide string NPTR to `long int'\nrepresentation."]
    pub fn wcstol(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_long;
}
extern "C" {
    #[doc = " Convert initial portion of wide string NPTR to `unsigned long int'\nrepresentation."]
    pub fn wcstoul(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    #[doc = " Convert initial portion of wide string NPTR to `long long int'\nrepresentation."]
    pub fn wcstoll(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_longlong;
}
extern "C" {
    #[doc = " Convert initial portion of wide string NPTR to `unsigned long long int'\nrepresentation."]
    pub fn wcstoull(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: core::ffi::c_int,
    ) -> core::ffi::c_ulonglong;
}
extern "C" {
    #[doc = " Write formatted output to stdout.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn wprintf(__format: *const wchar_t, ...) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Write formatted output to stdout from argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vwprintf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Write formatted output of at most N character to S from argument\nlist ARG."]
    pub fn vswprintf(
        __s: *mut wchar_t,
        __n: usize,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn wscanf(__format: *const wchar_t, ...) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_wscanf"]
    pub fn wscanf1(__format: *const wchar_t, ...) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vwscanf(__format: *const wchar_t, __arg: *mut __va_list_tag) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG."]
    pub fn vswscanf(
        __s: *const wchar_t,
        __format: *const wchar_t,
        __arg: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read a character from stdin.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn getwchar() -> wint_t;
}
extern "C" {
    #[doc = " Write a character to stdout.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn putwchar(__wc: wchar_t) -> wint_t;
}
extern "C" {
    #[doc = " Format TP into S according to FORMAT.\nWrite no more than MAXSIZE wide characters and return the number\nof wide characters written, or 0 if it would exceed MAXSIZE."]
    pub fn wcsftime(
        __s: *mut wchar_t,
        __maxsize: usize,
        __format: *const wchar_t,
        __tp: *const tm,
    ) -> usize;
}
#[doc = " The tag name of this struct is _G_fpos_t to preserve historic\nC++ mangled names for functions taking fpos_t arguments.\nThat name should not be used in new code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
impl Default for _G_fpos_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The tag name of this struct is _G_fpos_t to preserve historic\nC++ mangled names for functions taking fpos_t arguments.\nThat name should not be used in new code."]
pub type __fpos_t = _G_fpos_t;
#[doc = " The tag name of this struct is _G_fpos64_t to preserve historic\nC++ mangled names for functions taking fpos_t and/or fpos64_t\narguments.  That name should not be used in new code."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
impl Default for _G_fpos64_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " The tag name of this struct is _G_fpos64_t to preserve historic\nC++ mangled names for functions taking fpos_t and/or fpos64_t\narguments.  That name should not be used in new code."]
pub type __fpos64_t = _G_fpos64_t;
#[doc = " The opaque type of streams.  This is the definition used elsewhere."]
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_codecvt {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_wide_data {
    _unused: [u8; 0],
}
pub type _IO_lock_t = core::ffi::c_void;
#[doc = " The tag name of this struct is _IO_FILE to preserve historic\nC++ mangled names for functions taking FILE* arguments.\nThat name should not be used in new code."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _IO_FILE {
    #[doc = " High-order word is _IO_MAGIC; rest is flags."]
    pub _flags: core::ffi::c_int,
    #[doc = " Current read pointer"]
    pub _IO_read_ptr: *mut core::ffi::c_char,
    #[doc = " End of get area."]
    pub _IO_read_end: *mut core::ffi::c_char,
    #[doc = " Start of putback+get area."]
    pub _IO_read_base: *mut core::ffi::c_char,
    #[doc = " Start of put area."]
    pub _IO_write_base: *mut core::ffi::c_char,
    #[doc = " Current put pointer."]
    pub _IO_write_ptr: *mut core::ffi::c_char,
    #[doc = " End of put area."]
    pub _IO_write_end: *mut core::ffi::c_char,
    #[doc = " Start of reserve area."]
    pub _IO_buf_base: *mut core::ffi::c_char,
    #[doc = " End of reserve area."]
    pub _IO_buf_end: *mut core::ffi::c_char,
    #[doc = " Pointer to start of non-current get area."]
    pub _IO_save_base: *mut core::ffi::c_char,
    #[doc = " Pointer to first valid character of backup area"]
    pub _IO_backup_base: *mut core::ffi::c_char,
    #[doc = " Pointer to end of non-current get area."]
    pub _IO_save_end: *mut core::ffi::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: core::ffi::c_int,
    pub _flags2: core::ffi::c_int,
    #[doc = " This used to be _offset but it's too small."]
    pub _old_offset: __off_t,
    #[doc = " 1+column number of pbase(); 0 is unknown."]
    pub _cur_column: core::ffi::c_ushort,
    pub _vtable_offset: core::ffi::c_schar,
    pub _shortbuf: [core::ffi::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    #[doc = " Wide character stream stuff."]
    pub _codecvt: *mut _IO_codecvt,
    pub _wide_data: *mut _IO_wide_data,
    pub _freeres_list: *mut _IO_FILE,
    pub _freeres_buf: *mut core::ffi::c_void,
    pub __pad5: usize,
    pub _mode: core::ffi::c_int,
    #[doc = " Make sure we don't get into trouble again."]
    pub _unused2: [core::ffi::c_char; 20usize],
}
impl Default for _IO_FILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type va_list = __gnuc_va_list;
#[doc = " The tag name of this struct is _G_fpos_t to preserve historic\nC++ mangled names for functions taking fpos_t arguments.\nThat name should not be used in new code."]
pub type fpos_t = __fpos_t;
extern "C" {
    #[doc = " Standard input stream."]
    pub static mut stdin: *mut FILE;
}
extern "C" {
    #[doc = " Standard output stream."]
    pub static mut stdout: *mut FILE;
}
extern "C" {
    #[doc = " Standard error output stream."]
    pub static mut stderr: *mut FILE;
}
extern "C" {
    #[doc = " Remove file FILENAME."]
    pub fn remove(__filename: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Rename file OLD to NEW."]
    pub fn rename(
        __old: *const core::ffi::c_char,
        __new: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Close STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fclose(__stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    #[doc = " Generate a temporary filename."]
    pub fn tmpnam(arg1: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Generate a unique temporary filename using up to five characters of PFX\nif it is not NULL.  The directory to put this file in is searched for\nas follows: First the environment variable \"TMPDIR\" is checked.\nIf it contains the name of a writable directory, that directory is used.\nIf not and if DIR is not NULL, that value is checked.  If that fails,\nP_tmpdir is tried and finally \"/tmp\".  The storage for the filename\nis allocated by `malloc'."]
    pub fn tempnam(
        __dir: *const core::ffi::c_char,
        __pfx: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Flush STREAM, or all streams if STREAM is NULL.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fflush(__stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Open a file and create a new stream for it.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fopen(
        __filename: *const core::ffi::c_char,
        __modes: *const core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Open a file, replacing an existing stream with it.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn freopen(
        __filename: *const core::ffi::c_char,
        __modes: *const core::ffi::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Create a new stream that refers to an existing system file descriptor."]
    pub fn fdopen(__fd: core::ffi::c_int, __modes: *const core::ffi::c_char) -> *mut FILE;
}
extern "C" {
    #[doc = " Write formatted output to STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Write formatted output to stdout.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn printf(__format: *const core::ffi::c_char, ...) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Write formatted output to S from argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Write formatted output to stdout from argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vprintf(
        __format: *const core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Write formatted output to S from argument list ARG."]
    pub fn vsprintf(
        __s: *mut core::ffi::c_char,
        __format: *const core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut core::ffi::c_char,
        __maxlen: core::ffi::c_ulong,
        __format: *const core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read formatted input from STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fscanf(__stream: *mut FILE, __format: *const core::ffi::c_char, ...)
        -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read formatted input from STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn vscanf(
        __format: *const core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG."]
    pub fn vsscanf(
        __s: *const core::ffi::c_char,
        __format: *const core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read formatted input from stdin into argument list ARG.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read formatted input from S into argument list ARG."]
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const core::ffi::c_char,
        __format: *const core::ffi::c_char,
        __arg: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read a character from STREAM.\n\nThese functions are possible cancellation points and therefore not\nmarked with __THROW."]
    pub fn fgetc(__stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read a character from stdin.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn getchar() -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Write a character to STREAM.\n\nThese functions are possible cancellation points and therefore not\nmarked with __THROW.\n\nThese functions is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fputc(__c: core::ffi::c_int, __stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    pub fn putc(__c: core::ffi::c_int, __stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Write a character to stdout.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn putchar(__c: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get a word (int) from STREAM."]
    pub fn getw(__stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Write a word (int) to STREAM."]
    pub fn putw(__w: core::ffi::c_int, __stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get a newline-terminated string of finite length from STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fgets(
        __s: *mut core::ffi::c_char,
        __n: core::ffi::c_int,
        __stream: *mut FILE,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Write a string to STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fputs(__s: *const core::ffi::c_char, __stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Write a string, followed by a newline, to stdout.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn puts(__s: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Push a character back onto the input buffer of STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn ungetc(__c: core::ffi::c_int, __stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read chunks of generic data from STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fread(
        __ptr: *mut core::ffi::c_void,
        __size: core::ffi::c_ulong,
        __n: core::ffi::c_ulong,
        __stream: *mut FILE,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    #[doc = " Write chunks of generic data to STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fwrite(
        __ptr: *const core::ffi::c_void,
        __size: core::ffi::c_ulong,
        __n: core::ffi::c_ulong,
        __s: *mut FILE,
    ) -> core::ffi::c_ulong;
}
extern "C" {
    #[doc = " Seek to a certain position on STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fseek(
        __stream: *mut FILE,
        __off: core::ffi::c_long,
        __whence: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return the current position of STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn ftell(__stream: *mut FILE) -> core::ffi::c_long;
}
extern "C" {
    #[doc = " Rewind to the beginning of STREAM.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    #[doc = " Get STREAM's position.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set STREAM's position.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Clear the error and EOF indicators for STREAM."]
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    #[doc = " Return the EOF indicator for STREAM."]
    pub fn feof(__stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return the error indicator for STREAM."]
    pub fn ferror(__stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Print a message describing the meaning of the value of errno.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn perror(__s: *const core::ffi::c_char);
}
extern "C" {
    #[doc = " Return the system file descriptor for STREAM."]
    pub fn fileno(__stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Close a stream opened by popen and return the status of its child.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn pclose(__stream: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Create a new stream connected to a pipe running the given command.\n\nThis function is a possible cancellation point and therefore not\nmarked with __THROW."]
    pub fn popen(
        __command: *const core::ffi::c_char,
        __modes: *const core::ffi::c_char,
    ) -> *mut FILE;
}
extern "C" {
    #[doc = " Return the name of the controlling terminal."]
    pub fn ctermid(__s: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Return the name of the current user."]
    pub fn cuserid(__s: *mut core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " For communication from 'getopt' to the caller.\nWhen 'getopt' finds an option that takes an argument,\nthe argument value is returned here.\nAlso, when 'ordering' is RETURN_IN_ORDER,\neach non-option ARGV-element is returned here."]
    pub static mut optarg: *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Index in ARGV of the next element to be scanned.\nThis is used for communication to and from the caller\nand for communication between successive calls to 'getopt'.\n\nOn entry to 'getopt', zero means this is the first call; initialize.\n\nWhen 'getopt' returns -1, this is the index of the first of the\nnon-option elements that the caller should itself scan.\n\nOtherwise, 'optind' communicates from one call to the next\nhow much of ARGV has been scanned so far."]
    pub static mut optind: core::ffi::c_int;
}
extern "C" {
    #[doc = " Callers store zero here to inhibit the error message 'getopt' prints\nfor unrecognized options."]
    pub static mut opterr: core::ffi::c_int;
}
extern "C" {
    #[doc = " Set to an option character which was unrecognized."]
    pub static mut optopt: core::ffi::c_int;
}
extern "C" {
    #[doc = " Get definitions and prototypes for functions to process the\narguments in ARGV (ARGC of them, minus the program name) for\noptions given in OPTS.\n\nReturn the option character from OPTS just read.  Return -1 when\nthere are no more options.  For unrecognized options, or options\nmissing arguments, 'optopt' is set to the option letter, and '?' is\nreturned.\n\nThe OPTS string is a list of characters which are recognized option\nletters, optionally followed by colons, specifying that that letter\ntakes an argument, to be placed in 'optarg'.\n\nIf a letter in OPTS is followed by two colons, its argument is\noptional.  This behavior is specific to the GNU 'getopt'.\n\nThe argument '--' causes premature termination of argument\nscanning, explicitly telling 'getopt' that there are no more\noptions.\n\nIf OPTS begins with '-', then non-option arguments are treated as\narguments to the option '\\1'.  This behavior is specific to the GNU\n'getopt'.  If OPTS begins with '+', or POSIXLY_CORRECT is set in\nthe environment, then do not permute arguments.\n\nFor standards compliance, the 'argv' argument has the type\nchar *const *, but this is inaccurate; if argument permutation is\nenabled, the argv array (not the strings it points to) must be\nwritable."]
    pub fn getopt(
        ___argc: core::ffi::c_int,
        ___argv: *const *mut core::ffi::c_char,
        __shortopts: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Slow-path routines used by the optimized inline functions in\nbits/stdio.h."]
    pub fn __uflow(arg1: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut FILE, arg2: core::ffi::c_int) -> core::ffi::c_int;
}
#[doc = " Signed."]
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
#[doc = " Unsigned."]
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
#[doc = " Signed."]
pub type int_fast8_t = core::ffi::c_schar;
pub type int_fast16_t = core::ffi::c_long;
pub type int_fast32_t = core::ffi::c_long;
pub type int_fast64_t = core::ffi::c_long;
#[doc = " Unsigned."]
pub type uint_fast8_t = core::ffi::c_uchar;
pub type uint_fast16_t = core::ffi::c_ulong;
pub type uint_fast32_t = core::ffi::c_ulong;
pub type uint_fast64_t = core::ffi::c_ulong;
#[doc = " Largest integral types."]
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " Returned by `div'."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct div_t {
    #[doc = " Quotient."]
    pub quot: core::ffi::c_int,
    #[doc = " Remainder."]
    pub rem: core::ffi::c_int,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ldiv_t {
    #[doc = " Quotient."]
    pub quot: core::ffi::c_long,
    #[doc = " Remainder."]
    pub rem: core::ffi::c_long,
}
#[doc = " Returned by `lldiv'."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct lldiv_t {
    #[doc = " Quotient."]
    pub quot: core::ffi::c_longlong,
    #[doc = " Remainder."]
    pub rem: core::ffi::c_longlong,
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    #[doc = " Convert a string to a floating-point number."]
    pub fn atof(__nptr: *const core::ffi::c_char) -> f64;
}
extern "C" {
    #[doc = " Convert a string to an integer."]
    pub fn atoi(__nptr: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Convert a string to a long integer."]
    pub fn atol(__nptr: *const core::ffi::c_char) -> core::ffi::c_long;
}
extern "C" {
    #[doc = " Convert a string to a long long integer."]
    pub fn atoll(__nptr: *const core::ffi::c_char) -> core::ffi::c_longlong;
}
extern "C" {
    #[doc = " Return a random integer between 0 and RAND_MAX inclusive."]
    pub fn rand() -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return non-negative, double-precision floating-point value in [0.0,1.0)."]
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut core::ffi::c_ushort) -> f64;
}
extern "C" {
    #[doc = " Return non-negative, long integer in [0,2^31)."]
    pub fn lrand48() -> core::ffi::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut core::ffi::c_ushort) -> core::ffi::c_long;
}
extern "C" {
    pub fn lcong48(__param: *mut core::ffi::c_ushort);
}
extern "C" {
    #[doc = " Allocate NMEMB elements of SIZE bytes each, all initialized to 0."]
    pub fn calloc(
        __nmemb: core::ffi::c_ulong,
        __size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Re-allocate the previously allocated block\nin PTR, making the new block SIZE bytes long.  */\n/* __attribute_malloc__ is not used, because if realloc returns\nthe same pointer that was passed to it, aliasing needs to be allowed\nbetween objects pointed by the old and new pointers."]
    pub fn realloc(
        __ptr: *mut core::ffi::c_void,
        __size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Free a block allocated by `malloc', `realloc' or `calloc'."]
    pub fn free(__ptr: *mut core::ffi::c_void);
}
extern "C" {
    #[doc = " ISO C variant of aligned allocation."]
    pub fn aligned_alloc(
        __alignment: core::ffi::c_ulong,
        __size: core::ffi::c_ulong,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Abort execution and generate a core-dump."]
    pub fn abort() -> !;
}
extern "C" {
    #[doc = " Register a function to be called when `exit' is called."]
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> core::ffi::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Call all functions registered with `atexit' and `on_exit',\nin the reverse of the order in which they were registered,\nperform stdio cleanup, and terminate program execution with STATUS."]
    pub fn exit(__status: core::ffi::c_int) -> !;
}
extern "C" {
    #[doc = " Call all functions registered with `at_quick_exit' in the reverse\nof the order in which they were registered and terminate program\nexecution with STATUS."]
    pub fn quick_exit(__status: core::ffi::c_int) -> !;
}
extern "C" {
    #[doc = " Terminate the program with STATUS without calling any of the\nfunctions registered with `atexit' or `on_exit'."]
    pub fn _Exit(__status: core::ffi::c_int) -> !;
}
extern "C" {
    #[doc = " Return the value of envariable NAME, or NULL if it doesn't exist."]
    pub fn getenv(__name: *const core::ffi::c_char) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " The SVID says this is in <stdio.h>, but this seems a better place.\t*/\n/* Put STRING, which is of the form \"NAME=VALUE\", in the environment.\nIf there is no `=', remove NAME from the environment."]
    pub fn putenv(__string: *mut core::ffi::c_char) -> core::ffi::c_int;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const core::ffi::c_void,
        arg2: *const core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
extern "C" {
    #[doc = " Do a binary search for KEY in BASE, which consists of NMEMB elements\nof SIZE bytes each, using COMPAR to perform the comparisons."]
    pub fn bsearch(
        __key: *const core::ffi::c_void,
        __base: *const core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Sort NMEMB elements of BASE, of SIZE bytes each,\nusing COMPAR to perform the comparisons."]
    pub fn qsort(
        __base: *mut core::ffi::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    #[doc = " Return the absolute value of X."]
    pub fn abs(__x: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn labs(__x: core::ffi::c_long) -> core::ffi::c_long;
}
extern "C" {
    pub fn llabs(__x: core::ffi::c_longlong) -> core::ffi::c_longlong;
}
extern "C" {
    #[doc = " Return the `div_t', `ldiv_t' or `lldiv_t' representation\nof the value of NUMER over DENOM. */\n/* GCC may have built-ins for these someday."]
    pub fn div(__numer: core::ffi::c_int, __denom: core::ffi::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: core::ffi::c_long, __denom: core::ffi::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: core::ffi::c_longlong, __denom: core::ffi::c_longlong) -> lldiv_t;
}
extern "C" {
    #[doc = " Put the multibyte character represented\nby WCHAR in S, returning its length."]
    pub fn wctomb(__s: *mut core::ffi::c_char, __wchar: wchar_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Convert a wide char string to multibyte string."]
    pub fn wcstombs(__s: *mut core::ffi::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    #[doc = " Compare N bytes of S1 and S2.  Return zero if S1 and S2 are equal.\nReturn some non-zero value otherwise.\n\nEssentially __memcmpeq has the exact same semantics as memcmp\nexcept the return value is less constrained.  memcmp is always a\ncorrect implementation of __memcmpeq.  As well !!memcmp, -memcmp,\nor bcmp are correct implementations.\n\n__memcmpeq is meant to be used by compilers when memcmp return is\nonly used for its boolean value.\n\n__memcmpeq is declared only for use by compilers.  Programs should\ncontinue to use memcmp."]
    pub fn __memcmpeq(
        __s1: *const core::ffi::c_void,
        __s2: *const core::ffi::c_void,
        __n: usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Divide S into tokens separated by characters in DELIM.  Information\npassed between calls are stored in SAVE_PTR."]
    pub fn __strtok_r(
        __s: *mut core::ffi::c_char,
        __delim: *const core::ffi::c_char,
        __save_ptr: *mut *mut core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
#[doc = " An integral type that can be modified atomically, without the\npossibility of a signal arriving in the middle of the operation."]
pub type sig_atomic_t = __sig_atomic_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __sigset_t {
    pub __val: [core::ffi::c_ulong; 16usize],
}
#[doc = " A set of signals to be blocked, unblocked, or waited for."]
pub type sigset_t = __sigset_t;
pub type pid_t = __pid_t;
pub type uid_t = __uid_t;
#[doc = " Type of a signal handler."]
pub type __sighandler_t = ::core::option::Option<unsafe extern "C" fn(arg1: core::ffi::c_int)>;
extern "C" {
    #[doc = " The X/Open definition of `signal' specifies the SVID semantic.  Use\nthe additional function `sysv_signal' when X/Open compatibility is\nrequested."]
    pub fn __sysv_signal(__sig: core::ffi::c_int, __handler: __sighandler_t) -> __sighandler_t;
}
extern "C" {
    pub fn kill(__pid: __pid_t, __sig: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Raise signal SIG, i.e., send SIG to yourself."]
    pub fn raise(__sig: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Clear all signals from SET."]
    pub fn sigemptyset(__set: *mut sigset_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set all signals in SET."]
    pub fn sigfillset(__set: *mut sigset_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Add SIGNO to SET."]
    pub fn sigaddset(__set: *mut sigset_t, __signo: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Remove SIGNO from SET."]
    pub fn sigdelset(__set: *mut sigset_t, __signo: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return 1 if SIGNO is in SET, 0 if not."]
    pub fn sigismember(__set: *const sigset_t, __signo: core::ffi::c_int) -> core::ffi::c_int;
}
#[doc = " Structure describing the action to be taken when a signal arrives."]
#[repr(C)]
pub struct sigaction {
    pub sa_handler: __sighandler_t,
    #[doc = " Additional set of signals to be blocked."]
    pub sa_mask: __sigset_t,
    #[doc = " Special flags."]
    pub sa_flags: core::ffi::c_int,
    #[doc = " Restore handler."]
    pub sa_restorer: ::core::option::Option<unsafe extern "C" fn()>,
}
impl Default for sigaction {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Get and/or change the set of blocked signals."]
    pub fn sigprocmask(
        __how: core::ffi::c_int,
        __set: *const sigset_t,
        __oset: *mut sigset_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Change the set of blocked signals to SET,\nwait until a signal arrives, and restore the set of blocked signals.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn sigsuspend(__set: *const sigset_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get and/or set the action for signal SIG."]
    pub fn sigaction(
        __sig: core::ffi::c_int,
        __act: *const sigaction,
        __oact: *mut sigaction,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Put in SET all signals that are blocked and waiting to be delivered."]
    pub fn sigpending(__set: *mut sigset_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return number of available real-time signal with highest priority."]
    pub fn __libc_current_sigrtmin() -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return number of available real-time signal with lowest priority."]
    pub fn __libc_current_sigrtmax() -> core::ffi::c_int;
}
#[doc = " Structure for scatter/gather I/O."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct iovec {
    #[doc = " Pointer to data."]
    pub iov_base: *mut core::ffi::c_void,
    #[doc = " Length of data."]
    pub iov_len: usize,
}
impl Default for iovec {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type nlink_t = __nlink_t;
pub type off_t = __off_t;
pub type id_t = __id_t;
pub type key_t = __key_t;
#[doc = " Clock ID used in clock and timer functions."]
pub type clockid_t = __clockid_t;
#[doc = " Timer ID returned by `timer_create'."]
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type suseconds_t = __suseconds_t;
#[doc = " These were defined by ISO C without the first `_'."]
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = core::ffi::c_long;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type socklen_t = __socklen_t;
#[doc = " Sequenced, reliable, connection-based\nbyte streams."]
pub const __socket_type_SOCK_STREAM: __socket_type = 1;
#[doc = " Connectionless, unreliable datagrams\nof fixed maximum length."]
pub const __socket_type_SOCK_DGRAM: __socket_type = 2;
#[doc = " Raw protocol interface."]
pub const __socket_type_SOCK_RAW: __socket_type = 3;
#[doc = " Reliably-delivered messages."]
pub const __socket_type_SOCK_RDM: __socket_type = 4;
#[doc = " Sequenced, reliable, connection-based,\ndatagrams of fixed maximum length."]
pub const __socket_type_SOCK_SEQPACKET: __socket_type = 5;
#[doc = " Datagram Congestion Control Protocol."]
pub const __socket_type_SOCK_DCCP: __socket_type = 6;
#[doc = " Linux specific way of getting packets\nat the dev level.  For writing rarp and\nother similar things on the user level."]
pub const __socket_type_SOCK_PACKET: __socket_type = 10;
#[doc = " Atomically set close-on-exec flag for the\nnew descriptor(s)."]
pub const __socket_type_SOCK_CLOEXEC: __socket_type = 524288;
#[doc = " Atomically mark descriptor(s) as\nnon-blocking."]
pub const __socket_type_SOCK_NONBLOCK: __socket_type = 2048;
#[doc = " Types of sockets."]
pub type __socket_type = core::ffi::c_uint;
#[doc = " POSIX.1g specifies this type name for the `sa_family' member."]
pub type sa_family_t = core::ffi::c_ushort;
#[doc = " Structure describing a generic socket address."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sockaddr {
    #[doc = " Common data: address family and length."]
    pub sa_family: sa_family_t,
    #[doc = " Address data."]
    pub sa_data: [core::ffi::c_char; 14usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sockaddr_storage {
    #[doc = " Address family, etc."]
    pub ss_family: sa_family_t,
    pub __ss_padding: [core::ffi::c_char; 118usize],
    #[doc = " Force desired alignment."]
    pub __ss_align: core::ffi::c_ulong,
}
impl Default for sockaddr_storage {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Structure used for storage of ancillary data object information."]
#[repr(C)]
#[derive(Debug, Default)]
pub struct cmsghdr {
    #[doc = " Length of data in cmsg_data plus length\nof cmsghdr structure.\n The type should be socklen_t but the\ndefinition of the kernel is incompatible\nwith this."]
    pub cmsg_len: usize,
    #[doc = " Originating protocol."]
    pub cmsg_level: core::ffi::c_int,
    #[doc = " Protocol specific type."]
    pub cmsg_type: core::ffi::c_int,
    #[doc = " Ancillary data."]
    pub __cmsg_data: __IncompleteArrayField<core::ffi::c_uchar>,
}
#[doc = " Structure used to manipulate the SO_LINGER option."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct linger {
    #[doc = " Nonzero to linger on close."]
    pub l_onoff: core::ffi::c_int,
    #[doc = " Time to linger."]
    pub l_linger: core::ffi::c_int,
}
extern "C" {
    #[doc = " Give the socket FD the local address ADDR (which is LEN bytes long)."]
    pub fn bind(
        __fd: core::ffi::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Put the local address of FD into *ADDR and its length in *LEN."]
    pub fn getsockname(
        __fd: core::ffi::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Open a connection on socket FD to peer at ADDR (which LEN bytes long).\nFor connectionless socket types, just set the default address to send to\nand the only address from which to accept transmissions.\nReturn 0 on success, -1 for errors.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn connect(
        __fd: core::ffi::c_int,
        __addr: *const sockaddr,
        __len: socklen_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Put the address of the peer connected to socket FD into *ADDR\n(which is *LEN bytes long), and its actual length into *LEN."]
    pub fn getpeername(
        __fd: core::ffi::c_int,
        __addr: *mut sockaddr,
        __len: *mut socklen_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Read N bytes into BUF from socket FD.\nReturns the number read or -1 for errors.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn recv(
        __fd: core::ffi::c_int,
        __buf: *mut core::ffi::c_void,
        __n: usize,
        __flags: core::ffi::c_int,
    ) -> isize;
}
extern "C" {
    #[doc = " Read N bytes into BUF through socket FD.\nIf ADDR is not NULL, fill in *ADDR_LEN bytes of it with the address of\nthe sender, and store the actual size of the address in *ADDR_LEN.\nReturns the number of bytes read or -1 for errors.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn recvfrom(
        __fd: core::ffi::c_int,
        __buf: *mut core::ffi::c_void,
        __n: usize,
        __flags: core::ffi::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> isize;
}
extern "C" {
    pub fn getsockopt(
        __fd: core::ffi::c_int,
        __level: core::ffi::c_int,
        __optname: core::ffi::c_int,
        __optval: *mut core::ffi::c_void,
        __optlen: *mut socklen_t,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Prepare to accept connections on socket FD.\nN connection requests will be queued before further requests are refused.\nReturns 0 on success, -1 for errors."]
    pub fn listen(__fd: core::ffi::c_int, __n: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Await a connection on socket FD.\nWhen a connection arrives, open a new socket to communicate with it,\nset *ADDR (which is *ADDR_LEN bytes long) to the address of the connecting\npeer and *ADDR_LEN to the address's actual length, and return the\nnew socket's descriptor, or -1 for errors.\n\nThis function is a cancellation point and therefore not marked with\n__THROW."]
    pub fn accept(
        __fd: core::ffi::c_int,
        __addr: *mut sockaddr,
        __addr_len: *mut socklen_t,
    ) -> core::ffi::c_int;
}
#[doc = " Internet address."]
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[doc = " Type to represent a port."]
pub type in_port_t = u16;
#[doc = " IPv6 address"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
impl Default for in6_addr {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " ::"]
    pub static in6addr_any: in6_addr;
}
extern "C" {
    #[doc = " ::1"]
    pub static in6addr_loopback: in6_addr;
}
#[doc = " Structure describing an Internet socket address."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    #[doc = " Port number."]
    pub sin_port: in_port_t,
    #[doc = " Internet address."]
    pub sin_addr: in_addr,
    #[doc = " Pad to size of `struct sockaddr'."]
    pub sin_zero: [core::ffi::c_uchar; 8usize],
}
#[doc = " Ditto, for IPv6."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    #[doc = " Transport layer port #"]
    pub sin6_port: in_port_t,
    #[doc = " IPv6 flow information"]
    pub sin6_flowinfo: u32,
    #[doc = " IPv6 address"]
    pub sin6_addr: in6_addr,
    #[doc = " IPv6 scope-id"]
    pub sin6_scope_id: u32,
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn htonl(__hostlong: u32) -> u32;
}
extern "C" {
    pub fn htons(__hostshort: u16) -> u16;
}
extern "C" {
    #[doc = " Get a human-readable string describing the running Notcurses version."]
    pub fn notcurses_version() -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Cannot be inline, as we want to get the versions of the actual Notcurses\n library we loaded, not what we compile against."]
    pub fn notcurses_version_components(
        major: *mut core::ffi::c_int,
        minor: *mut core::ffi::c_int,
        patch: *mut core::ffi::c_int,
        tweak: *mut core::ffi::c_int,
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct notcurses {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncplane {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncvisual {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncuplot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncdplot {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncprogbar {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncfdplane {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncsubproc {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncselector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncmultiselector {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncreader {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ncfadectx {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct nctablet {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncreel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct nctab {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct nctabbed {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug)]
pub struct ncdirect {
    _unused: [u8; 0],
}
#[doc = " let the ncvisual pick"]
pub const ncblitter_e_NCBLIT_DEFAULT: ncblitter_e = 0;
#[doc = " space, compatible with ASCII"]
pub const ncblitter_e_NCBLIT_1x1: ncblitter_e = 1;
#[doc = " halves + 1x1 (space)     ▄▀"]
pub const ncblitter_e_NCBLIT_2x1: ncblitter_e = 2;
#[doc = " quadrants + 2x1          ▗▐ ▖▀▟▌▙"]
pub const ncblitter_e_NCBLIT_2x2: ncblitter_e = 3;
#[doc = " sextants (*NOT* 2x2)     🬀🬁🬂🬃🬄🬅🬆🬇🬈🬉🬊🬋🬌🬍🬎🬏🬐🬑🬒🬓🬔🬕🬖🬗🬘🬙🬚🬛🬜🬝🬞"]
pub const ncblitter_e_NCBLIT_3x2: ncblitter_e = 4;
#[doc = " 4 rows, 2 cols (braille) ⡀⡄⡆⡇⢀⣀⣄⣆⣇⢠⣠⣤⣦⣧⢰⣰⣴⣶⣷⢸⣸⣼⣾⣿"]
pub const ncblitter_e_NCBLIT_BRAILLE: ncblitter_e = 5;
#[doc = " pixel graphics"]
pub const ncblitter_e_NCBLIT_PIXEL: ncblitter_e = 6;
#[doc = " four vertical levels     █▆▄▂"]
pub const ncblitter_e_NCBLIT_4x1: ncblitter_e = 7;
#[doc = " eight vertical levels    █▇▆▅▄▃▂▁"]
pub const ncblitter_e_NCBLIT_8x1: ncblitter_e = 8;
#[doc = " we never blit full blocks, but instead spaces (more efficient) with the\n background set to the desired foreground. these need be kept in the same\n order as the blitters[] definition in lib/blit.c."]
pub type ncblitter_e = core::ffi::c_uint;
pub const ncalign_e_NCALIGN_UNALIGNED: ncalign_e = 0;
pub const ncalign_e_NCALIGN_LEFT: ncalign_e = 1;
pub const ncalign_e_NCALIGN_CENTER: ncalign_e = 2;
pub const ncalign_e_NCALIGN_RIGHT: ncalign_e = 3;
#[doc = " Alignment within a plane or terminal. Left/right-justified, or centered."]
pub type ncalign_e = core::ffi::c_uint;
pub const ncscale_e_NCSCALE_NONE: ncscale_e = 0;
pub const ncscale_e_NCSCALE_SCALE: ncscale_e = 1;
pub const ncscale_e_NCSCALE_STRETCH: ncscale_e = 2;
pub const ncscale_e_NCSCALE_NONE_HIRES: ncscale_e = 3;
pub const ncscale_e_NCSCALE_SCALE_HIRES: ncscale_e = 4;
#[doc = " How to scale an ncvisual during rendering. NCSCALE_NONE will apply no\n scaling. NCSCALE_SCALE scales a visual to the plane's size, maintaining\n aspect ratio. NCSCALE_STRETCH stretches and scales the image in an attempt\n to fill the entirety of the plane. NCSCALE_NONE_HIRES and\n NCSCALE_SCALE_HIRES behave like their counterparts, but admit blitters\n which don't preserve aspect ratio."]
pub type ncscale_e = core::ffi::c_uint;
extern "C" {
    #[doc = " Returns the number of columns occupied by the longest valid prefix of a\n multibyte (UTF-8) string. If an invalid character is encountered, -1 will be\n returned, and the number of valid bytes and columns will be written into\n *|validbytes| and *|validwidth| (assuming them non-NULL). If the entire\n string is valid, *|validbytes| and *|validwidth| reflect the entire string."]
    pub fn ncstrwidth(
        egcs: *const core::ffi::c_char,
        validbytes: *mut core::ffi::c_int,
        validwidth: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " input functions like notcurses_get() return ucs32-encoded uint32_t. convert\n a series of uint32_t to utf8. result must be at least 4 bytes per input\n uint32_t (6 bytes per uint32_t will future-proof against Unicode expansion).\n the number of bytes used is returned, or -1 if passed illegal ucs32, or too\n small of a buffer."]
    pub fn notcurses_ucs32_to_utf8(
        ucs32: *const u32,
        ucs32count: core::ffi::c_uint,
        resultbuf: *mut core::ffi::c_uchar,
        buflen: usize,
    ) -> core::ffi::c_int;
}
#[doc = " An nccell corresponds to a single character cell on some plane, which can be\n occupied by a single grapheme cluster (some root spacing glyph, along with\n possible combining characters, which might span multiple columns). At any\n cell, we can have a theoretically arbitrarily long UTF-8 EGC, a foreground\n color, a background color, and an attribute set. Valid grapheme cluster\n contents include:\n\n  * A NUL terminator,\n  * A single control character, followed by a NUL terminator,\n  * At most one spacing character, followed by zero or more nonspacing\n    characters, followed by a NUL terminator.\n\n Multi-column characters can only have a single style/color throughout.\n Existence is suffering, and thus wcwidth() is not reliable. It's just\n quoting whether or not the EGC contains a \"Wide Asian\" double-width\n character. This is set for some things, like most emoji, and not set for\n other things, like cuneiform. True display width is a *function of the\n font and terminal*. Among the longest Unicode codepoints is\n\n    U+FDFD ARABIC LIGATURE BISMILLAH AR-RAHMAN AR-RAHEEM ﷽\n\n wcwidth() rather optimistically claims this most exalted glyph to occupy\n a single column. BiDi text is too complicated for me to even get into here.\n Be assured there are no easy answers; ours is indeed a disturbing Universe.\n\n Each nccell occupies 16 static bytes (128 bits). The surface is thus ~1.6MB\n for a (pretty large) 500x200 terminal. At 80x43, it's less than 64KB.\n Dynamic requirements (the egcpool) can add up to 16MB to an ncplane, but\n such large pools are unlikely in common use.\n\n We implement some small alpha compositing. Foreground and background both\n have two bits of inverted alpha. The actual grapheme written to a cell is\n the topmost non-zero grapheme. If its alpha is 00, its foreground color is\n used unchanged. If its alpha is 10, its foreground color is derived entirely\n from cells underneath it. Otherwise, the result will be a composite.\n Likewise for the background. If the bottom of a coordinate's zbuffer is\n reached with a cumulative alpha of zero, the default is used. In this way,\n a terminal configured with transparent background can be supported through\n multiple occluding ncplanes. A foreground alpha of 11 requests high-contrast\n text (relative to the computed background). A background alpha of 11 is\n currently forbidden.\n\n Default color takes precedence over palette or RGB, and cannot be used with\n transparency. Indexed palette takes precedence over RGB. It cannot\n meaningfully set transparency, but it can be mixed into a cascading color.\n RGB is used if neither default terminal colors nor palette indexing are in\n play, and fully supports all transparency options.\n\n This structure is exposed only so that most functions can be inlined. Do not\n directly modify or access the fields of this structure; use the API."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nccell {
    #[doc = " 4B → 4B little endian EGC"]
    pub gcluster: u32,
    #[doc = " 1B → 5B (8 bits of zero)"]
    pub gcluster_backstop: u8,
    #[doc = " 1B → 6B (8 bits of EGC column width)"]
    pub width: u8,
    #[doc = " 2B → 8B (16 bits of NCSTYLE_* attributes)"]
    pub stylemask: u16,
    #[doc = " + 8B == 16B"]
    pub channels: u64,
}
extern "C" {
    #[doc = " Breaks the UTF-8 string in 'gcluster' down, setting up the nccell 'c'.\n Returns the number of bytes copied out of 'gcluster', or -1 on failure. The\n styling of the cell is left untouched, but any resources are released."]
    pub fn nccell_load(
        n: *mut ncplane,
        c: *mut nccell,
        gcluster: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Duplicate 'c' into 'targ'; both must be/will be bound to 'n'. Returns -1 on\n failure, and 0 on success."]
    pub fn nccell_duplicate(
        n: *mut ncplane,
        targ: *mut nccell,
        c: *const nccell,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Release resources held by the nccell 'c'."]
    pub fn nccell_release(n: *mut ncplane, c: *mut nccell);
}
extern "C" {
    #[doc = " return a pointer to the NUL-terminated EGC referenced by 'c'. this pointer\n can be invalidated by any further operation on the plane 'n', so...watch out!"]
    pub fn nccell_extended_gcluster(
        n: *const ncplane,
        c: *const nccell,
    ) -> *const core::ffi::c_char;
}
#[doc = " default. print nothing once fullscreen service begins"]
pub const ncloglevel_e_NCLOGLEVEL_SILENT: ncloglevel_e = -1;
#[doc = " print diagnostics related to catastrophic failure"]
pub const ncloglevel_e_NCLOGLEVEL_PANIC: ncloglevel_e = 0;
#[doc = " we're hanging around, but we've had a horrible fault"]
pub const ncloglevel_e_NCLOGLEVEL_FATAL: ncloglevel_e = 1;
#[doc = " we can't keep doing this, but we can do other things"]
pub const ncloglevel_e_NCLOGLEVEL_ERROR: ncloglevel_e = 2;
#[doc = " you probably don't want what's happening to happen"]
pub const ncloglevel_e_NCLOGLEVEL_WARNING: ncloglevel_e = 3;
#[doc = " \"standard information\""]
pub const ncloglevel_e_NCLOGLEVEL_INFO: ncloglevel_e = 4;
#[doc = " \"detailed information\""]
pub const ncloglevel_e_NCLOGLEVEL_VERBOSE: ncloglevel_e = 5;
#[doc = " this is honestly a bit much"]
pub const ncloglevel_e_NCLOGLEVEL_DEBUG: ncloglevel_e = 6;
#[doc = " there's probably a better way to do what you want"]
pub const ncloglevel_e_NCLOGLEVEL_TRACE: ncloglevel_e = 7;
#[doc = " These log levels consciously map cleanly to those of libav; Notcurses itself\n does not use this full granularity. The log level does not affect the opening\n and closing banners, which can be disabled via the notcurses_option struct's\n 'suppress_banner'. Note that if stderr is connected to the same terminal on\n which we're rendering, any kind of logging will disrupt the output (which is\n undesirable). The \"default\" zero value is NCLOGLEVEL_PANIC."]
pub type ncloglevel_e = core::ffi::c_int;
#[doc = " Configuration for notcurses_init()."]
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct notcurses_options {
    #[doc = " The name of the terminfo database entry describing this terminal. If NULL,\n the environment variable TERM is used. Failure to open the terminal\n definition will result in failure to initialize notcurses."]
    pub termtype: *const core::ffi::c_char,
    #[doc = " Progressively higher log levels result in more logging to stderr. By\n default, nothing is printed to stderr once fullscreen service begins."]
    pub loglevel: ncloglevel_e,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety\n of the screen. If the screen is too small, we do what we can--this is\n strictly best-effort. Absolute coordinates are relative to the rendering\n area ((0, 0) is always the origin of the rendering area)."]
    pub margin_t: core::ffi::c_uint,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety\n of the screen. If the screen is too small, we do what we can--this is\n strictly best-effort. Absolute coordinates are relative to the rendering\n area ((0, 0) is always the origin of the rendering area)."]
    pub margin_r: core::ffi::c_uint,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety\n of the screen. If the screen is too small, we do what we can--this is\n strictly best-effort. Absolute coordinates are relative to the rendering\n area ((0, 0) is always the origin of the rendering area)."]
    pub margin_b: core::ffi::c_uint,
    #[doc = " Desirable margins. If all are 0 (default), we will render to the entirety\n of the screen. If the screen is too small, we do what we can--this is\n strictly best-effort. Absolute coordinates are relative to the rendering\n area ((0, 0) is always the origin of the rendering area)."]
    pub margin_l: core::ffi::c_uint,
    #[doc = " General flags; see NCOPTION_*. This is expressed as a bitfield so that\n future options can be added without reshaping the struct. Undefined bits\n must be set to 0."]
    pub flags: u64,
}
impl Default for notcurses_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Lex a margin argument according to the standard Notcurses definition. There\n can be either a single number, which will define all margins equally, or\n there can be four numbers separated by commas."]
    pub fn notcurses_lex_margins(
        op: *const core::ffi::c_char,
        opts: *mut notcurses_options,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Lex a blitter."]
    pub fn notcurses_lex_blitter(
        op: *const core::ffi::c_char,
        blitter: *mut ncblitter_e,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the name of a blitter."]
    pub fn notcurses_str_blitter(blitter: ncblitter_e) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Lex a scaling mode (one of \"none\", \"stretch\", \"scale\", \"hires\",\n \"scalehi\", or \"inflate\")."]
    pub fn notcurses_lex_scalemode(
        op: *const core::ffi::c_char,
        scalemode: *mut ncscale_e,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the name of a scaling mode."]
    pub fn notcurses_str_scalemode(scalemode: ncscale_e) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Initialize a Notcurses context on the connected terminal at 'fp'. 'fp' must\n be a tty. You'll usually want stdout. NULL can be supplied for 'fp', in\n which case /dev/tty will be opened. Returns NULL on error, including any\n failure initializing terminfo."]
    pub fn notcurses_init(opts: *const notcurses_options, fp: *mut FILE) -> *mut notcurses;
}
extern "C" {
    #[doc = " The same as notcurses_init(), but without any multimedia functionality,\n allowing for a svelter binary. Link with notcurses-core if this is used."]
    pub fn notcurses_core_init(opts: *const notcurses_options, fp: *mut FILE) -> *mut notcurses;
}
extern "C" {
    #[doc = " Destroy a Notcurses context. A NULL 'nc' is a no-op."]
    pub fn notcurses_stop(nc: *mut notcurses) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Shift to the alternate screen, if available. If already using the alternate\n screen, this returns 0 immediately. If the alternate screen is not\n available, this returns -1 immediately. Entering the alternate screen turns\n off scrolling for the standard plane."]
    pub fn notcurses_enter_alternate_screen(nc: *mut notcurses) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Exit the alternate screen. Immediately returns 0 if not currently using the\n alternate screen."]
    pub fn notcurses_leave_alternate_screen(nc: *mut notcurses) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get a reference to the standard plane (one matching our current idea of the\n terminal size) for this terminal. The standard plane always exists, and its\n origin is always at the uppermost, leftmost cell of the terminal."]
    pub fn notcurses_stdplane(nc: *mut notcurses) -> *mut ncplane;
}
extern "C" {
    pub fn notcurses_stdplane_const(nc: *const notcurses) -> *const ncplane;
}
extern "C" {
    #[doc = " Return the topmost plane of the pile containing 'n'."]
    pub fn ncpile_top(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Return the bottommost plane of the pile containing 'n'."]
    pub fn ncpile_bottom(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Renders the pile of which 'n' is a part. Rendering this pile again will blow\n away the render. To actually write out the render, call ncpile_rasterize()."]
    pub fn ncpile_render(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Make the physical screen match the last rendered frame from the pile of\n which 'n' is a part. This is a blocking call. Don't call this before the\n pile has been rendered (doing so will likely result in a blank screen)."]
    pub fn ncpile_rasterize(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Perform the rendering and rasterization portion of ncpile_render() and\n ncpile_rasterize(), but do not write the resulting buffer out to the\n terminal. Using this function, the user can control the writeout process.\n The returned buffer must be freed by the caller."]
    pub fn ncpile_render_to_buffer(
        p: *mut ncplane,
        buf: *mut *mut core::ffi::c_char,
        buflen: *mut usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Write the last rendered frame, in its entirety, to 'fp'. If a frame has\n not yet been rendered, nothing will be written."]
    pub fn ncpile_render_to_file(p: *mut ncplane, fp: *mut FILE) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Destroy all ncplanes other than the stdplane."]
    pub fn notcurses_drop_planes(nc: *mut notcurses);
}
pub const ncintype_e_NCTYPE_UNKNOWN: ncintype_e = 0;
pub const ncintype_e_NCTYPE_PRESS: ncintype_e = 1;
pub const ncintype_e_NCTYPE_REPEAT: ncintype_e = 2;
pub const ncintype_e_NCTYPE_RELEASE: ncintype_e = 3;
pub type ncintype_e = core::ffi::c_uint;
#[doc = " An input event. Cell coordinates are currently defined only for mouse\n events. It is not guaranteed that we can set the modifiers for a given\n ncinput. We encompass single Unicode codepoints, not complete EGCs.\n FIXME for abi4, combine the bools into |modifiers|"]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash)]
pub struct ncinput {
    #[doc = " Unicode codepoint or synthesized NCKEY event"]
    pub id: u32,
    #[doc = " y/x cell coordinate of event, -1 for undefined"]
    pub y: core::ffi::c_int,
    #[doc = " y/x cell coordinate of event, -1 for undefined"]
    pub x: core::ffi::c_int,
    #[doc = " utf8 representation, if one exists"]
    pub utf8: [core::ffi::c_char; 5usize],
    #[doc = " was alt held?"]
    pub alt: bool,
    #[doc = " was shift held?"]
    pub shift: bool,
    #[doc = " was ctrl held?"]
    pub ctrl: bool,
    #[doc = " END DEPRECATION"]
    pub evtype: ncintype_e,
    #[doc = " bitmask over NCKEY_MOD_*"]
    pub modifiers: core::ffi::c_uint,
    #[doc = " pixel offsets within cell, -1 for undefined"]
    pub ypx: core::ffi::c_int,
    #[doc = " pixel offsets within cell, -1 for undefined"]
    pub xpx: core::ffi::c_int,
    #[doc = " Effective"]
    pub eff_text: [u32; 4usize],
}
impl Default for ncinput {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Read a UTF-32-encoded Unicode codepoint from input. This might only be part\n of a larger EGC. Provide a NULL 'ts' to block at length, and otherwise a\n timespec specifying an absolute deadline calculated using CLOCK_MONOTONIC.\n Returns a single Unicode code point, or a synthesized special key constant,\n or (uint32_t)-1 on error. Returns 0 on a timeout. If an event is processed,\n the return value is the 'id' field from that event. 'ni' may be NULL."]
    pub fn notcurses_get(n: *mut notcurses, ts: *const timespec, ni: *mut ncinput) -> u32;
}
extern "C" {
    #[doc = " Acquire up to 'vcount' ncinputs at the vector 'ni'. The number read will be\n returned, or -1 on error without any reads, 0 on timeout."]
    pub fn notcurses_getvec(
        n: *mut notcurses,
        ts: *const timespec,
        ni: *mut ncinput,
        vcount: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get a file descriptor suitable for input event poll()ing. When this\n descriptor becomes available, you can call notcurses_get_nblock(),\n and input ought be ready. This file descriptor is *not* necessarily\n the file descriptor associated with stdin (but it might be!)."]
    pub fn notcurses_inputready_fd(n: *mut notcurses) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Enable mice events according to 'eventmask'; an eventmask of 0 will disable\n all mice tracking. On failure, -1 is returned. On success, 0 is returned, and\n mouse events will be published to notcurses_get()."]
    pub fn notcurses_mice_enable(
        n: *mut notcurses,
        eventmask: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Disable signals originating from the terminal's line discipline, i.e.\n SIGINT (^C), SIGQUIT (^\\), and SIGTSTP (^Z). They are enabled by default."]
    pub fn notcurses_linesigs_disable(n: *mut notcurses) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Restore signals originating from the terminal's line discipline, i.e.\n SIGINT (^C), SIGQUIT (^\\), and SIGTSTP (^Z), if disabled."]
    pub fn notcurses_linesigs_enable(n: *mut notcurses) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Refresh the physical screen to match what was last rendered (i.e., without\n reflecting any changes since the last call to notcurses_render()). This is\n primarily useful if the screen is externally corrupted, or if an\n NCKEY_RESIZE event has been read and you're not yet ready to render. The\n current screen geometry is returned in 'y' and 'x', if they are not NULL."]
    pub fn notcurses_refresh(
        n: *mut notcurses,
        y: *mut core::ffi::c_uint,
        x: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Extract the Notcurses context to which this plane is attached."]
    pub fn ncplane_notcurses(n: *const ncplane) -> *mut notcurses;
}
extern "C" {
    pub fn ncplane_notcurses_const(n: *const ncplane) -> *const notcurses;
}
extern "C" {
    #[doc = " Return the dimensions of this ncplane. y or x may be NULL."]
    pub fn ncplane_dim_yx(n: *const ncplane, y: *mut core::ffi::c_uint, x: *mut core::ffi::c_uint);
}
extern "C" {
    #[doc = " Retrieve pixel geometry for the display region ('pxy', 'pxx'), each cell\n ('celldimy', 'celldimx'), and the maximum displayable bitmap ('maxbmapy',\n 'maxbmapx'). If bitmaps are not supported, or if there is no artificial\n limit on bitmap size, 'maxbmapy' and 'maxbmapx' will be 0. Any of the\n geometry arguments may be NULL."]
    pub fn ncplane_pixel_geom(
        n: *const ncplane,
        pxy: *mut core::ffi::c_uint,
        pxx: *mut core::ffi::c_uint,
        celldimy: *mut core::ffi::c_uint,
        celldimx: *mut core::ffi::c_uint,
        maxbmapy: *mut core::ffi::c_uint,
        maxbmapx: *mut core::ffi::c_uint,
    );
}
extern "C" {
    #[doc = " Retrieve the contents of the specified cell as last rendered. Returns the EGC\n or NULL on error. This EGC must be free()d by the caller. The stylemask and\n channels are written to 'stylemask' and 'channels', respectively."]
    pub fn notcurses_at_yx(
        nc: *mut notcurses,
        yoff: core::ffi::c_uint,
        xoff: core::ffi::c_uint,
        stylemask: *mut u16,
        channels: *mut u64,
    ) -> *mut core::ffi::c_char;
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncplane_options {
    #[doc = " vertical placement relative to parent plane"]
    pub y: core::ffi::c_int,
    #[doc = " horizontal placement relative to parent plane"]
    pub x: core::ffi::c_int,
    #[doc = " rows, must be >0 unless NCPLANE_OPTION_MARGINALIZED"]
    pub rows: core::ffi::c_uint,
    #[doc = " columns, must be >0 unless NCPLANE_OPTION_MARGINALIZED"]
    pub cols: core::ffi::c_uint,
    #[doc = " user curry, may be NULL"]
    pub userptr: *mut core::ffi::c_void,
    #[doc = " name (used only for debugging), may be NULL"]
    pub name: *const core::ffi::c_char,
    #[doc = " callback when parent is resized"]
    pub resizecb:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut ncplane) -> core::ffi::c_int>,
    #[doc = " closure over NCPLANE_OPTION_*"]
    pub flags: u64,
    #[doc = " margins (require NCPLANE_OPTION_MARGINALIZED)"]
    pub margin_b: core::ffi::c_uint,
    #[doc = " margins (require NCPLANE_OPTION_MARGINALIZED)"]
    pub margin_r: core::ffi::c_uint,
}
impl Default for ncplane_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Create a new ncplane bound to plane 'n', at the offset 'y'x'x' (relative to\n the origin of 'n') and the specified size. The number of 'rows' and 'cols'\n must both be positive. This plane is initially at the top of the z-buffer,\n as if ncplane_move_top() had been called on it. The void* 'userptr' can be\n retrieved (and reset) later. A 'name' can be set, used in debugging."]
    pub fn ncplane_create(n: *mut ncplane, nopts: *const ncplane_options) -> *mut ncplane;
}
extern "C" {
    #[doc = " Same as ncplane_create(), but creates a new pile. The returned plane will\n be the top, bottom, and root of this new pile."]
    pub fn ncpile_create(nc: *mut notcurses, nopts: *const ncplane_options) -> *mut ncplane;
}
extern "C" {
    #[doc = " resize the plane to the visual region's size (used for the standard plane)."]
    pub fn ncplane_resize_maximize(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " resize the plane to its parent's size, attempting to enforce the margins\n supplied along with NCPLANE_OPTION_MARGINALIZED."]
    pub fn ncplane_resize_marginalized(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " realign the plane 'n' against its parent, using the alignments specified\n with NCPLANE_OPTION_HORALIGNED and/or NCPLANE_OPTION_VERALIGNED."]
    pub fn ncplane_resize_realign(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " move the plane such that it is entirely within its parent, if possible.\n no resizing is performed."]
    pub fn ncplane_resize_placewithin(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Replace the ncplane's existing resizecb with 'resizecb' (which may be NULL).\n The standard plane's resizecb may not be changed."]
    pub fn ncplane_set_resizecb(
        n: *mut ncplane,
        resizecb: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut ncplane) -> core::ffi::c_int,
        >,
    );
}
extern "C" {
    #[doc = " Returns the ncplane's current resize callback."]
    pub fn ncplane_resizecb(
        n: *const ncplane,
    ) -> ::core::option::Option<unsafe extern "C" fn(n: *mut ncplane) -> core::ffi::c_int>;
}
extern "C" {
    #[doc = " Set the plane's name (may be NULL), replacing any current name."]
    pub fn ncplane_set_name(n: *mut ncplane, name: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return a heap-allocated copy of the plane's name, or NULL if it has none."]
    pub fn ncplane_name(n: *const ncplane) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Plane 'n' will be unbound from its parent plane, and will be made a bound\n child of 'newparent'. It is an error if 'n' or 'newparent' are NULL. If\n 'newparent' is equal to 'n', 'n' becomes the root of a new pile, unless 'n'\n is already the root of a pile, in which case this is a no-op. Returns 'n'.\n The standard plane cannot be reparented. Any planes bound to 'n' are\n reparented to the previous parent of 'n'."]
    pub fn ncplane_reparent(n: *mut ncplane, newparent: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " The same as ncplane_reparent(), except any planes bound to 'n' come along\n with it to its new destination. Their z-order is maintained. If 'newparent'\n is an ancestor of 'n', NULL is returned, and no changes are made."]
    pub fn ncplane_reparent_family(n: *mut ncplane, newparent: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Duplicate an existing ncplane. The new plane will have the same geometry,\n will duplicate all content, and will start with the same rendering state.\n The new plane will be immediately above the old one on the z axis, and will\n be bound to the same parent (unless 'n' is a root plane, in which case the\n new plane will be bound to it). Bound planes are *not* duplicated; the new\n plane is bound to the parent of 'n', but has no bound planes."]
    pub fn ncplane_dup(n: *const ncplane, opaque: *mut core::ffi::c_void) -> *mut ncplane;
}
extern "C" {
    #[doc = " provided a coordinate relative to the origin of 'src', map it to the same\n absolute coordinate relative to the origin of 'dst'. either or both of 'y'\n and 'x' may be NULL. if 'dst' is NULL, it is taken to be the standard plane."]
    pub fn ncplane_translate(
        src: *const ncplane,
        dst: *const ncplane,
        y: *mut core::ffi::c_int,
        x: *mut core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " Fed absolute 'y'/'x' coordinates, determine whether that coordinate is\n within the ncplane 'n'. If not, return false. If so, return true. Either\n way, translate the absolute coordinates relative to 'n'. If the point is not\n within 'n', these coordinates will not be within the dimensions of the plane."]
    pub fn ncplane_translate_abs(
        n: *const ncplane,
        y: *mut core::ffi::c_int,
        x: *mut core::ffi::c_int,
    ) -> bool;
}
extern "C" {
    #[doc = " All planes are created with scrolling disabled. Scrolling can be dynamically\n controlled with ncplane_set_scrolling(). Returns true if scrolling was\n previously enabled, or false if it was disabled."]
    pub fn ncplane_set_scrolling(n: *mut ncplane, scrollp: core::ffi::c_uint) -> bool;
}
extern "C" {
    pub fn ncplane_scrolling_p(n: *const ncplane) -> bool;
}
extern "C" {
    #[doc = " By default, planes are created with autogrow disabled. Autogrow can be\n dynamically controlled with ncplane_set_autogrow(). Returns true if\n autogrow was previously enabled, or false if it was disabled."]
    pub fn ncplane_set_autogrow(n: *mut ncplane, growp: core::ffi::c_uint) -> bool;
}
extern "C" {
    pub fn ncplane_autogrow_p(n: *const ncplane) -> bool;
}
#[doc = " Palette API. Some terminals only support 256 colors, but allow the full\n palette to be specified with arbitrary RGB colors. In all cases, it's more\n performant to use indexed colors, since it's much less data to write to the\n terminal. If you can limit yourself to 256 colors, that's probably best."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncpalette {
    #[doc = " RGB values as regular ol' channels"]
    pub chans: [u32; 256usize],
}
impl Default for ncpalette {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Create a new palette store. It will be initialized with notcurses' best\n knowledge of the currently configured palette."]
    pub fn ncpalette_new(nc: *mut notcurses) -> *mut ncpalette;
}
extern "C" {
    #[doc = " Attempt to configure the terminal with the provided palette 'p'. Does not\n transfer ownership of 'p'; ncpalette_free() can (ought) still be called."]
    pub fn ncpalette_use(nc: *mut notcurses, p: *const ncpalette) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Free the palette store 'p'."]
    pub fn ncpalette_free(p: *mut ncpalette);
}
#[doc = " Capabilities, derived from terminfo, environment variables, and queries"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nccapabilities {
    #[doc = " size of palette for indexed colors"]
    pub colors: core::ffi::c_uint,
    #[doc = " are we using utf-8 encoding? from nl_langinfo(3)"]
    pub utf8: bool,
    #[doc = " 24bit color? COLORTERM/heuristics/terminfo 'rgb'"]
    pub rgb: bool,
    #[doc = " can we change the palette? terminfo 'ccc'"]
    pub can_change_colors: bool,
    #[doc = " we assume halfblocks, but some are known to lack them"]
    pub halfblocks: bool,
    #[doc = " do we have (good, vetted) Unicode 1 quadrant support?"]
    pub quadrants: bool,
    #[doc = " do we have (good, vetted) Unicode 13 sextant support?"]
    pub sextants: bool,
    #[doc = " do we have Braille support? (linux console does not)"]
    pub braille: bool,
}
extern "C" {
    #[doc = " Returns a 16-bit bitmask of supported curses-style attributes\n (NCSTYLE_UNDERLINE, NCSTYLE_BOLD, etc.) The attribute is only\n indicated as supported if the terminal can support it together with color.\n For more information, see the \"ncv\" capability in terminfo(5)."]
    pub fn notcurses_supported_styles(nc: *const notcurses) -> u16;
}
extern "C" {
    #[doc = " Returns the number of simultaneous colors claimed to be supported, or 1 if\n there is no color support. Note that several terminal emulators advertise\n more colors than they actually support, downsampling internally."]
    pub fn notcurses_palette_size(nc: *const notcurses) -> core::ffi::c_uint;
}
extern "C" {
    #[doc = " Returns the name (and sometimes version) of the terminal, as Notcurses\n has been best able to determine."]
    pub fn notcurses_detected_terminal(nc: *const notcurses) -> *mut core::ffi::c_char;
}
extern "C" {
    pub fn notcurses_capabilities(n: *const notcurses) -> *const nccapabilities;
}
pub const ncpixelimpl_e_NCPIXEL_NONE: ncpixelimpl_e = 0;
#[doc = " sixel"]
pub const ncpixelimpl_e_NCPIXEL_SIXEL: ncpixelimpl_e = 1;
#[doc = " linux framebuffer"]
pub const ncpixelimpl_e_NCPIXEL_LINUXFB: ncpixelimpl_e = 2;
#[doc = " iTerm2"]
pub const ncpixelimpl_e_NCPIXEL_ITERM2: ncpixelimpl_e = 3;
#[doc = " C=1 (disabling scrolling) was only introduced in 0.20.0, at the same\n time as animation. prior to this, graphics had to be entirely redrawn\n on any change, and it wasn't possible to use the bottom line."]
pub const ncpixelimpl_e_NCPIXEL_KITTY_STATIC: ncpixelimpl_e = 4;
#[doc = " until 0.22.0's introduction of 'a=c' for self-referential composition, we\n had to keep a complete copy of the RGBA data, in case a wiped cell needed\n to be rebuilt. we'd otherwise have to unpack the glyph and store it into\n the auxvec on the fly."]
pub const ncpixelimpl_e_NCPIXEL_KITTY_ANIMATED: ncpixelimpl_e = 5;
#[doc = " with 0.22.0, we only ever write transparent cells after writing the\n original image (which we now deflate, since we needn't unpack it later).\n the only data we need keep is the auxvecs."]
pub const ncpixelimpl_e_NCPIXEL_KITTY_SELFREF: ncpixelimpl_e = 6;
#[doc = " pixel blitting implementations. informative only; don't special-case\n based off any of this information!"]
pub type ncpixelimpl_e = core::ffi::c_uint;
extern "C" {
    #[doc = " Can we blit pixel-accurate bitmaps?"]
    pub fn notcurses_check_pixel_support(nc: *const notcurses) -> ncpixelimpl_e;
}
extern "C" {
    #[doc = " Can we load images? This requires being built against FFmpeg/OIIO."]
    pub fn notcurses_canopen_images(nc: *const notcurses) -> bool;
}
extern "C" {
    #[doc = " Can we load videos? This requires being built against FFmpeg."]
    pub fn notcurses_canopen_videos(nc: *const notcurses) -> bool;
}
#[doc = " whenever a new field is added here, ensure we add the proper rule to\n notcurses_stats_reset(), so that values are preserved in the stash stats."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncstats {
    #[doc = " successful ncpile_render() runs"]
    pub renders: u64,
    #[doc = " successful ncpile_rasterize() runs"]
    pub writeouts: u64,
    #[doc = " aborted renders, should be 0"]
    pub failed_renders: u64,
    #[doc = " aborted writes"]
    pub failed_writeouts: u64,
    #[doc = " bytes emitted to ttyfp"]
    pub raster_bytes: u64,
    #[doc = " max bytes emitted for a frame"]
    pub raster_max_bytes: i64,
    #[doc = " min bytes emitted for a frame"]
    pub raster_min_bytes: i64,
    #[doc = " nanoseconds spent rendering"]
    pub render_ns: u64,
    #[doc = " max ns spent in render for a frame"]
    pub render_max_ns: i64,
    #[doc = " min ns spent in render for a frame"]
    pub render_min_ns: i64,
    #[doc = " nanoseconds spent rasterizing"]
    pub raster_ns: u64,
    #[doc = " max ns spent in raster for a frame"]
    pub raster_max_ns: i64,
    #[doc = " min ns spent in raster for a frame"]
    pub raster_min_ns: i64,
    #[doc = " nanoseconds spent writing frames to terminal"]
    pub writeout_ns: u64,
    #[doc = " max ns spent writing out a frame"]
    pub writeout_max_ns: i64,
    #[doc = " min ns spent writing out a frame"]
    pub writeout_min_ns: i64,
    #[doc = " cells we elided entirely thanks to damage maps"]
    pub cellelisions: u64,
    #[doc = " total number of cells emitted to terminal"]
    pub cellemissions: u64,
    #[doc = " RGB fg elision count"]
    pub fgelisions: u64,
    #[doc = " RGB fg emissions"]
    pub fgemissions: u64,
    #[doc = " RGB bg elision count"]
    pub bgelisions: u64,
    #[doc = " RGB bg emissions"]
    pub bgemissions: u64,
    #[doc = " default color was emitted"]
    pub defaultelisions: u64,
    #[doc = " default color was elided"]
    pub defaultemissions: u64,
    #[doc = " refresh requests (non-optimized redraw)"]
    pub refreshes: u64,
    #[doc = " sprixel draw count"]
    pub sprixelemissions: u64,
    #[doc = " sprixel elision count"]
    pub sprixelelisions: u64,
    #[doc = " sprixel bytes emitted"]
    pub sprixelbytes: u64,
    #[doc = " how many application-synchronized updates?"]
    pub appsync_updates: u64,
    #[doc = " errors processing control sequences/utf8"]
    pub input_errors: u64,
    #[doc = " characters returned to userspace"]
    pub input_events: u64,
    #[doc = " unnecessary hpas issued"]
    pub hpa_gratuitous: u64,
    #[doc = " cell geometry changes (resizes)"]
    pub cell_geo_changes: u64,
    #[doc = " pixel geometry changes (font resize)"]
    pub pixel_geo_changes: u64,
    #[doc = " total bytes devoted to all active framebuffers"]
    pub fbbytes: u64,
    #[doc = " number of planes currently in existence"]
    pub planes: core::ffi::c_uint,
}
extern "C" {
    #[doc = " Allocate an ncstats object. Use this rather than allocating your own, since\n future versions of Notcurses might enlarge this structure."]
    pub fn notcurses_stats_alloc(nc: *const notcurses) -> *mut ncstats;
}
extern "C" {
    #[doc = " Acquire an atomic snapshot of the Notcurses object's stats."]
    pub fn notcurses_stats(nc: *mut notcurses, stats: *mut ncstats);
}
extern "C" {
    #[doc = " Reset all cumulative stats (immediate ones, such as fbbytes, are not reset),\n first copying them into |*stats| (if |stats| is not NULL)."]
    pub fn notcurses_stats_reset(nc: *mut notcurses, stats: *mut ncstats);
}
extern "C" {
    #[doc = " Resize the specified ncplane. The four parameters 'keepy', 'keepx',\n 'keepleny', and 'keeplenx' define a subset of the ncplane to keep,\n unchanged. This may be a region of size 0, though none of these four\n parameters may be negative. 'keepx' and 'keepy' are relative to the ncplane.\n They must specify a coordinate within the ncplane's totality. 'yoff' and\n 'xoff' are relative to 'keepy' and 'keepx', and place the upper-left corner\n of the resized ncplane. Finally, 'ylen' and 'xlen' are the dimensions of the\n ncplane after resizing. 'ylen' must be greater than or equal to 'keepleny',\n and 'xlen' must be greater than or equal to 'keeplenx'. It is an error to\n attempt to resize the standard plane. If either of 'keepleny' or 'keeplenx'\n is non-zero, both must be non-zero.\n\n Essentially, the kept material does not move. It serves to anchor the\n resized plane. If there is no kept material, the plane can move freely."]
    pub fn ncplane_resize(
        n: *mut ncplane,
        keepy: core::ffi::c_int,
        keepx: core::ffi::c_int,
        keepleny: core::ffi::c_uint,
        keeplenx: core::ffi::c_uint,
        yoff: core::ffi::c_int,
        xoff: core::ffi::c_int,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Destroy the specified ncplane. None of its contents will be visible after\n the next call to notcurses_render(). It is an error to attempt to destroy\n the standard plane."]
    pub fn ncplane_destroy(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the ncplane's base nccell to 'c'. The base cell is used for purposes of\n rendering anywhere that the ncplane's gcluster is 0. Note that the base cell\n is not affected by ncplane_erase(). 'c' must not be a secondary cell from a\n multicolumn EGC."]
    pub fn ncplane_set_base_cell(n: *mut ncplane, c: *const nccell) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the ncplane's base nccell. It will be used for purposes of rendering\n anywhere that the ncplane's gcluster is 0. Note that the base cell is not\n affected by ncplane_erase(). 'egc' must be an extended grapheme cluster.\n Returns the number of bytes copied out of 'gcluster', or -1 on failure."]
    pub fn ncplane_set_base(
        n: *mut ncplane,
        egc: *const core::ffi::c_char,
        stylemask: u16,
        channels: u64,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Extract the ncplane's base nccell into 'c'. The reference is invalidated if\n 'ncp' is destroyed."]
    pub fn ncplane_base(n: *mut ncplane, c: *mut nccell) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the origin of plane 'n' relative to its bound plane, or pile (if 'n' is\n a root plane). To get absolute coordinates, use ncplane_abs_yx()."]
    pub fn ncplane_yx(n: *const ncplane, y: *mut core::ffi::c_int, x: *mut core::ffi::c_int);
}
extern "C" {
    pub fn ncplane_y(n: *const ncplane) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_x(n: *const ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Move this plane relative to the standard plane, or the plane to which it is\n bound (if it is bound to a plane). It is an error to attempt to move the\n standard plane."]
    pub fn ncplane_move_yx(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the origin of plane 'n' relative to its pile. Either or both of 'x' and\n 'y' may be NULL."]
    pub fn ncplane_abs_yx(n: *const ncplane, y: *mut core::ffi::c_int, x: *mut core::ffi::c_int);
}
extern "C" {
    pub fn ncplane_abs_y(n: *const ncplane) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_abs_x(n: *const ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the plane to which the plane 'n' is bound, if any."]
    pub fn ncplane_parent(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    pub fn ncplane_parent_const(n: *const ncplane) -> *const ncplane;
}
extern "C" {
    #[doc = " Splice ncplane 'n' out of the z-buffer, and reinsert it above 'above'.\n Returns non-zero if 'n' is already in the desired location. 'n' and\n 'above' must not be the same plane. If 'above' is NULL, 'n' is moved\n to the bottom of its pile."]
    pub fn ncplane_move_above(n: *mut ncplane, above: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Splice ncplane 'n' out of the z-buffer, and reinsert it below 'below'.\n Returns non-zero if 'n' is already in the desired location. 'n' and\n 'below' must not be the same plane. If 'below' is NULL, 'n' is moved to\n the top of its pile."]
    pub fn ncplane_move_below(n: *mut ncplane, below: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Splice ncplane 'n' and its bound planes out of the z-buffer, and reinsert\n them above or below 'targ'. Relative order will be maintained between the\n reinserted planes. For a plane E bound to C, with z-ordering A B C D E,\n moving the C family to the top results in C E A B D, while moving it to\n the bottom results in A B D C E."]
    pub fn ncplane_move_family_above(n: *mut ncplane, targ: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_move_family_below(n: *mut ncplane, targ: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return the plane below this one, or NULL if this is at the bottom."]
    pub fn ncplane_below(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Return the plane above this one, or NULL if this is at the top."]
    pub fn ncplane_above(n: *mut ncplane) -> *mut ncplane;
}
extern "C" {
    #[doc = " Effect |r| scroll events on the plane |n|. Returns an error if |n| is not\n a scrolling plane, and otherwise returns the number of lines scrolled."]
    pub fn ncplane_scrollup(n: *mut ncplane, r: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Scroll |n| up until |child| is no longer hidden beneath it. Returns an\n error if |child| is not a child of |n|, or |n| is not scrolling, or |child|\n is fixed. Returns the number of scrolling events otherwise (might be 0).\n If the child plane is not fixed, it will likely scroll as well."]
    pub fn ncplane_scrollup_child(n: *mut ncplane, child: *const ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Rotate the plane π/2 radians clockwise or counterclockwise. This cannot\n be performed on arbitrary planes, because glyphs cannot be arbitrarily\n rotated. The glyphs which can be rotated are limited: line-drawing\n characters, spaces, half blocks, and full blocks. The plane must have\n an even number of columns. Use the ncvisual rotation for a more\n flexible approach."]
    pub fn ncplane_rotate_cw(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_rotate_ccw(n: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Retrieve the current contents of the cell under the cursor. The EGC is\n returned, or NULL on error. This EGC must be free()d by the caller. The\n stylemask and channels are written to 'stylemask' and 'channels', respectively."]
    pub fn ncplane_at_cursor(
        n: *const ncplane,
        stylemask: *mut u16,
        channels: *mut u64,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Retrieve the current contents of the cell under the cursor into 'c'. This\n cell is invalidated if the associated plane is destroyed. Returns the number\n of bytes in the EGC, or -1 on error."]
    pub fn ncplane_at_cursor_cell(n: *mut ncplane, c: *mut nccell) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Retrieve the current contents of the specified cell. The EGC is returned, or\n NULL on error. This EGC must be free()d by the caller. The stylemask and\n channels are written to 'stylemask' and 'channels', respectively. The return\n represents how the cell will be used during rendering, and thus integrates\n any base cell where appropriate. If called upon the secondary columns of a\n wide glyph, the EGC will be returned (i.e. this function does not distinguish\n between the primary and secondary columns of a wide glyph). If called on a\n sprixel plane, its control sequence is returned for all valid locations."]
    pub fn ncplane_at_yx(
        n: *const ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        stylemask: *mut u16,
        channels: *mut u64,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Retrieve the current contents of the specified cell into 'c'. This cell is\n invalidated if the associated plane is destroyed. Returns the number of\n bytes in the EGC, or -1 on error. Unlike ncplane_at_yx(), when called upon\n the secondary columns of a wide glyph, the return can be distinguished from\n the primary column (nccell_wide_right_p(c) will return true). It is an\n error to call this on a sprixel plane (unlike ncplane_at_yx())."]
    pub fn ncplane_at_yx_cell(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        c: *mut nccell,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Create a flat string from the EGCs of the selected region of the ncplane\n 'n'. Start at the plane's 'begy'x'begx' coordinate (which must lie on the\n plane), continuing for 'leny'x'lenx' cells. Either or both of 'leny' and\n 'lenx' can be specified as 0 to go through the boundary of the plane.\n -1 can be specified for 'begx'/'begy' to use the current cursor location."]
    pub fn ncplane_contents(
        n: *mut ncplane,
        begy: core::ffi::c_int,
        begx: core::ffi::c_int,
        leny: core::ffi::c_uint,
        lenx: core::ffi::c_uint,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Manipulate the opaque user pointer associated with this plane.\n ncplane_set_userptr() returns the previous userptr after replacing\n it with 'opaque'. the others simply return the userptr."]
    pub fn ncplane_set_userptr(
        n: *mut ncplane,
        opaque: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    pub fn ncplane_userptr(n: *mut ncplane) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Find the center coordinate of a plane, preferring the top/left in the\n case of an even number of rows/columns (in such a case, there will be one\n more cell to the bottom/right of the center than the top/left). The\n center is then modified relative to the plane's origin."]
    pub fn ncplane_center_abs(
        n: *const ncplane,
        y: *mut core::ffi::c_int,
        x: *mut core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " Create an RGBA flat array from the selected region of the ncplane 'nc'.\n Start at the plane's 'begy'x'begx' coordinate (which must lie on the\n plane), continuing for 'leny'x'lenx' cells. Either or both of 'leny' and\n 'lenx' can be specified as 0 to go through the boundary of the plane.\n Only glyphs from the specified ncblitset may be present. If 'pxdimy' and/or\n 'pxdimx' are non-NULL, they will be filled in with the total pixel geometry."]
    pub fn ncplane_as_rgba(
        n: *const ncplane,
        blit: ncblitter_e,
        begy: core::ffi::c_int,
        begx: core::ffi::c_int,
        leny: core::ffi::c_uint,
        lenx: core::ffi::c_uint,
        pxdimy: *mut core::ffi::c_uint,
        pxdimx: *mut core::ffi::c_uint,
    ) -> *mut u32;
}
extern "C" {
    #[doc = " Move the cursor to the specified position (the cursor needn't be visible).\n Pass -1 as either coordinate to hold that axis constant. Returns -1 if the\n move would place the cursor outside the plane."]
    pub fn ncplane_cursor_move_yx(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Move the cursor relative to the current cursor position (the cursor needn't\n be visible). Returns -1 on error, including target position exceeding the\n plane's dimensions."]
    pub fn ncplane_cursor_move_rel(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Move the cursor to 0, 0. Can't fail."]
    pub fn ncplane_home(n: *mut ncplane);
}
extern "C" {
    #[doc = " Get the current position of the cursor within n. y and/or x may be NULL."]
    pub fn ncplane_cursor_yx(
        n: *const ncplane,
        y: *mut core::ffi::c_uint,
        x: *mut core::ffi::c_uint,
    );
}
extern "C" {
    #[doc = " Get the current colors and alpha values for ncplane 'n'."]
    pub fn ncplane_channels(n: *const ncplane) -> u64;
}
extern "C" {
    #[doc = " Get the current styling for the ncplane 'n'."]
    pub fn ncplane_styles(n: *const ncplane) -> u16;
}
extern "C" {
    #[doc = " Replace the cell at the specified coordinates with the provided cell 'c',\n and advance the cursor by the width of the cell (but not past the end of the\n plane). On success, returns the number of columns the cursor was advanced.\n 'c' must already be associated with 'n'. On failure, -1 is returned."]
    pub fn ncplane_putc_yx(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        c: *const nccell,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Replace the EGC underneath us, but retain the styling. The current styling\n of the plane will not be changed."]
    pub fn ncplane_putchar_stained(n: *mut ncplane, c: core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Replace the cell at the specified coordinates with the provided EGC, and\n advance the cursor by the width of the cluster (but not past the end of the\n plane). On success, returns the number of columns the cursor was advanced.\n On failure, -1 is returned. The number of bytes converted from gclust is\n written to 'sbytes' if non-NULL."]
    pub fn ncplane_putegc_yx(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        gclust: *const core::ffi::c_char,
        sbytes: *mut usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Replace the EGC underneath us, but retain the styling. The current styling\n of the plane will not be changed."]
    pub fn ncplane_putegc_stained(
        n: *mut ncplane,
        gclust: *const core::ffi::c_char,
        sbytes: *mut usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Replace the EGC underneath us, but retain the styling. The current styling\n of the plane will not be changed."]
    pub fn ncplane_putwegc_stained(
        n: *mut ncplane,
        gclust: *const wchar_t,
        sbytes: *mut usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_putnstr_aligned(
        n: *mut ncplane,
        y: core::ffi::c_int,
        align: ncalign_e,
        s: usize,
        str_: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_putwstr_stained(n: *mut ncplane, gclustarr: *const wchar_t) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " The ncplane equivalents of printf(3) and vprintf(3)."]
    pub fn ncplane_vprintf_aligned(
        n: *mut ncplane,
        y: core::ffi::c_int,
        align: ncalign_e,
        format: *const core::ffi::c_char,
        ap: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_vprintf_yx(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        format: *const core::ffi::c_char,
        ap: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_vprintf_stained(
        n: *mut ncplane,
        format: *const core::ffi::c_char,
        ap: *mut __va_list_tag,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Write the specified text to the plane, breaking lines sensibly, beginning at\n the specified line. Returns the number of columns written. When breaking a\n line, the line will be cleared to the end of the plane (the last line will\n *not* be so cleared). The number of bytes written from the input is written\n to '*bytes' if it is not NULL. Cleared columns are included in the return\n value, but *not* included in the number of bytes written. Leaves the cursor\n at the end of output. A partial write will be accomplished as far as it can;\n determine whether the write completed by inspecting '*bytes'. Can output to\n multiple rows even in the absence of scrolling, but not more rows than are\n available. With scrolling enabled, arbitrary amounts of data can be emitted.\n All provided whitespace is preserved -- ncplane_puttext() followed by an\n appropriate ncplane_contents() will read back the original output.\n\n If 'y' is -1, the first row of output is taken relative to the current\n cursor: it will be left-, right-, or center-aligned in whatever remains\n of the row. On subsequent rows -- or if 'y' is not -1 -- the entire row can\n be used, and alignment works normally.\n\n A newline at any point will move the cursor to the next row."]
    pub fn ncplane_puttext(
        n: *mut ncplane,
        y: core::ffi::c_int,
        align: ncalign_e,
        text: *const core::ffi::c_char,
        bytes: *mut usize,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Draw horizontal or vertical lines using the specified cell, starting at the\n current cursor position. The cursor will end at the cell following the last\n cell output (even, perhaps counter-intuitively, when drawing vertical\n lines), just as if ncplane_putc() was called at that spot. Return the\n number of cells drawn on success. On error, return the negative number of\n cells drawn. A length of 0 is an error, resulting in a return of -1."]
    pub fn ncplane_hline_interp(
        n: *mut ncplane,
        c: *const nccell,
        len: core::ffi::c_uint,
        c1: u64,
        c2: u64,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_vline_interp(
        n: *mut ncplane,
        c: *const nccell,
        len: core::ffi::c_uint,
        c1: u64,
        c2: u64,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Draw a box with its upper-left corner at the current cursor position, and its\n lower-right corner at 'ystop'x'xstop'. The 6 cells provided are used to draw the\n upper-left, ur, ll, and lr corners, then the horizontal and vertical lines.\n 'ctlword' is defined in the least significant byte, where bits [7, 4] are a\n gradient mask, and [3, 0] are a border mask:\n  * 7, 3: top\n  * 6, 2: right\n  * 5, 1: bottom\n  * 4, 0: left\n If the gradient bit is not set, the styling from the hl/vl cells is used for\n the horizontal and vertical lines, respectively. If the gradient bit is set,\n the color is linearly interpolated between the two relevant corner cells.\n\n By default, vertexes are drawn whether their connecting edges are drawn or\n not. The value of the bits corresponding to NCBOXCORNER_MASK control this,\n and are interpreted as the number of connecting edges necessary to draw a\n given corner. At 0 (the default), corners are always drawn. At 3, corners\n are never drawn (since at most 2 edges can touch a box's corner)."]
    pub fn ncplane_box(
        n: *mut ncplane,
        ul: *const nccell,
        ur: *const nccell,
        ll: *const nccell,
        lr: *const nccell,
        hline: *const nccell,
        vline: *const nccell,
        ystop: core::ffi::c_uint,
        xstop: core::ffi::c_uint,
        ctlword: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Starting at the specified coordinate, if its glyph is different from that of\n 'c', 'c' is copied into it, and the original glyph is considered the fill\n target. We do the same to all cardinally-connected cells having this same\n fill target. Returns the number of cells polyfilled. An invalid initial y, x\n is an error. Returns the number of cells filled, or -1 on error."]
    pub fn ncplane_polyfill_yx(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        c: *const nccell,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Draw a gradient with its upper-left corner at the position specified by 'y'/'x',\n where -1 means the current cursor position in that dimension. The area is\n specified by 'ylen'/'xlen', where 0 means \"everything remaining below or\n to the right, respectively.\" The glyph composed of 'egc' and 'styles' is\n used for all cells. The channels specified by 'ul', 'ur', 'll', and 'lr'\n are composed into foreground and background gradients. To do a vertical\n gradient, 'ul' ought equal 'ur' and 'll' ought equal 'lr'. To do a\n horizontal gradient, 'ul' ought equal 'll' and 'ur' ought equal 'ul'. To\n color everything the same, all four channels should be equivalent. The\n resulting alpha values are equal to incoming alpha values. Returns the\n number of cells filled on success, or -1 on failure.\n Palette-indexed color is not supported.\n\n Preconditions for gradient operations (error otherwise):\n\n  all: only RGB colors, unless all four channels match as default\n  all: all alpha values must be the same\n  1x1: all four colors must be the same\n  1xN: both top and both bottom colors must be the same (vertical gradient)\n  Nx1: both left and both right colors must be the same (horizontal gradient)"]
    pub fn ncplane_gradient(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
        egc: *const core::ffi::c_char,
        styles: u16,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Do a high-resolution gradient using upper blocks and synced backgrounds.\n This doubles the number of vertical gradations, but restricts you to\n half blocks (appearing to be full blocks). Returns the number of cells\n filled on success, or -1 on error."]
    pub fn ncplane_gradient2x1(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
        ul: u32,
        ur: u32,
        ll: u32,
        lr: u32,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the given style throughout the specified region, keeping content and\n channels unchanged. The upper left corner is at 'y', 'x', and -1 may be\n specified to indicate the cursor's position in that dimension. The area\n is specified by 'ylen', 'xlen', and 0 may be specified to indicate everything\n remaining to the right and below, respectively. It is an error for any\n coordinate to be outside the plane. Returns the number of cells set,\n or -1 on failure."]
    pub fn ncplane_format(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
        stylemask: u16,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the given channels throughout the specified region, keeping content and\n channels unchanged. The upper left corner is at 'y', 'x', and -1 may be\n specified to indicate the cursor's position in that dimension. The area\n is specified by 'ylen', 'xlen', and 0 may be specified to indicate everything\n remaining to the right and below, respectively. It is an error for any\n coordinate to be outside the plane. Returns the number of cells set,\n or -1 on failure."]
    pub fn ncplane_stain(
        n: *mut ncplane,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Merge the entirety of 'src' down onto the ncplane 'dst'. If 'src' does not\n intersect with 'dst', 'dst' will not be changed, but it is not an error."]
    pub fn ncplane_mergedown_simple(src: *mut ncplane, dst: *mut ncplane) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Merge the ncplane 'src' down onto the ncplane 'dst'. This is most rigorously\n defined as \"write to 'dst' the frame that would be rendered were the entire\n stack made up only of the specified subregion of 'src' and, below it, the\n subregion of 'dst' having the specified origin. Supply -1 to indicate the\n current cursor position in the relevant dimension. Merging is independent of\n the position of 'src' viz 'dst' on the z-axis. It is an error to define a\n subregion that is not entirely contained within 'src'. It is an error to\n define a target origin such that the projected subregion is not entirely\n contained within 'dst'.  Behavior is undefined if 'src' and 'dst' are\n equivalent. 'dst' is modified, but 'src' remains unchanged. Neither 'src'\n nor 'dst' may have sprixels. Lengths of 0 mean \"everything left\"."]
    pub fn ncplane_mergedown(
        src: *mut ncplane,
        dst: *mut ncplane,
        begsrcy: core::ffi::c_int,
        begsrcx: core::ffi::c_int,
        leny: core::ffi::c_uint,
        lenx: core::ffi::c_uint,
        dsty: core::ffi::c_int,
        dstx: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Erase every cell in the ncplane (each cell is initialized to the null glyph\n and the default channels/styles). All cells associated with this ncplane are\n invalidated, and must not be used after the call, *excluding* the base cell.\n The cursor is homed. The plane's active attributes are unaffected."]
    pub fn ncplane_erase(n: *mut ncplane);
}
extern "C" {
    #[doc = " Erase every cell in the region starting at {ystart, xstart} and having size\n {|ylen|x|xlen|} for non-zero lengths. If ystart and/or xstart are -1, the current\n cursor position along that axis is used; other negative values are an error. A\n negative ylen means to move up from the origin, and a negative xlen means to move\n left from the origin. A positive ylen moves down, and a positive xlen moves right.\n A value of 0 for the length erases everything along that dimension. It is an error\n if the starting coordinate is not in the plane, but the ending coordinate may be\n outside the plane.\n\n For example, on a plane of 20 rows and 10 columns, with the cursor at row 10 and\n column 5, the following would hold:\n\n  (-1, -1, 0, 1): clears the column to the right of the cursor (column 6)\n  (-1, -1, 0, -1): clears the column to the left of the cursor (column 4)\n  (-1, -1, INT_MAX, 0): clears all rows with or below the cursor (rows 10--19)\n  (-1, -1, -INT_MAX, 0): clears all rows with or above the cursor (rows 0--10)\n  (-1, 4, 3, 3): clears from row 5, column 4 through row 7, column 6\n  (-1, 4, -3, -3): clears from row 5, column 4 through row 3, column 2\n  (4, -1, 0, 3): clears columns 5, 6, and 7\n  (-1, -1, 0, 0): clears the plane *if the cursor is in a legal position*\n  (0, 0, 0, 0): clears the plane in all cases"]
    pub fn ncplane_erase_region(
        n: *mut ncplane,
        ystart: core::ffi::c_int,
        xstart: core::ffi::c_int,
        ylen: core::ffi::c_int,
        xlen: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the alpha and coloring bits of the plane's current channels from a\n 64-bit pair of channels."]
    pub fn ncplane_set_channels(n: *mut ncplane, channels: u64);
}
extern "C" {
    #[doc = " Set the background alpha and coloring bits of the plane's current\n channels from a single 32-bit value."]
    pub fn ncplane_set_bchannel(n: *mut ncplane, channel: u32) -> u64;
}
extern "C" {
    #[doc = " Set the foreground alpha and coloring bits of the plane's current\n channels from a single 32-bit value."]
    pub fn ncplane_set_fchannel(n: *mut ncplane, channel: u32) -> u64;
}
extern "C" {
    #[doc = " Set the specified style bits for the ncplane 'n', whether they're actively\n supported or not."]
    pub fn ncplane_set_styles(n: *mut ncplane, stylebits: core::ffi::c_uint);
}
extern "C" {
    #[doc = " Add the specified styles to the ncplane's existing spec."]
    pub fn ncplane_on_styles(n: *mut ncplane, stylebits: core::ffi::c_uint);
}
extern "C" {
    #[doc = " Remove the specified styles from the ncplane's existing spec."]
    pub fn ncplane_off_styles(n: *mut ncplane, stylebits: core::ffi::c_uint);
}
extern "C" {
    #[doc = " Set the current fore/background color using RGB specifications. If the\n terminal does not support directly-specified 3x8b cells (24-bit \"TrueColor\",\n indicated by the \"RGB\" terminfo capability), the provided values will be\n interpreted in some lossy fashion. None of r, g, or b may exceed 255.\n \"HP-like\" terminals require setting foreground and background at the same\n time using \"color pairs\"; Notcurses will manage color pairs transparently."]
    pub fn ncplane_set_fg_rgb8(
        n: *mut ncplane,
        r: core::ffi::c_uint,
        g: core::ffi::c_uint,
        b: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_rgb8(
        n: *mut ncplane,
        r: core::ffi::c_uint,
        g: core::ffi::c_uint,
        b: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Same, but clipped to [0..255]."]
    pub fn ncplane_set_bg_rgb8_clipped(
        n: *mut ncplane,
        r: core::ffi::c_int,
        g: core::ffi::c_int,
        b: core::ffi::c_int,
    );
}
extern "C" {
    pub fn ncplane_set_fg_rgb8_clipped(
        n: *mut ncplane,
        r: core::ffi::c_int,
        g: core::ffi::c_int,
        b: core::ffi::c_int,
    );
}
extern "C" {
    #[doc = " Same, but with rgb assembled into a channel (i.e. lower 24 bits)."]
    pub fn ncplane_set_fg_rgb(n: *mut ncplane, channel: u32) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_rgb(n: *mut ncplane, channel: u32) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Use the default color for the foreground/background."]
    pub fn ncplane_set_fg_default(n: *mut ncplane);
}
extern "C" {
    pub fn ncplane_set_bg_default(n: *mut ncplane);
}
extern "C" {
    #[doc = " Set the ncplane's foreground palette index, set the foreground palette index\n bit, set it foreground-opaque, and clear the foreground default color bit."]
    pub fn ncplane_set_fg_palindex(n: *mut ncplane, idx: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_palindex(n: *mut ncplane, idx: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the alpha parameters for ncplane 'n'."]
    pub fn ncplane_set_fg_alpha(n: *mut ncplane, alpha: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncplane_set_bg_alpha(n: *mut ncplane, alpha: core::ffi::c_int) -> core::ffi::c_int;
}
#[doc = " Called for each fade iteration on 'ncp'. If anything but 0 is returned,\n the fading operation ceases immediately, and that value is propagated out.\n The recommended absolute display time target is passed in 'tspec'."]
pub type fadecb = ::core::option::Option<
    unsafe extern "C" fn(
        nc: *mut notcurses,
        n: *mut ncplane,
        arg1: *const timespec,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
extern "C" {
    #[doc = " Fade the ncplane out over the provided time, calling 'fader' at each\n iteration. Requires a terminal which supports truecolor, or at least palette\n modification (if the terminal uses a palette, our ability to fade planes is\n limited, and affected by the complexity of the rest of the screen)."]
    pub fn ncplane_fadeout(
        n: *mut ncplane,
        ts: *const timespec,
        fader: fadecb,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Fade the ncplane in over the specified time. Load the ncplane with the\n target cells without rendering, then call this function. When it's done, the\n ncplane will have reached the target levels, starting from zeroes."]
    pub fn ncplane_fadein(
        n: *mut ncplane,
        ts: *const timespec,
        fader: fadecb,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Rather than the simple ncplane_fade{in/out}(), ncfadectx_setup() can be\n paired with a loop over ncplane_fade{in/out}_iteration() + ncfadectx_free()."]
    pub fn ncfadectx_setup(n: *mut ncplane) -> *mut ncfadectx;
}
extern "C" {
    #[doc = " Return the number of iterations through which 'nctx' will fade."]
    pub fn ncfadectx_iterations(nctx: *const ncfadectx) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Fade out through 'iter' iterations, where\n 'iter' < 'ncfadectx_iterations(nctx)'."]
    pub fn ncplane_fadeout_iteration(
        n: *mut ncplane,
        nctx: *mut ncfadectx,
        iter: core::ffi::c_int,
        fader: fadecb,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Fade in through 'iter' iterations, where\n 'iter' < 'ncfadectx_iterations(nctx)'."]
    pub fn ncplane_fadein_iteration(
        n: *mut ncplane,
        nctx: *mut ncfadectx,
        iter: core::ffi::c_int,
        fader: fadecb,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Pulse the plane in and out until the callback returns non-zero, relying on\n the callback 'fader' to initiate rendering. 'ts' defines the half-period\n (i.e. the transition from black to full brightness, or back again). Proper\n use involves preparing (but not rendering) an ncplane, then calling\n ncplane_pulse(), which will fade in from black to the specified colors."]
    pub fn ncplane_pulse(
        n: *mut ncplane,
        ts: *const timespec,
        fader: fadecb,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Release the resources associated with 'nctx'."]
    pub fn ncfadectx_free(nctx: *mut ncfadectx);
}
extern "C" {
    #[doc = " Open a visual at 'file', extract a codec and parameters, decode the first\n image to memory."]
    pub fn ncvisual_from_file(file: *const core::ffi::c_char) -> *mut ncvisual;
}
extern "C" {
    #[doc = " Prepare an ncvisual, and its underlying plane, based off RGBA content in\n memory at 'rgba'. 'rgba' is laid out as 'rows' lines, each of which is\n 'rowstride' bytes in length. Each line has 'cols' 32-bit 8bpc RGBA pixels\n followed by possible padding (there will be 'rowstride' - 'cols' * 4 bytes\n of padding). The total size of 'rgba' is thus ('rows' * 'rowstride') bytes,\n of which ('rows' * 'cols' * 4) bytes are actual non-padding data. It is an\n error if any argument is not positive, if 'rowstride' is not a multiple of\n 4, or if 'rowstride' is less than 'cols' * 4."]
    pub fn ncvisual_from_rgba(
        rgba: *const core::ffi::c_void,
        rows: core::ffi::c_int,
        rowstride: core::ffi::c_int,
        cols: core::ffi::c_int,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " ncvisual_from_rgba(), but the pixels are 3-byte RGB. A is filled in\n throughout using 'alpha'. It is an error if 'rows', 'rowstride', or 'cols'\n is not positive, if 'rowstride' is not a multiple of 3, or if 'rowstride'\n is less than 'cols' * 3."]
    pub fn ncvisual_from_rgb_packed(
        rgba: *const core::ffi::c_void,
        rows: core::ffi::c_int,
        rowstride: core::ffi::c_int,
        cols: core::ffi::c_int,
        alpha: core::ffi::c_int,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " ncvisual_from_rgba(), but the pixels are 4-byte RGBx. A is filled in\n throughout using 'alpha'. It is an error if 'rows', 'cols', or 'rowstride'\n are not positive, if 'rowstride' is not a multiple of 4, or if 'rowstride'\n is less than 'cols' * 4."]
    pub fn ncvisual_from_rgb_loose(
        rgba: *const core::ffi::c_void,
        rows: core::ffi::c_int,
        rowstride: core::ffi::c_int,
        cols: core::ffi::c_int,
        alpha: core::ffi::c_int,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " ncvisual_from_rgba(), but 'bgra' is arranged as BGRA. note that this is a\n byte-oriented layout, despite being bunched in 32-bit pixels; the lowest\n memory address ought be B, and A is reached by adding 3 to that address.\n It is an error if 'rows', 'cols', or 'rowstride' are not positive, if\n 'rowstride' is not a multiple of 4, or if 'rowstride' is less than 'cols' * 4."]
    pub fn ncvisual_from_bgra(
        bgra: *const core::ffi::c_void,
        rows: core::ffi::c_int,
        rowstride: core::ffi::c_int,
        cols: core::ffi::c_int,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " ncvisual_from_rgba(), but 'data' is 'pstride'-byte palette-indexed pixels,\n arranged in 'rows' lines of 'rowstride' bytes each, composed of 'cols'\n pixels. 'palette' is an array of at least 'palsize' ncchannels.\n It is an error if 'rows', 'cols', 'rowstride', or 'pstride' are not\n positive, if 'rowstride' is not a multiple of 'pstride', or if 'rowstride'\n is less than 'cols' * 'pstride'."]
    pub fn ncvisual_from_palidx(
        data: *const core::ffi::c_void,
        rows: core::ffi::c_int,
        rowstride: core::ffi::c_int,
        cols: core::ffi::c_int,
        palsize: core::ffi::c_int,
        pstride: core::ffi::c_int,
        palette: *const u32,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " Promote an ncplane 'n' to an ncvisual. The plane may contain only spaces,\n half blocks, and full blocks. The latter will be checked, and any other\n glyph will result in a NULL being returned. This function exists so that\n planes can be subjected to ncvisual transformations. If possible, it's\n better to create the ncvisual from memory using ncvisual_from_rgba().\n Lengths of 0 are interpreted to mean \"all available remaining area\"."]
    pub fn ncvisual_from_plane(
        n: *const ncplane,
        blit: ncblitter_e,
        begy: core::ffi::c_int,
        begx: core::ffi::c_int,
        leny: core::ffi::c_uint,
        lenx: core::ffi::c_uint,
    ) -> *mut ncvisual;
}
extern "C" {
    #[doc = " Construct an ncvisual from a nul-terminated Sixel control sequence."]
    pub fn ncvisual_from_sixel(
        s: *const core::ffi::c_char,
        leny: core::ffi::c_uint,
        lenx: core::ffi::c_uint,
    ) -> *mut ncvisual;
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncvisual_options {
    #[doc = " if no ncplane is provided, one will be created using the exact size\n necessary to render the source with perfect fidelity (this might be\n smaller or larger than the rendering area). if NCVISUAL_OPTION_CHILDPLANE\n is provided, this must be non-NULL, and will be interpreted as the parent."]
    pub n: *mut ncplane,
    #[doc = " the scaling is ignored if no ncplane is provided (it ought be NCSCALE_NONE\n in this case). otherwise, the source is stretched/scaled relative to the\n provided ncplane."]
    pub scaling: ncscale_e,
    #[doc = " if an ncplane is provided, y and x specify where the visual will be\n rendered on that plane. otherwise, they specify where the created ncplane\n will be placed relative to the standard plane's origin. x is an ncalign_e\n value if NCVISUAL_OPTION_HORALIGNED is provided. y is an ncalign_e if\n NCVISUAL_OPTION_VERALIGNED is provided."]
    pub y: core::ffi::c_int,
    #[doc = " if an ncplane is provided, y and x specify where the visual will be\n rendered on that plane. otherwise, they specify where the created ncplane\n will be placed relative to the standard plane's origin. x is an ncalign_e\n value if NCVISUAL_OPTION_HORALIGNED is provided. y is an ncalign_e if\n NCVISUAL_OPTION_VERALIGNED is provided."]
    pub x: core::ffi::c_int,
    #[doc = " origin of rendered region in pixels"]
    pub begy: core::ffi::c_uint,
    #[doc = " origin of rendered region in pixels"]
    pub begx: core::ffi::c_uint,
    #[doc = " size of rendered region in pixels"]
    pub leny: core::ffi::c_uint,
    #[doc = " size of rendered region in pixels"]
    pub lenx: core::ffi::c_uint,
    #[doc = " glyph set to use (maps input to output cells)"]
    pub blitter: ncblitter_e,
    #[doc = " bitmask over NCVISUAL_OPTION_*"]
    pub flags: u64,
    #[doc = " treat this color as transparent under NCVISUAL_OPTION_ADDALPHA"]
    pub transcolor: u32,
    #[doc = " pixel offsets within the cell. if NCBLIT_PIXEL is used, the bitmap will\n be drawn offset from the upper-left cell's origin by these amounts. it is\n an error if either number exceeds the cell-pixel geometry in its\n dimension. if NCBLIT_PIXEL is not used, these fields are ignored.\n this functionality can be used for smooth bitmap movement."]
    pub pxoffy: core::ffi::c_uint,
    #[doc = " pixel offsets within the cell. if NCBLIT_PIXEL is used, the bitmap will\n be drawn offset from the upper-left cell's origin by these amounts. it is\n an error if either number exceeds the cell-pixel geometry in its\n dimension. if NCBLIT_PIXEL is not used, these fields are ignored.\n this functionality can be used for smooth bitmap movement."]
    pub pxoffx: core::ffi::c_uint,
}
impl Default for ncvisual_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " describes all geometries of an ncvisual: those which are inherent, and those\n dependent upon a given rendering regime. pixy and pixx are the true internal\n pixel geometry, taken directly from the load (and updated by\n ncvisual_resize()). cdimy/cdimx are the cell-pixel geometry *at the time\n of this call* (it can change with a font change, in which case all values\n other than pixy/pixx are invalidated). rpixy/rpixx are the pixel geometry as\n handed to the blitter, following any scaling. scaley/scalex are the number\n of input pixels drawn to a single cell; when using NCBLIT_PIXEL, they are\n equivalent to cdimy/cdimx. rcelly/rcellx are the cell geometry as written by\n the blitter, following any padding (there is padding whenever rpix{y, x} is\n not evenly divided by scale{y, x}, and also sometimes for Sixel).\n maxpixely/maxpixelx are defined only when NCBLIT_PIXEL is used, and specify\n the largest bitmap that the terminal is willing to accept. blitter is the\n blitter which will be used, a function of the requested blitter and the\n blitters actually supported by this environment. if no ncvisual was\n supplied, only cdimy/cdimx are filled in."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncvgeom {
    #[doc = " true pixel geometry of ncvisual data"]
    pub pixy: core::ffi::c_uint,
    #[doc = " true pixel geometry of ncvisual data"]
    pub pixx: core::ffi::c_uint,
    #[doc = " terminal cell geometry when this was calculated"]
    pub cdimy: core::ffi::c_uint,
    #[doc = " terminal cell geometry when this was calculated"]
    pub cdimx: core::ffi::c_uint,
    #[doc = " rendered pixel geometry (per visual_options)"]
    pub rpixy: core::ffi::c_uint,
    #[doc = " rendered pixel geometry (per visual_options)"]
    pub rpixx: core::ffi::c_uint,
    #[doc = " rendered cell geometry (per visual_options)"]
    pub rcelly: core::ffi::c_uint,
    #[doc = " rendered cell geometry (per visual_options)"]
    pub rcellx: core::ffi::c_uint,
    #[doc = " source pixels per filled cell"]
    pub scaley: core::ffi::c_uint,
    #[doc = " source pixels per filled cell"]
    pub scalex: core::ffi::c_uint,
    #[doc = " upper-left corner of used region"]
    pub begy: core::ffi::c_uint,
    #[doc = " upper-left corner of used region"]
    pub begx: core::ffi::c_uint,
    #[doc = " geometry of used region"]
    pub leny: core::ffi::c_uint,
    #[doc = " geometry of used region"]
    pub lenx: core::ffi::c_uint,
    #[doc = " only defined for NCBLIT_PIXEL"]
    pub maxpixely: core::ffi::c_uint,
    #[doc = " only defined for NCBLIT_PIXEL"]
    pub maxpixelx: core::ffi::c_uint,
    #[doc = " blitter that will be used"]
    pub blitter: ncblitter_e,
}
impl Default for ncvgeom {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " all-purpose ncvisual geometry solver. one or both of 'nc' and 'n' must be\n non-NULL. if 'nc' is NULL, only pixy/pixx will be filled in, with the true\n pixel geometry of 'n'. if 'n' is NULL, only cdimy/cdimx, blitter,\n scaley/scalex, and maxpixely/maxpixelx are filled in. cdimy/cdimx and\n maxpixely/maxpixelx are only ever filled in if we know them."]
    pub fn ncvisual_geom(
        nc: *const notcurses,
        n: *const ncvisual,
        vopts: *const ncvisual_options,
        geom: *mut ncvgeom,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Destroy an ncvisual. Rendered elements will not be disrupted, but the visual\n can be neither decoded nor rendered any further."]
    pub fn ncvisual_destroy(ncv: *mut ncvisual);
}
extern "C" {
    #[doc = " extract the next frame from an ncvisual. returns 1 on end of file, 0 on\n success, and -1 on failure."]
    pub fn ncvisual_decode(nc: *mut ncvisual) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " decode the next frame ala ncvisual_decode(), but if we have reached the end,\n rewind to the first frame of the ncvisual. a subsequent 'ncvisual_blit()'\n will render the first frame, as if the ncvisual had been closed and reopened.\n the return values remain the same as those of ncvisual_decode()."]
    pub fn ncvisual_decode_loop(nc: *mut ncvisual) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Rotate the visual 'rads' radians. Only M_PI/2 and -M_PI/2 are supported at\n the moment, but this might change in the future."]
    pub fn ncvisual_rotate(n: *mut ncvisual, rads: f64) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Scale the visual to 'rows' X 'columns' pixels, using the best scheme\n available. This is a lossy transformation, unless the size is unchanged."]
    pub fn ncvisual_resize(
        n: *mut ncvisual,
        rows: core::ffi::c_int,
        cols: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Scale the visual to 'rows' X 'columns' pixels, using non-interpolative\n (naive) scaling. No new colors will be introduced as a result."]
    pub fn ncvisual_resize_noninterpolative(
        n: *mut ncvisual,
        rows: core::ffi::c_int,
        cols: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Polyfill at the specified location within the ncvisual 'n', using 'rgba'."]
    pub fn ncvisual_polyfill_yx(
        n: *mut ncvisual,
        y: core::ffi::c_uint,
        x: core::ffi::c_uint,
        rgba: u32,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the specified pixel from the specified ncvisual."]
    pub fn ncvisual_at_yx(
        n: *const ncvisual,
        y: core::ffi::c_uint,
        x: core::ffi::c_uint,
        pixel: *mut u32,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the specified pixel in the specified ncvisual."]
    pub fn ncvisual_set_yx(
        n: *const ncvisual,
        y: core::ffi::c_uint,
        x: core::ffi::c_uint,
        pixel: u32,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Render the decoded frame according to the provided options (which may be\n NULL). The plane used for rendering depends on vopts->n and vopts->flags.\n If NCVISUAL_OPTION_CHILDPLANE is set, vopts->n must not be NULL, and the\n plane will always be created as a child of vopts->n. If this flag is not\n set, and vopts->n is NULL, a new plane is created as root of a new pile.\n If the flag is not set and vopts->n is not NULL, we render to vopts->n.\n A subregion of the visual can be rendered using 'begx', 'begy', 'lenx', and\n 'leny'. Negative values for any of these are an error. It is an error to\n specify any region beyond the boundaries of the frame. Returns the (possibly\n newly-created) plane to which we drew. Pixels may not be blitted to the\n standard plane."]
    pub fn ncvisual_blit(
        nc: *mut notcurses,
        ncv: *mut ncvisual,
        vopts: *const ncvisual_options,
    ) -> *mut ncplane;
}
extern "C" {
    #[doc = " If a subtitle ought be displayed at this time, return a new plane (bound\n to 'parent' containing the subtitle, which might be text or graphics\n (depending on the input format)."]
    pub fn ncvisual_subtitle_plane(parent: *mut ncplane, ncv: *const ncvisual) -> *mut ncplane;
}
extern "C" {
    #[doc = " Get the default *media* (not plot) blitter for this environment when using\n the specified scaling method. Currently, this means:\n  - if lacking UTF-8, NCBLIT_1x1\n  - otherwise, if not NCSCALE_STRETCH, NCBLIT_2x1\n  - otherwise, if sextants are not known to be good, NCBLIT_2x2\n  - otherwise NCBLIT_3x2\n NCBLIT_2x2 and NCBLIT_3x2 both distort the original aspect ratio, thus\n NCBLIT_2x1 is used outside of NCSCALE_STRETCH."]
    pub fn ncvisual_media_defblitter(nc: *const notcurses, scale: ncscale_e) -> ncblitter_e;
}
#[doc = " Called for each frame rendered from 'ncv'. If anything but 0 is returned,\n the streaming operation ceases immediately, and that value is propagated out.\n The recommended absolute display time target is passed in 'tspec'."]
pub type ncstreamcb = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ncvisual,
        arg2: *mut ncvisual_options,
        arg3: *const timespec,
        arg4: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
extern "C" {
    #[doc = " Shut up and display my frames! Provide as an argument to ncvisual_stream().\n If you'd like subtitles to be decoded, provide an ncplane as the curry. If the\n curry is NULL, subtitles will not be displayed."]
    pub fn ncvisual_simple_streamer(
        ncv: *mut ncvisual,
        vopts: *mut ncvisual_options,
        tspec: *const timespec,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Stream the entirety of the media, according to its own timing. Blocking,\n obviously. streamer may be NULL; it is otherwise called for each frame, and\n its return value handled as outlined for streamcb. If streamer() returns\n non-zero, the stream is aborted, and that value is returned. By convention,\n return a positive number to indicate intentional abort from within\n streamer(). 'timescale' allows the frame duration time to be scaled. For a\n visual naturally running at 30FPS, a 'timescale' of 0.1 will result in\n 300FPS, and a 'timescale' of 10 will result in 3FPS. It is an error to\n supply 'timescale' less than or equal to 0."]
    pub fn ncvisual_stream(
        nc: *mut notcurses,
        ncv: *mut ncvisual,
        timescale: f32,
        streamer: ncstreamcb,
        vopts: *const ncvisual_options,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Blit a flat array 'data' of RGBA 32-bit values to the ncplane 'vopts->n',\n which mustn't be NULL. the blit begins at 'vopts->y' and 'vopts->x' relative\n to the specified plane. Each source row ought occupy 'linesize' bytes (this\n might be greater than 'vopts->lenx' * 4 due to padding or partial blits). A\n subregion of the input can be specified with the 'begy'x'begx' and\n 'leny'x'lenx' fields from 'vopts'. Returns the number of pixels blitted, or\n -1 on error."]
    pub fn ncblit_rgba(
        data: *const core::ffi::c_void,
        linesize: core::ffi::c_int,
        vopts: *const ncvisual_options,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Same as ncblit_rgba(), but for BGRx."]
    pub fn ncblit_bgrx(
        data: *const core::ffi::c_void,
        linesize: core::ffi::c_int,
        vopts: *const ncvisual_options,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Supply an alpha value [0..255] to be applied throughout."]
    pub fn ncblit_rgb_packed(
        data: *const core::ffi::c_void,
        linesize: core::ffi::c_int,
        vopts: *const ncvisual_options,
        alpha: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Supply an alpha value [0..255] to be applied throughout. linesize must be\n a multiple of 4 for this RGBx data."]
    pub fn ncblit_rgb_loose(
        data: *const core::ffi::c_void,
        linesize: core::ffi::c_int,
        vopts: *const ncvisual_options,
        alpha: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncreel_options {
    #[doc = " bitfield; 1s will not be drawn (see bordermaskbits)"]
    pub bordermask: core::ffi::c_uint,
    #[doc = " attributes used for ncreel border"]
    pub borderchan: u64,
    #[doc = " bitfield; same as bordermask but for tablet borders"]
    pub tabletmask: core::ffi::c_uint,
    #[doc = " tablet border styling channel"]
    pub tabletchan: u64,
    #[doc = " focused tablet border styling channel"]
    pub focusedchan: u64,
    #[doc = " bitfield over NCREEL_OPTION_*"]
    pub flags: u64,
}
extern "C" {
    #[doc = " Take over the ncplane 'nc' and use it to draw a reel according to 'popts'.\n The plane will be destroyed by ncreel_destroy(); this transfers ownership."]
    pub fn ncreel_create(n: *mut ncplane, popts: *const ncreel_options) -> *mut ncreel;
}
extern "C" {
    #[doc = " Returns the ncplane on which this ncreel lives."]
    pub fn ncreel_plane(nr: *mut ncreel) -> *mut ncplane;
}
#[doc = " Tablet draw callback, provided a tablet (from which the ncplane and userptr\n may be extracted), and a bool indicating whether output ought be drawn from\n the top (true) or bottom (false). Returns non-negative count of output lines,\n which must be less than or equal to ncplane_dim_y(nctablet_plane(t))."]
pub type tabletcb = ::core::option::Option<
    unsafe extern "C" fn(t: *mut nctablet, drawfromtop: bool) -> core::ffi::c_int,
>;
extern "C" {
    #[doc = " Add a new nctablet to the provided ncreel 'nr', having the callback object\n 'opaque'. Neither, either, or both of 'after' and 'before' may be specified.\n If neither is specified, the new tablet can be added anywhere on the reel.\n If one or the other is specified, the tablet will be added before or after\n the specified tablet. If both are specified, the tablet will be added to the\n resulting location, assuming it is valid (after->next == before->prev); if\n it is not valid, or there is any other error, NULL will be returned."]
    pub fn ncreel_add(
        nr: *mut ncreel,
        after: *mut nctablet,
        before: *mut nctablet,
        cb: tabletcb,
        opaque: *mut core::ffi::c_void,
    ) -> *mut nctablet;
}
extern "C" {
    #[doc = " Return the number of nctablets in the ncreel 'nr'."]
    pub fn ncreel_tabletcount(nr: *const ncreel) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Delete the tablet specified by t from the ncreel 'nr'. Returns -1 if the\n tablet cannot be found."]
    pub fn ncreel_del(nr: *mut ncreel, t: *mut nctablet) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Redraw the ncreel 'nr' in its entirety. The reel will be cleared, and\n tablets will be lain out, using the focused tablet as a fulcrum. Tablet\n drawing callbacks will be invoked for each visible tablet."]
    pub fn ncreel_redraw(nr: *mut ncreel) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Offer input 'ni' to the ncreel 'nr'. If it's relevant, this function returns\n true, and the input ought not be processed further. If it's irrelevant to\n the reel, false is returned. Relevant inputs include:\n  * a mouse click on a tablet (focuses tablet)\n  * a mouse scrollwheel event (rolls reel)\n  * up, down, pgup, or pgdown (navigates among items)"]
    pub fn ncreel_offer_input(nr: *mut ncreel, ni: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Return the focused tablet, if any tablets are present. This is not a copy;\n be careful to use it only for the duration of a critical section."]
    pub fn ncreel_focused(nr: *mut ncreel) -> *mut nctablet;
}
extern "C" {
    #[doc = " Change focus to the next tablet, if one exists"]
    pub fn ncreel_next(nr: *mut ncreel) -> *mut nctablet;
}
extern "C" {
    #[doc = " Change focus to the previous tablet, if one exists"]
    pub fn ncreel_prev(nr: *mut ncreel) -> *mut nctablet;
}
extern "C" {
    #[doc = " Destroy an ncreel allocated with ncreel_create()."]
    pub fn ncreel_destroy(nr: *mut ncreel);
}
extern "C" {
    #[doc = " Returns a pointer to a user pointer associated with this nctablet."]
    pub fn nctablet_userptr(t: *mut nctablet) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Access the ncplane associated with nctablet 't', if one exists."]
    pub fn nctablet_plane(t: *mut nctablet) -> *mut ncplane;
}
extern "C" {
    #[doc = " snprintf(3) is used internally, with 's' as its size bound. If the output\n requires more size than is available, NULL will be returned.\n\n Floating-point is never used, because an IEEE758 double can only losslessly\n represent integers through 2^53-1.\n\n 2^64-1 is 18446744073709551615, 18.45E(xa). KMGTPEZY thus suffice to handle\n an 89-bit uintmax_t. Beyond Z(etta) and Y(otta) lie lands unspecified by SI.\n 2^-63 is 0.000000000000000000108, 1.08a(tto).\n val: value to print\n s: maximum output size; see snprintf(3)\n decimal: scaling. '1' if none has taken place.\n buf: buffer in which string will be generated\n omitdec: inhibit printing of all-0 decimal portions\n mult: base of suffix system (almost always 1000 or 1024)\n uprefix: character to print following suffix ('i' for kibibytes basically).\n   only printed if suffix is actually printed (input >= mult).\n\n You are encouraged to consult notcurses_metric(3)."]
    pub fn ncnmetric(
        val: uintmax_t,
        s: usize,
        decimal: uintmax_t,
        buf: *mut core::ffi::c_char,
        omitdec: core::ffi::c_int,
        mult: uintmax_t,
        uprefix: core::ffi::c_int,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Get the default foreground color, if it is known. Returns -1 on error\n (unknown foreground). On success, returns 0, writing the RGB value to\n 'fg' (if non-NULL)"]
    pub fn notcurses_default_foreground(nc: *const notcurses, fg: *mut u32) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the default background color, if it is known. Returns -1 on error\n (unknown background). On success, returns 0, writing the RGB value to\n 'bg' (if non-NULL) and setting 'bgtrans' high iff the background color\n is treated as transparent."]
    pub fn notcurses_default_background(nc: *const notcurses, bg: *mut u32) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Enable or disable the terminal's cursor, if supported, placing it at\n 'y', 'x'. Immediate effect (no need for a call to notcurses_render()).\n It is an error if 'y', 'x' lies outside the standard plane. Can be\n called while already visible to move the cursor."]
    pub fn notcurses_cursor_enable(
        nc: *mut notcurses,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Disable the hardware cursor. It is an error to call this while the\n cursor is already disabled."]
    pub fn notcurses_cursor_disable(nc: *mut notcurses) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the current location of the terminal's cursor, whether visible or not."]
    pub fn notcurses_cursor_yx(
        nc: *const notcurses,
        y: *mut core::ffi::c_int,
        x: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Convert the plane's content to greyscale."]
    pub fn ncplane_greyscale(n: *mut ncplane);
}
#[doc = " selection widget -- an ncplane with a title header and a body section. the\n body section supports infinite scrolling up and down.\n\n At all times, exactly one item is selected."]
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncselector_item {
    pub option: *const core::ffi::c_char,
    pub desc: *const core::ffi::c_char,
}
impl Default for ncselector_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncselector_options {
    #[doc = " title may be NULL, inhibiting riser, saving two rows."]
    pub title: *const core::ffi::c_char,
    #[doc = " secondary may be NULL"]
    pub secondary: *const core::ffi::c_char,
    #[doc = " footer may be NULL"]
    pub footer: *const core::ffi::c_char,
    #[doc = " initial items and descriptions"]
    pub items: *const ncselector_item,
    #[doc = " default item (selected at start), must be < itemcount unless itemcount is\n 0, in which case 'defidx' must also be 0"]
    pub defidx: core::ffi::c_uint,
    #[doc = " maximum number of options to display at once, 0 to use all available space"]
    pub maxdisplay: core::ffi::c_uint,
    #[doc = " option channels"]
    pub opchannels: u64,
    #[doc = " description channels"]
    pub descchannels: u64,
    #[doc = " title channels"]
    pub titlechannels: u64,
    #[doc = " secondary and footer channels"]
    pub footchannels: u64,
    #[doc = " border channels"]
    pub boxchannels: u64,
    #[doc = " bitfield of NCSELECTOR_OPTION_*, currently unused"]
    pub flags: u64,
}
impl Default for ncselector_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ncselector_create(n: *mut ncplane, opts: *const ncselector_options) -> *mut ncselector;
}
extern "C" {
    #[doc = " Dynamically add or delete items. It is usually sufficient to supply a static\n list of items via ncselector_options->items."]
    pub fn ncselector_additem(n: *mut ncselector, item: *const ncselector_item)
        -> core::ffi::c_int;
}
extern "C" {
    pub fn ncselector_delitem(
        n: *mut ncselector,
        item: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return reference to the selected option, or NULL if there are no items."]
    pub fn ncselector_selected(n: *const ncselector) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Return a reference to the ncselector's underlying ncplane."]
    pub fn ncselector_plane(n: *mut ncselector) -> *mut ncplane;
}
extern "C" {
    #[doc = " Move up or down in the list. A reference to the newly-selected item is\n returned, or NULL if there are no items in the list."]
    pub fn ncselector_previtem(n: *mut ncselector) -> *const core::ffi::c_char;
}
extern "C" {
    pub fn ncselector_nextitem(n: *mut ncselector) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Offer the input to the ncselector. If it's relevant, this function returns\n true, and the input ought not be processed further. If it's irrelevant to\n the selector, false is returned. Relevant inputs include:\n  * a mouse click on an item\n  * a mouse scrollwheel event\n  * a mouse click on the scrolling arrows\n  * up, down, pgup, or pgdown on an unrolled menu (navigates among items)"]
    pub fn ncselector_offer_input(n: *mut ncselector, nc: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Destroy the ncselector."]
    pub fn ncselector_destroy(n: *mut ncselector, item: *mut *mut core::ffi::c_char);
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmselector_item {
    pub option: *const core::ffi::c_char,
    pub desc: *const core::ffi::c_char,
    pub selected: bool,
}
impl Default for ncmselector_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " multiselection widget -- a selector supporting multiple selections.\n\n Unlike the selector widget, zero to all of the items can be selected, but\n also the widget does not support adding or removing items at runtime."]
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmultiselector_options {
    #[doc = " title may be NULL, inhibiting riser, saving two rows."]
    pub title: *const core::ffi::c_char,
    #[doc = " secondary may be NULL"]
    pub secondary: *const core::ffi::c_char,
    #[doc = " footer may be NULL"]
    pub footer: *const core::ffi::c_char,
    #[doc = " initial items, descriptions, and statuses"]
    pub items: *const ncmselector_item,
    #[doc = " maximum number of options to display at once, 0 to use all available space"]
    pub maxdisplay: core::ffi::c_uint,
    #[doc = " option channels"]
    pub opchannels: u64,
    #[doc = " description channels"]
    pub descchannels: u64,
    #[doc = " title channels"]
    pub titlechannels: u64,
    #[doc = " secondary and footer channels"]
    pub footchannels: u64,
    #[doc = " border channels"]
    pub boxchannels: u64,
    #[doc = " bitfield of NCMULTISELECTOR_OPTION_*, currently unused"]
    pub flags: u64,
}
impl Default for ncmultiselector_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn ncmultiselector_create(
        n: *mut ncplane,
        opts: *const ncmultiselector_options,
    ) -> *mut ncmultiselector;
}
extern "C" {
    #[doc = " Return selected vector. An array of bools must be provided, along with its\n length. If that length doesn't match the itemcount, it is an error."]
    pub fn ncmultiselector_selected(
        n: *mut ncmultiselector,
        selected: *mut bool,
        count: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return a reference to the ncmultiselector's underlying ncplane."]
    pub fn ncmultiselector_plane(n: *mut ncmultiselector) -> *mut ncplane;
}
extern "C" {
    #[doc = " Offer the input to the ncmultiselector. If it's relevant, this function\n returns true, and the input ought not be processed further. If it's\n irrelevant to the multiselector, false is returned. Relevant inputs include:\n  * a mouse click on an item\n  * a mouse scrollwheel event\n  * a mouse click on the scrolling arrows\n  * up, down, pgup, or pgdown on an unrolled menu (navigates among items)"]
    pub fn ncmultiselector_offer_input(n: *mut ncmultiselector, nc: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Destroy the ncmultiselector."]
    pub fn ncmultiselector_destroy(n: *mut ncmultiselector);
}
#[doc = " each item has a curry, and zero or more subitems."]
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nctree_item {
    pub curry: *mut core::ffi::c_void,
    pub subs: *mut nctree_item,
    pub subcount: core::ffi::c_uint,
}
impl Default for nctree_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nctree_options {
    #[doc = " top-level nctree_item array"]
    pub items: *const nctree_item,
    #[doc = " size of |items|"]
    pub count: core::ffi::c_uint,
    #[doc = " item callback function"]
    pub nctreecb: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ncplane,
            arg2: *mut core::ffi::c_void,
            arg3: core::ffi::c_int,
        ) -> core::ffi::c_int,
    >,
    #[doc = " columns to indent per level of hierarchy"]
    pub indentcols: core::ffi::c_int,
    #[doc = " bitfield of NCTREE_OPTION_*"]
    pub flags: u64,
}
impl Default for nctree_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct nctree {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " |opts| may *not* be NULL, since it is necessary to define a callback\n function."]
    pub fn nctree_create(n: *mut ncplane, opts: *const nctree_options) -> *mut nctree;
}
extern "C" {
    #[doc = " Returns the ncplane on which this nctree lives."]
    pub fn nctree_plane(n: *mut nctree) -> *mut ncplane;
}
extern "C" {
    #[doc = " Redraw the nctree 'n' in its entirety. The tree will be cleared, and items\n will be lain out, using the focused item as a fulcrum. Item-drawing\n callbacks will be invoked for each visible item."]
    pub fn nctree_redraw(n: *mut nctree) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Offer input 'ni' to the nctree 'n'. If it's relevant, this function returns\n true, and the input ought not be processed further. If it's irrelevant to\n the tree, false is returned. Relevant inputs include:\n  * a mouse click on an item (focuses item)\n  * a mouse scrollwheel event (srolls tree)\n  * up, down, pgup, or pgdown (navigates among items)"]
    pub fn nctree_offer_input(n: *mut nctree, ni: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Return the focused item, if any items are present. This is not a copy;\n be careful to use it only for the duration of a critical section."]
    pub fn nctree_focused(n: *mut nctree) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Change focus to the next item."]
    pub fn nctree_next(n: *mut nctree) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Change focus to the previous item."]
    pub fn nctree_prev(n: *mut nctree) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Go to the item specified by the array |spec| (a spec is a series of unsigned\n values, each identifying a subelement in the hierarchy thus far, terminated\n by UINT_MAX). If the spec is invalid, NULL is returned, and the depth of the\n first invalid spec is written to *|failspec|. Otherwise, the true depth is\n written to *|failspec|, and the curry is returned (|failspec| is necessary\n because the curry could itself be NULL)."]
    pub fn nctree_goto(
        n: *mut nctree,
        spec: *const core::ffi::c_uint,
        failspec: *mut core::ffi::c_int,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Insert |add| into the nctree |n| at |spec|. The path up to the last element\n must already exist. If an item already exists at the path, it will be moved\n to make room for |add|."]
    pub fn nctree_add(
        n: *mut nctree,
        spec: *const core::ffi::c_uint,
        add: *const nctree_item,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Delete the item at |spec|, including any subitems."]
    pub fn nctree_del(n: *mut nctree, spec: *const core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Destroy the nctree."]
    pub fn nctree_destroy(n: *mut nctree);
}
#[doc = " Menus. Horizontal menu bars are supported, on the top and/or bottom rows.\n If the menu bar is longer than the screen, it will be only partially\n visible. Menus may be either visible or invisible by default. In the event of\n a plane resize, menus will be automatically moved/resized. Elements can be\n dynamically enabled or disabled at all levels (menu, section, and item),"]
#[repr(C)]
#[derive(Debug, Hash)]
pub struct ncmenu_item {
    #[doc = " utf-8 menu item, NULL for horizontal separator"]
    pub desc: *const core::ffi::c_char,
    #[doc = " shortcut, all should be distinct"]
    pub shortcut: ncinput,
}
impl Default for ncmenu_item {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Hash)]
pub struct ncmenu_section {
    #[doc = " utf-8 c string"]
    pub name: *const core::ffi::c_char,
    pub itemcount: core::ffi::c_int,
    pub items: *mut ncmenu_item,
    #[doc = " shortcut, will be underlined if present in name"]
    pub shortcut: ncinput,
}
impl Default for ncmenu_section {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncmenu_options {
    #[doc = " array of 'sectioncount' menu_sections"]
    pub sections: *mut ncmenu_section,
    #[doc = " must be positive"]
    pub sectioncount: core::ffi::c_int,
    #[doc = " styling for header"]
    pub headerchannels: u64,
    #[doc = " styling for sections"]
    pub sectionchannels: u64,
    #[doc = " flag word of NCMENU_OPTION_*"]
    pub flags: u64,
}
impl Default for ncmenu_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug)]
pub struct ncmenu {
    _unused: [u8; 0],
}
extern "C" {
    #[doc = " Create a menu with the specified options, bound to the specified plane."]
    pub fn ncmenu_create(n: *mut ncplane, opts: *const ncmenu_options) -> *mut ncmenu;
}
extern "C" {
    #[doc = " Unroll the specified menu section, making the menu visible if it was\n invisible, and rolling up any menu section that is already unrolled."]
    pub fn ncmenu_unroll(n: *mut ncmenu, sectionidx: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Roll up any unrolled menu section, and hide the menu if using hiding."]
    pub fn ncmenu_rollup(n: *mut ncmenu) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Unroll the previous/next section (relative to current unrolled). If no\n section is unrolled, the first section will be unrolled."]
    pub fn ncmenu_nextsection(n: *mut ncmenu) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncmenu_prevsection(n: *mut ncmenu) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Move to the previous/next item within the currently unrolled section. If no\n section is unrolled, the first section will be unrolled."]
    pub fn ncmenu_nextitem(n: *mut ncmenu) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncmenu_previtem(n: *mut ncmenu) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Disable or enable a menu item. Returns 0 if the item was found."]
    pub fn ncmenu_item_set_status(
        n: *mut ncmenu,
        section: *const core::ffi::c_char,
        item: *const core::ffi::c_char,
        enabled: bool,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Return the selected item description, or NULL if no section is unrolled. If\n 'ni' is not NULL, and the selected item has a shortcut, 'ni' will be filled\n in with that shortcut--this can allow faster matching."]
    pub fn ncmenu_selected(n: *const ncmenu, ni: *mut ncinput) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Return the item description corresponding to the mouse click 'click'. The\n item must be on an actively unrolled section, and the click must be in the\n area of a valid item. If 'ni' is not NULL, and the selected item has a\n shortcut, 'ni' will be filled in with the shortcut."]
    pub fn ncmenu_mouse_selected(
        n: *const ncmenu,
        click: *const ncinput,
        ni: *mut ncinput,
    ) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Return the ncplane backing this ncmenu."]
    pub fn ncmenu_plane(n: *mut ncmenu) -> *mut ncplane;
}
extern "C" {
    #[doc = " Offer the input to the ncmenu. If it's relevant, this function returns true,\n and the input ought not be processed further. If it's irrelevant to the\n menu, false is returned. Relevant inputs include:\n  * mouse movement over a hidden menu\n  * a mouse click on a menu section (the section is unrolled)\n  * a mouse click outside of an unrolled menu (the menu is rolled up)\n  * left or right on an unrolled menu (navigates among sections)\n  * up or down on an unrolled menu (navigates among items)\n  * escape on an unrolled menu (the menu is rolled up)"]
    pub fn ncmenu_offer_input(n: *mut ncmenu, nc: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Destroy a menu created with ncmenu_create()."]
    pub fn ncmenu_destroy(n: *mut ncmenu);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncprogbar_options {
    #[doc = " upper-left channel. in the context of a progress bar,"]
    pub ulchannel: u32,
    #[doc = " \"up\" is the direction we are progressing towards, and"]
    pub urchannel: u32,
    #[doc = " \"bottom\" is the direction of origin. for monochromatic"]
    pub blchannel: u32,
    #[doc = " bar, all four channels ought be the same."]
    pub brchannel: u32,
    pub flags: u64,
}
extern "C" {
    #[doc = " Takes ownership of the ncplane 'n', which will be destroyed by\n ncprogbar_destroy(). The progress bar is initially at 0%."]
    pub fn ncprogbar_create(n: *mut ncplane, opts: *const ncprogbar_options) -> *mut ncprogbar;
}
extern "C" {
    #[doc = " Return a reference to the ncprogbar's underlying ncplane."]
    pub fn ncprogbar_plane(n: *mut ncprogbar) -> *mut ncplane;
}
extern "C" {
    #[doc = " Set the progress bar's completion, a double 0 <= 'p' <= 1."]
    pub fn ncprogbar_set_progress(n: *mut ncprogbar, p: f64) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the progress bar's completion, a double on [0, 1]."]
    pub fn ncprogbar_progress(n: *const ncprogbar) -> f64;
}
extern "C" {
    #[doc = " Destroy the progress bar and its underlying ncplane."]
    pub fn ncprogbar_destroy(n: *mut ncprogbar);
}
#[repr(C)]
#[derive(Debug, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct nctabbed_options {
    #[doc = " channel for the selected tab header"]
    pub selchan: u64,
    #[doc = " channel for unselected tab headers"]
    pub hdrchan: u64,
    #[doc = " channel for the tab separator"]
    pub sepchan: u64,
    #[doc = " separator string (copied by nctabbed_create())"]
    pub separator: *const core::ffi::c_char,
    #[doc = " bitmask of NCTABBED_OPTION_*"]
    pub flags: u64,
}
impl Default for nctabbed_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Tab content drawing callback. Takes the tab it was associated to, the ncplane\n on which tab content is to be drawn, and the user pointer of the tab.\n It is called during nctabbed_redraw()."]
pub type tabcb = ::core::option::Option<
    unsafe extern "C" fn(t: *mut nctab, ncp: *mut ncplane, curry: *mut core::ffi::c_void),
>;
extern "C" {
    #[doc = " Creates a new nctabbed widget, associated with the given ncplane 'n', and with\n additional options given in 'opts'. When 'opts' is NULL, it acts as if it were\n called with an all-zero opts. The widget takes ownership of 'n', and destroys\n it when the widget is destroyed. Returns the newly created widget. Returns\n NULL on failure, also destroying 'n'."]
    pub fn nctabbed_create(n: *mut ncplane, opts: *const nctabbed_options) -> *mut nctabbed;
}
extern "C" {
    #[doc = " Destroy an nctabbed widget. All memory belonging to 'nt' is deallocated,\n including all tabs and their names. The plane associated with 'nt' is also\n destroyed. Calling this with NULL does nothing."]
    pub fn nctabbed_destroy(nt: *mut nctabbed);
}
extern "C" {
    #[doc = " Redraw the widget. This calls the tab callback of the currently selected tab\n to draw tab contents, and draws tab headers. The tab content plane is not\n modified by this function, apart from resizing the plane is necessary."]
    pub fn nctabbed_redraw(nt: *mut nctabbed);
}
extern "C" {
    #[doc = " Make sure the tab header of the currently selected tab is at least partially\n visible. (by rotating tabs until at least one column is displayed)\n Does nothing if there are no tabs."]
    pub fn nctabbed_ensure_selected_header_visible(nt: *mut nctabbed);
}
extern "C" {
    #[doc = " Returns the currently selected tab, or NULL if there are no tabs."]
    pub fn nctabbed_selected(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Returns the leftmost tab, or NULL if there are no tabs."]
    pub fn nctabbed_leftmost(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Returns the number of tabs in the widget."]
    pub fn nctabbed_tabcount(nt: *mut nctabbed) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Returns the plane associated to 'nt'."]
    pub fn nctabbed_plane(nt: *mut nctabbed) -> *mut ncplane;
}
extern "C" {
    #[doc = " Returns the tab content plane."]
    pub fn nctabbed_content_plane(nt: *mut nctabbed) -> *mut ncplane;
}
extern "C" {
    #[doc = " Returns the tab callback."]
    pub fn nctab_cb(t: *mut nctab) -> tabcb;
}
extern "C" {
    #[doc = " Returns the tab name. This is not a copy and it should not be stored."]
    pub fn nctab_name(t: *mut nctab) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns the width (in columns) of the tab's name."]
    pub fn nctab_name_width(t: *mut nctab) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Returns the tab's user pointer."]
    pub fn nctab_userptr(t: *mut nctab) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Returns the tab to the right of 't'. This does not change which tab is selected."]
    pub fn nctab_next(t: *mut nctab) -> *mut nctab;
}
extern "C" {
    #[doc = " Returns the tab to the left of 't'. This does not change which tab is selected."]
    pub fn nctab_prev(t: *mut nctab) -> *mut nctab;
}
extern "C" {
    #[doc = " Add a new tab to 'nt' with the given tab callback, name, and user pointer.\n If both 'before' and 'after' are NULL, the tab is inserted after the selected\n tab. Otherwise, it gets put after 'after' (if not NULL) and before 'before'\n (if not NULL). If both 'after' and 'before' are given, they must be two\n neighboring tabs (the tab list is circular, so the last tab is immediately\n before the leftmost tab), otherwise the function returns NULL. If 'name' is\n NULL or a string containing illegal characters, the function returns NULL.\n On all other failures the function also returns NULL. If it returns NULL,\n none of the arguments are modified, and the widget state is not altered."]
    pub fn nctabbed_add(
        nt: *mut nctabbed,
        after: *mut nctab,
        before: *mut nctab,
        tcb: tabcb,
        name: *const core::ffi::c_char,
        opaque: *mut core::ffi::c_void,
    ) -> *mut nctab;
}
extern "C" {
    #[doc = " Remove a tab 't' from 'nt'. Its neighboring tabs become neighbors to each\n other. If 't' if the selected tab, the tab after 't' becomes selected.\n Likewise if 't' is the leftmost tab, the tab after 't' becomes leftmost.\n If 't' is the only tab, there will no more be a selected or leftmost tab,\n until a new tab is added. Returns -1 if 't' is NULL, and 0 otherwise."]
    pub fn nctabbed_del(nt: *mut nctabbed, t: *mut nctab) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Move 't' after 'after' (if not NULL) and before 'before' (if not NULL).\n If both 'after' and 'before' are NULL, the function returns -1, otherwise\n it returns 0."]
    pub fn nctab_move(
        nt: *mut nctabbed,
        t: *mut nctab,
        after: *mut nctab,
        before: *mut nctab,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Move 't' to the right by one tab, looping around to become leftmost if needed."]
    pub fn nctab_move_right(nt: *mut nctabbed, t: *mut nctab);
}
extern "C" {
    #[doc = " Move 't' to the right by one tab, looping around to become the last tab if needed."]
    pub fn nctab_move_left(nt: *mut nctabbed, t: *mut nctab);
}
extern "C" {
    #[doc = " Rotate the tabs of 'nt' right by 'amt' tabs, or '-amt' tabs left if 'amt' is\n negative. Tabs are rotated only by changing the leftmost tab; the selected tab\n stays the same. If there are no tabs, nothing happens."]
    pub fn nctabbed_rotate(nt: *mut nctabbed, amt: core::ffi::c_int);
}
extern "C" {
    #[doc = " Select the tab after the currently selected tab, and return the newly selected\n tab. Returns NULL if there are no tabs."]
    pub fn nctabbed_next(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Select the tab before the currently selected tab, and return the newly selected\n tab. Returns NULL if there are no tabs."]
    pub fn nctabbed_prev(nt: *mut nctabbed) -> *mut nctab;
}
extern "C" {
    #[doc = " Change the selected tab to be 't'. Returns the previously selected tab."]
    pub fn nctabbed_select(nt: *mut nctabbed, t: *mut nctab) -> *mut nctab;
}
extern "C" {
    #[doc = " Write the channels for tab headers, the selected tab header, and the separator\n to '*hdrchan', '*selchan', and '*sepchan' respectively."]
    pub fn nctabbed_channels(
        nt: *mut nctabbed,
        hdrchan: *mut u64,
        selchan: *mut u64,
        sepchan: *mut u64,
    );
}
extern "C" {
    #[doc = " Returns the tab separator. This is not a copy and it should not be stored.\n This can be NULL, if the separator was set to NULL in ncatbbed_create() or\n nctabbed_set_separator()."]
    pub fn nctabbed_separator(nt: *mut nctabbed) -> *const core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns the tab separator width, or zero if there is no separator."]
    pub fn nctabbed_separator_width(nt: *mut nctabbed) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the tab headers channel for 'nt'."]
    pub fn nctabbed_set_hdrchan(nt: *mut nctabbed, chan: u64);
}
extern "C" {
    #[doc = " Set the selected tab header channel for 'nt'."]
    pub fn nctabbed_set_selchan(nt: *mut nctabbed, chan: u64);
}
extern "C" {
    #[doc = " Set the tab separator channel for 'nt'."]
    pub fn nctabbed_set_sepchan(nt: *mut nctabbed, chan: u64);
}
extern "C" {
    #[doc = " Set the tab callback function for 't'. Returns the previous tab callback."]
    pub fn nctab_set_cb(t: *mut nctab, newcb: tabcb) -> tabcb;
}
extern "C" {
    #[doc = " Change the name of 't'. Returns -1 if 'newname' is NULL, and 0 otherwise."]
    pub fn nctab_set_name(t: *mut nctab, newname: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Set the user pointer of 't'. Returns the previous user pointer."]
    pub fn nctab_set_userptr(
        t: *mut nctab,
        newopaque: *mut core::ffi::c_void,
    ) -> *mut core::ffi::c_void;
}
extern "C" {
    #[doc = " Change the tab separator for 'nt'. Returns -1 if 'separator' is not NULL and\n is not a valid string, and 0 otherwise."]
    pub fn nctabbed_set_separator(
        nt: *mut nctabbed,
        separator: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncplot_options {
    #[doc = " channels for the maximum and minimum levels. linear or exponential\n interpolation will be applied across the domain between these two."]
    pub maxchannels: u64,
    pub minchannels: u64,
    #[doc = " styling used for the legend, if NCPLOT_OPTION_LABELTICKSD is set"]
    pub legendstyle: u16,
    #[doc = " number of \"pixels\" per row x column"]
    pub gridtype: ncblitter_e,
    #[doc = " independent variable can either be a contiguous range, or a finite set\n of keys. for a time range, say the previous hour sampled with second\n resolution, the independent variable would be the range [0..3600): 3600.\n if rangex is 0, it is dynamically set to the number of columns."]
    pub rangex: core::ffi::c_int,
    #[doc = " optional, printed by the labels"]
    pub title: *const core::ffi::c_char,
    #[doc = " bitfield over NCPLOT_OPTION_*"]
    pub flags: u64,
}
impl Default for ncplot_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Use the provided plane 'n' for plotting according to the options 'opts'. The\n plot will make free use of the entirety of the plane. For domain\n autodiscovery, set miny == maxy == 0. ncuplot holds uint64_ts, while\n ncdplot holds doubles."]
    pub fn ncuplot_create(
        n: *mut ncplane,
        opts: *const ncplot_options,
        miny: u64,
        maxy: u64,
    ) -> *mut ncuplot;
}
extern "C" {
    pub fn ncdplot_create(
        n: *mut ncplane,
        opts: *const ncplot_options,
        miny: f64,
        maxy: f64,
    ) -> *mut ncdplot;
}
extern "C" {
    #[doc = " Return a reference to the ncplot's underlying ncplane."]
    pub fn ncuplot_plane(n: *mut ncuplot) -> *mut ncplane;
}
extern "C" {
    pub fn ncdplot_plane(n: *mut ncdplot) -> *mut ncplane;
}
extern "C" {
    #[doc = " Add to or set the value corresponding to this x. If x is beyond the current\n x window, the x window is advanced to include x, and values passing beyond\n the window are lost. The first call will place the initial window. The plot\n will be redrawn, but notcurses_render() is not called."]
    pub fn ncuplot_add_sample(n: *mut ncuplot, x: u64, y: u64) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdplot_add_sample(n: *mut ncdplot, x: u64, y: f64) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncuplot_set_sample(n: *mut ncuplot, x: u64, y: u64) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdplot_set_sample(n: *mut ncdplot, x: u64, y: f64) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncuplot_sample(n: *const ncuplot, x: u64, y: *mut u64) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdplot_sample(n: *const ncdplot, x: u64, y: *mut f64) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncuplot_destroy(n: *mut ncuplot);
}
extern "C" {
    pub fn ncdplot_destroy(n: *mut ncdplot);
}
pub type ncfdplane_callback = ::core::option::Option<
    unsafe extern "C" fn(
        n: *mut ncfdplane,
        buf: *const core::ffi::c_void,
        s: usize,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
pub type ncfdplane_done_cb = ::core::option::Option<
    unsafe extern "C" fn(
        n: *mut ncfdplane,
        fderrno: core::ffi::c_int,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int,
>;
#[doc = " read from an fd until EOF (or beyond, if follow is set), invoking the user's\n callback each time. runs in its own context. on EOF or error, the finalizer\n callback will be invoked, and the user ought destroy the ncfdplane. the\n data is *not* guaranteed to be nul-terminated, and may contain arbitrary\n zeroes."]
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncfdplane_options {
    #[doc = " parameter provided to callbacks"]
    pub curry: *mut core::ffi::c_void,
    #[doc = " keep reading after hitting end? (think tail -f)"]
    pub follow: bool,
    #[doc = " bitfield over NCOPTION_FDPLANE_*"]
    pub flags: u64,
}
impl Default for ncfdplane_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " Create an ncfdplane around the fd 'fd'. Consider this function to take\n ownership of the file descriptor, which will be closed in ncfdplane_destroy()."]
    pub fn ncfdplane_create(
        n: *mut ncplane,
        opts: *const ncfdplane_options,
        fd: core::ffi::c_int,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncfdplane;
}
extern "C" {
    pub fn ncfdplane_plane(n: *mut ncfdplane) -> *mut ncplane;
}
extern "C" {
    pub fn ncfdplane_destroy(n: *mut ncfdplane) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncsubproc_options {
    pub curry: *mut core::ffi::c_void,
    #[doc = " restart this many seconds after an exit (watch)"]
    pub restart_period: u64,
    #[doc = " bitfield over NCOPTION_SUBPROC_*"]
    pub flags: u64,
}
impl Default for ncsubproc_options {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " see exec(2). p-types use $PATH. e-type passes environment vars."]
    pub fn ncsubproc_createv(
        n: *mut ncplane,
        opts: *const ncsubproc_options,
        bin: *const core::ffi::c_char,
        arg: *const *const core::ffi::c_char,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncsubproc;
}
extern "C" {
    pub fn ncsubproc_createvp(
        n: *mut ncplane,
        opts: *const ncsubproc_options,
        bin: *const core::ffi::c_char,
        arg: *const *const core::ffi::c_char,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncsubproc;
}
extern "C" {
    pub fn ncsubproc_createvpe(
        n: *mut ncplane,
        opts: *const ncsubproc_options,
        bin: *const core::ffi::c_char,
        arg: *const *const core::ffi::c_char,
        env: *const *const core::ffi::c_char,
        cbfxn: ncfdplane_callback,
        donecbfxn: ncfdplane_done_cb,
    ) -> *mut ncsubproc;
}
extern "C" {
    pub fn ncsubproc_plane(n: *mut ncsubproc) -> *mut ncplane;
}
extern "C" {
    pub fn ncsubproc_destroy(n: *mut ncsubproc) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Draw a QR code at the current position on the plane. If there is insufficient\n room to draw the code here, or there is any other error, non-zero will be\n returned. Otherwise, the QR code \"version\" (size) is returned. The QR code\n is (version * 4 + 17) columns wide, and ⌈version * 4 + 17⌉ rows tall (the\n properly-scaled values are written back to '*ymax' and '*xmax')."]
    pub fn ncplane_qrcode(
        n: *mut ncplane,
        ymax: *mut core::ffi::c_uint,
        xmax: *mut core::ffi::c_uint,
        data: *const core::ffi::c_void,
        len: usize,
    ) -> core::ffi::c_int;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct ncreader_options {
    #[doc = " channels used for input"]
    pub tchannels: u64,
    #[doc = " attributes used for input"]
    pub tattrword: u32,
    #[doc = " bitfield of NCREADER_OPTION_*"]
    pub flags: u64,
}
extern "C" {
    #[doc = " ncreaders provide freeform input in a (possibly multiline) region, supporting\n optional readline keybindings. takes ownership of 'n', destroying it on any\n error (ncreader_destroy() otherwise destroys the ncplane)."]
    pub fn ncreader_create(n: *mut ncplane, opts: *const ncreader_options) -> *mut ncreader;
}
extern "C" {
    #[doc = " empty the ncreader of any user input, and home the cursor."]
    pub fn ncreader_clear(n: *mut ncreader) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncreader_plane(n: *mut ncreader) -> *mut ncplane;
}
extern "C" {
    #[doc = " Offer the input to the ncreader. If it's relevant, this function returns\n true, and the input ought not be processed further. Almost all inputs\n are relevant to an ncreader, save synthesized ones."]
    pub fn ncreader_offer_input(n: *mut ncreader, ni: *const ncinput) -> bool;
}
extern "C" {
    #[doc = " Atttempt to move in the specified direction. Returns 0 if a move was\n successfully executed, -1 otherwise. Scrolling is taken into account."]
    pub fn ncreader_move_left(n: *mut ncreader) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncreader_move_right(n: *mut ncreader) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncreader_move_up(n: *mut ncreader) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncreader_move_down(n: *mut ncreader) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Destructively write the provided EGC to the current cursor location. Move\n the cursor as necessary, scrolling if applicable."]
    pub fn ncreader_write_egc(n: *mut ncreader, egc: *const core::ffi::c_char) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " return a heap-allocated copy of the current (UTF-8) contents."]
    pub fn ncreader_contents(n: *const ncreader) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " destroy the reader and its bound plane. if 'contents' is not NULL, the\n UTF-8 input will be heap-duplicated and written to 'contents'."]
    pub fn ncreader_destroy(n: *mut ncreader, contents: *mut *mut core::ffi::c_char);
}
extern "C" {
    #[doc = " Returns a heap-allocated copy of the user name under which we are running."]
    pub fn notcurses_accountname() -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns a heap-allocated copy of the local host name."]
    pub fn notcurses_hostname() -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Returns a heap-allocated copy of human-readable OS name and version."]
    pub fn notcurses_osversion() -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Dump selected Notcurses state to the supplied 'debugfp'. Output is freeform,\n newline-delimited, and subject to change. It includes geometry of all\n planes, from all piles. No line has more than 80 columns' worth of output."]
    pub fn notcurses_debug(nc: *const notcurses, debugfp: *mut FILE);
}
extern "C" {
    #[doc = " Initialize a direct-mode Notcurses context on the connected terminal at 'fp'.\n 'fp' must be a tty. You'll usually want stdout. Direct mode supports a\n limited subset of Notcurses routines which directly affect 'fp', and neither\n supports nor requires notcurses_render(). This can be used to add color and\n styling to text in the standard output paradigm. 'flags' is a bitmask over\n NCDIRECT_OPTION_*.\n Returns NULL on error, including any failure initializing terminfo."]
    pub fn ncdirect_init(
        termtype: *const core::ffi::c_char,
        fp: *mut FILE,
        flags: u64,
    ) -> *mut ncdirect;
}
extern "C" {
    #[doc = " The same as ncdirect_init(), but without any multimedia functionality,\n allowing for a svelter binary. Link with notcurses-core if this is used."]
    pub fn ncdirect_core_init(
        termtype: *const core::ffi::c_char,
        fp: *mut FILE,
        flags: u64,
    ) -> *mut ncdirect;
}
extern "C" {
    #[doc = " Read a (heap-allocated) newline-delimited chunk of text, after printing the\n prompt. The newline itself, if present, is included. Returns NULL on error."]
    pub fn ncdirect_readline(
        nc: *mut ncdirect,
        prompt: *const core::ffi::c_char,
    ) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Direct mode. This API can be used to colorize and stylize output generated\n outside of notcurses, without ever calling notcurses_render(). These should\n not be intermixed with standard Notcurses rendering."]
    pub fn ncdirect_set_fg_rgb(nc: *mut ncdirect, rgb: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_set_bg_rgb(nc: *mut ncdirect, rgb: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_set_fg_palindex(nc: *mut ncdirect, pidx: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_set_bg_palindex(nc: *mut ncdirect, pidx: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Returns the number of simultaneous colors claimed to be supported, or 1 if\n there is no color support. Note that several terminal emulators advertise\n more colors than they actually support, downsampling internally."]
    pub fn ncdirect_palette_size(nc: *const ncdirect) -> core::ffi::c_uint;
}
extern "C" {
    #[doc = " Output the string |utf8| according to the channels |channels|. Note that\n ncdirect_putstr() does not explicitly flush output buffers, so it will not\n necessarily be immediately visible. Returns EOF on error."]
    pub fn ncdirect_putstr(
        nc: *mut ncdirect,
        channels: u64,
        utf8: *const core::ffi::c_char,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Output a single EGC (this might be several characters) from |utf8|,\n according to the channels |channels|. On success, the number of columns\n thought to have been used is returned, and if |sbytes| is not NULL,\n the number of bytes consumed will be written there."]
    pub fn ncdirect_putegc(
        nc: *mut ncdirect,
        channels: u64,
        utf8: *const core::ffi::c_char,
        sbytes: *mut core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Formatted printing (plus alignment relative to the terminal). Returns the\n number of columns printed on success."]
    pub fn ncdirect_printf_aligned(
        n: *mut ncdirect,
        y: core::ffi::c_int,
        align: ncalign_e,
        fmt: *const core::ffi::c_char,
        ...
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Force a flush. Returns 0 on success, -1 on failure."]
    pub fn ncdirect_flush(nc: *const ncdirect) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_set_fg_default(nc: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_set_bg_default(nc: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the current number of columns/rows."]
    pub fn ncdirect_dim_x(nc: *mut ncdirect) -> core::ffi::c_uint;
}
extern "C" {
    pub fn ncdirect_dim_y(nc: *mut ncdirect) -> core::ffi::c_uint;
}
extern "C" {
    #[doc = " Returns a 16-bit bitmask of supported curses-style attributes\n (NCSTYLE_UNDERLINE, NCSTYLE_BOLD, etc.) The attribute is only\n indicated as supported if the terminal can support it together with color.\n For more information, see the \"ncv\" capability in terminfo(5)."]
    pub fn ncdirect_supported_styles(nc: *const ncdirect) -> u16;
}
extern "C" {
    #[doc = " ncplane_styles_*() analogues"]
    pub fn ncdirect_set_styles(n: *mut ncdirect, stylebits: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_on_styles(n: *mut ncdirect, stylebits: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_off_styles(n: *mut ncdirect, stylebits: core::ffi::c_uint) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_styles(n: *const ncdirect) -> u16;
}
extern "C" {
    #[doc = " Move the cursor in direct mode. -1 to retain current location on that axis."]
    pub fn ncdirect_cursor_move_yx(
        n: *mut ncdirect,
        y: core::ffi::c_int,
        x: core::ffi::c_int,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_enable(nc: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_disable(nc: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_up(nc: *mut ncdirect, num: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_left(nc: *mut ncdirect, num: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_right(nc: *mut ncdirect, num: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_down(nc: *mut ncdirect, num: core::ffi::c_int) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Get the cursor position, when supported. This requires writing to the\n terminal, and then reading from it. If the terminal doesn't reply, or\n doesn't reply in a way we understand, the results might be deleterious."]
    pub fn ncdirect_cursor_yx(
        n: *mut ncdirect,
        y: *mut core::ffi::c_uint,
        x: *mut core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Push or pop the cursor location to the terminal's stack. The depth of this\n stack, and indeed its existence, is terminal-dependent."]
    pub fn ncdirect_cursor_push(n: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_cursor_pop(n: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Clear the screen."]
    pub fn ncdirect_clear(nc: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_capabilities(n: *const ncdirect) -> *const nccapabilities;
}
extern "C" {
    #[doc = " Draw horizontal/vertical lines using the specified channels, interpolating\n between them as we go. The EGC may not use more than one column. For a\n horizontal line, |len| cannot exceed the screen width minus the cursor's\n offset. For a vertical line, it may be as long as you'd like; the screen\n will scroll as necessary. All lines start at the current cursor position."]
    pub fn ncdirect_hline_interp(
        n: *mut ncdirect,
        egc: *const core::ffi::c_char,
        len: core::ffi::c_uint,
        h1: u64,
        h2: u64,
    ) -> core::ffi::c_int;
}
extern "C" {
    pub fn ncdirect_vline_interp(
        n: *mut ncdirect,
        egc: *const core::ffi::c_char,
        len: core::ffi::c_uint,
        h1: u64,
        h2: u64,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Draw a box with its upper-left corner at the current cursor position, having\n dimensions |ylen|x|xlen|. See ncplane_box() for more information. The\n minimum box size is 2x2, and it cannot be drawn off-screen. |wchars| is an\n array of 6 wide characters: UL, UR, LL, LR, HL, VL."]
    pub fn ncdirect_box(
        n: *mut ncdirect,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
        wchars: *const wchar_t,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
        ctlword: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " ncdirect_box() with the rounded box-drawing characters"]
    pub fn ncdirect_rounded_box(
        n: *mut ncdirect,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
        ctlword: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " ncdirect_box() with the double box-drawing characters"]
    pub fn ncdirect_double_box(
        n: *mut ncdirect,
        ul: u64,
        ur: u64,
        ll: u64,
        lr: u64,
        ylen: core::ffi::c_uint,
        xlen: core::ffi::c_uint,
        ctlword: core::ffi::c_uint,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Provide a NULL 'ts' to block at length, a 'ts' of 0 for non-blocking\n operation, and otherwise an absolute deadline in terms of CLOCK_MONOTONIC.\n Returns a single Unicode code point, a synthesized special key constant,\n or (uint32_t)-1 on error. Returns 0 on a timeout. If an event is processed,\n the return value is the 'id' field from that event. 'ni' may be NULL."]
    pub fn ncdirect_get(n: *mut ncdirect, absdl: *const timespec, ni: *mut ncinput) -> u32;
}
extern "C" {
    #[doc = " Get a file descriptor suitable for input event poll()ing. When this\n descriptor becomes available, you can call ncdirect_get_nblock(),\n and input ought be ready. This file descriptor is *not* necessarily\n the file descriptor associated with stdin (but it might be!)."]
    pub fn ncdirect_inputready_fd(n: *mut ncdirect) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Release 'nc' and any associated resources. 0 on success, non-0 on failure."]
    pub fn ncdirect_stop(nc: *mut ncdirect) -> core::ffi::c_int;
}
pub type ncdirectv = ncplane;
pub type ncdirectf = ncvisual;
extern "C" {
    #[doc = " Display an image using the specified blitter and scaling. The image may\n be arbitrarily many rows -- the output will scroll -- but will only occupy\n the column of the cursor, and those to the right. The render/raster process\n can be split by using ncdirect_render_frame() and ncdirect_raster_frame()."]
    pub fn ncdirect_render_image(
        n: *mut ncdirect,
        filename: *const core::ffi::c_char,
        align: ncalign_e,
        blitter: ncblitter_e,
        scale: ncscale_e,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Render an image using the specified blitter and scaling, but do not write\n the result. The image may be arbitrarily many rows -- the output will scroll\n -- but will only occupy the column of the cursor, and those to the right.\n To actually write (and free) this, invoke ncdirect_raster_frame(). 'maxx'\n and 'maxy' (cell geometry, *not* pixel), if greater than 0, are used for\n scaling; the terminal's geometry is otherwise used."]
    pub fn ncdirect_render_frame(
        n: *mut ncdirect,
        filename: *const core::ffi::c_char,
        blitter: ncblitter_e,
        scale: ncscale_e,
        maxy: core::ffi::c_int,
        maxx: core::ffi::c_int,
    ) -> *mut ncdirectv;
}
extern "C" {
    #[doc = " Takes the result of ncdirect_render_frame() and writes it to the output,\n freeing it on all paths."]
    pub fn ncdirect_raster_frame(
        n: *mut ncdirect,
        ncdv: *mut ncdirectv,
        align: ncalign_e,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Load media from disk, but do not yet render it (presumably because you want\n to get its geometry via ncdirectf_geom(), or to use the same file with\n ncdirect_render_loaded_frame() multiple times). You must destroy the result\n with ncdirectf_free();"]
    pub fn ncdirectf_from_file(
        n: *mut ncdirect,
        filename: *const core::ffi::c_char,
    ) -> *mut ncdirectf;
}
extern "C" {
    #[doc = " Free a ncdirectf returned from ncdirectf_from_file()."]
    pub fn ncdirectf_free(frame: *mut ncdirectf);
}
extern "C" {
    #[doc = " Same as ncdirect_render_frame(), except 'frame' must already have been\n loaded. A loaded frame may be rendered in different ways before it is\n destroyed."]
    pub fn ncdirectf_render(
        n: *mut ncdirect,
        frame: *mut ncdirectf,
        vopts: *const ncvisual_options,
    ) -> *mut ncdirectv;
}
extern "C" {
    #[doc = " Having loaded the frame 'frame', get the geometry of a potential render."]
    pub fn ncdirectf_geom(
        n: *mut ncdirect,
        frame: *mut ncdirectf,
        vopts: *const ncvisual_options,
        geom: *mut ncvgeom,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Load successive frames from a file, invoking 'streamer' on each."]
    pub fn ncdirect_stream(
        n: *mut ncdirect,
        filename: *const core::ffi::c_char,
        streamer: ncstreamcb,
        vopts: *mut ncvisual_options,
        curry: *mut core::ffi::c_void,
    ) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Capabilites"]
    pub fn ncdirect_detected_terminal(n: *const ncdirect) -> *mut core::ffi::c_char;
}
extern "C" {
    #[doc = " Is our encoding UTF-8? Requires LANG being set to a UTF8 locale."]
    pub fn ncdirect_canutf8(n: *const ncdirect) -> bool;
}
extern "C" {
    #[doc = " Can we blit pixel-accurate bitmaps?"]
    pub fn ncdirect_check_pixel_support(n: *const ncdirect) -> core::ffi::c_int;
}
extern "C" {
    #[doc = " Is there support for acquiring the cursor's current position? Requires the\n u7 terminfo capability, and that we are connected to an actual terminal."]
    pub fn ncdirect_canget_cursor(nc: *const ncdirect) -> bool;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct __va_list_tag {
    pub gp_offset: core::ffi::c_uint,
    pub fp_offset: core::ffi::c_uint,
    pub overflow_arg_area: *mut core::ffi::c_void,
    pub reg_save_area: *mut core::ffi::c_void,
}
impl Default for __va_list_tag {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
